# å åœæ¨¡å—æ•°æ®å½’æ¡£åŠŸèƒ½è®¾è®¡æ–¹æ¡ˆ

## ğŸ“‹ å½’æ¡£åŠŸèƒ½æ¦‚è¿°

æ•°æ®å½’æ¡£æ˜¯ä»‹äº"ä¿ç•™"å’Œ"åˆ é™¤"ä¹‹é—´çš„ä¸­é—´çŠ¶æ€ï¼Œå…è®¸ç”¨æˆ·å°†ä¸å¸¸ç”¨çš„å åœè®°å½•ç§»è‡³ä½æˆæœ¬å­˜å‚¨ï¼ŒåŒæ—¶ä¿ç•™æ¢å¤èƒ½åŠ›ã€‚

### å½’æ¡£ vs åˆ é™¤å¯¹æ¯”

| ç‰¹æ€§ | å½’æ¡£ (Archive) | åˆ é™¤ (Delete) |
|-----|---------------|--------------|
| **æ•°æ®ä¿ç•™** | âœ… ä¿ç•™åœ¨é“¾ä¸‹/IPFS | âŒ å®Œå…¨æ¸…é™¤ |
| **å¯æ¢å¤æ€§** | âœ… å¯æ¢å¤åˆ°é“¾ä¸Š | âŒ ä¸å¯æ¢å¤ |
| **æŠ¼é‡‘å¤„ç†** | ğŸ”„ éƒ¨åˆ†é€€è¿˜(50%) | âœ… å…¨é¢é€€è¿˜(100%) |
| **å­˜å‚¨æˆæœ¬** | ğŸ’° ä½æˆæœ¬(IPFS) | ğŸ’° æ— æˆæœ¬ |
| **æŸ¥è¯¢é€Ÿåº¦** | ğŸŒ è¾ƒæ…¢(éœ€è§£æ¡£) | âš¡ N/A |
| **é€‚ç”¨åœºæ™¯** | å†å²è®°å½•ä¿å­˜ | æµ‹è¯•æ•°æ®æ¸…ç† |

---

## ğŸ¯ å½’æ¡£åŠŸèƒ½ç›®æ ‡

### æ ¸å¿ƒç›®æ ‡
1. **é™ä½é“¾ä¸Šå­˜å‚¨å‹åŠ›**ï¼šå°†å†å²æ•°æ®è¿ç§»åˆ°IPFS
2. **ä¿ç•™æ•°æ®å®Œæ•´æ€§**ï¼šç”¨æˆ·å¯éšæ—¶æ¢å¤å½’æ¡£æ•°æ®
3. **ç»æµæ¿€åŠ±å¹³è¡¡**ï¼šå½’æ¡£é€€è¿˜éƒ¨åˆ†æŠ¼é‡‘ï¼Œé¼“åŠ±ç”¨æˆ·æ•´ç†æ•°æ®
4. **çµæ´»çš„å­˜å‚¨ç­–ç•¥**ï¼šç”¨æˆ·è‡ªä¸»é€‰æ‹©ä¿ç•™/å½’æ¡£/åˆ é™¤

### ä¸šåŠ¡ä»·å€¼
- **ç”¨æˆ·ä»·å€¼**ï¼šé•¿æœŸä¿å­˜å†å²å åœè®°å½•ï¼Œé™ä½æŒæœ‰æˆæœ¬
- **ç³»ç»Ÿä»·å€¼**ï¼šå‡å°‘é“¾ä¸Šå­˜å‚¨ï¼Œæå‡èŠ‚ç‚¹æ€§èƒ½
- **ç»æµä»·å€¼**ï¼šæŠ¼é‡‘éƒ¨åˆ†é€€è¿˜ï¼Œæ¿€åŠ±ç”¨æˆ·ä¸»åŠ¨å½’æ¡£

---

## ğŸ—ï¸ å½’æ¡£æ¶æ„è®¾è®¡

### 1. ä¸‰å±‚å­˜å‚¨æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ä¸‰å±‚å­˜å‚¨æ¶æ„                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 1: é“¾ä¸Šçƒ­å­˜å‚¨ (Active Storage)                        â”‚
â”‚  â”œâ”€ å­˜å‚¨ä½ç½®: Substrate Storage                              â”‚
â”‚  â”œâ”€ æ•°æ®ç±»å‹: æ´»è·ƒå åœè®°å½•                                    â”‚
â”‚  â”œâ”€ æŸ¥è¯¢é€Ÿåº¦: âš¡ æå¿« (ç›´æ¥è¯»å–)                              â”‚
â”‚  â”œâ”€ å­˜å‚¨æˆæœ¬: ğŸ’°ğŸ’°ğŸ’° é«˜ (å…¨é¢æŠ¼é‡‘)                           â”‚
â”‚  â””â”€ é€‚ç”¨åœºæ™¯: è¿‘æœŸåˆ›å»ºã€é¢‘ç¹æŸ¥è¯¢çš„è®°å½•                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 2: IPFSæ¸©å­˜å‚¨ (Archived Storage)                      â”‚
â”‚  â”œâ”€ å­˜å‚¨ä½ç½®: IPFS (pallet-stardust-ipfs)                    â”‚
â”‚  â”œâ”€ æ•°æ®ç±»å‹: å½’æ¡£å åœè®°å½•                                    â”‚
â”‚  â”œâ”€ æŸ¥è¯¢é€Ÿåº¦: ğŸŒ è¾ƒæ…¢ (éœ€è§£æ¡£æ¢å¤)                            â”‚
â”‚  â”œâ”€ å­˜å‚¨æˆæœ¬: ğŸ’° ä½ (50%æŠ¼é‡‘é€€è¿˜)                            â”‚
â”‚  â””â”€ é€‚ç”¨åœºæ™¯: å†å²è®°å½•ã€ä¸å¸¸æŸ¥è¯¢çš„æ•°æ®                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 3: é“¾ä¸Šç´¢å¼• (Archive Index)                           â”‚
â”‚  â”œâ”€ å­˜å‚¨ä½ç½®: Substrate Storage                              â”‚
â”‚  â”œâ”€ æ•°æ®ç±»å‹: å½’æ¡£è®°å½•å…ƒä¿¡æ¯ + IPFS CID                       â”‚
â”‚  â”œâ”€ æŸ¥è¯¢é€Ÿåº¦: âš¡ å¿« (ç´¢å¼•æŸ¥è¯¢)                                â”‚
â”‚  â”œâ”€ å­˜å‚¨æˆæœ¬: ğŸ’° æä½ (~200 bytes)                           â”‚
â”‚  â””â”€ é€‚ç”¨åœºæ™¯: å½’æ¡£è®°å½•æ£€ç´¢ã€æ¢å¤å®šä½                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. å½’æ¡£çŠ¶æ€æœº

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Active    â”‚ æ´»è·ƒçŠ¶æ€ï¼ˆé“¾ä¸Šï¼‰
â”‚  (100%æŠ¼é‡‘) â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ archive_record()
       â”‚ â†“ ä¸Šä¼ IPFS + æ¸…ç†é“¾ä¸Šæ•°æ®
       â”‚ â†“ é€€è¿˜50%æŠ¼é‡‘
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚  Archived   â”‚ å½’æ¡£çŠ¶æ€ï¼ˆIPFSï¼‰
â”‚  (50%æŠ¼é‡‘)  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â†’ unarchive_record()
       â”‚   â†“ ä»IPFSæ¢å¤ + è¡¥å……æŠ¼é‡‘
       â”‚   â†“ é”å®šå‰©ä½™50%æŠ¼é‡‘
       â”‚   â””â”€â†’ è¿”å› Active
       â”‚
       â””â”€â†’ delete_archived_record()
           â†“ æ¸…ç†IPFS + æ¸…ç†ç´¢å¼•
           â†“ é€€è¿˜å‰©ä½™50%æŠ¼é‡‘
           â””â”€â†’ Deleted (å®Œå…¨åˆ é™¤)
```

---

## ğŸ’¾ æ•°æ®ç»“æ„è®¾è®¡

### 1. å½’æ¡£è®°å½•ç´¢å¼•

```rust
/// å½’æ¡£è®°å½•ç´¢å¼•ï¼ˆé“¾ä¸Šè½»é‡çº§å­˜å‚¨ï¼‰
#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug, TypeInfo, MaxEncodedLen)]
#[scale_info(skip_type_params(T))]
pub struct ArchivedRecordIndex<T: Config> {
    /// åŸè®°å½•ID
    pub record_id: u64,
    
    /// å åœç±»å‹
    pub divination_type: DivinationType,
    
    /// æ‰€æœ‰è€…
    pub owner: T::AccountId,
    
    /// IPFS CIDï¼ˆå®Œæ•´æ•°æ®ï¼‰
    pub ipfs_cid: BoundedVec<u8, ConstU32<64>>,
    
    /// æ•°æ®å“ˆå¸Œï¼ˆå®Œæ•´æ€§æ ¡éªŒï¼‰
    pub data_hash: [u8; 32],
    
    /// å½’æ¡£æ—¶é—´
    pub archived_at: BlockNumberFor<T>,
    
    /// åŸåˆ›å»ºæ—¶é—´
    pub created_at: BlockNumberFor<T>,
    
    /// å‰©ä½™æŠ¼é‡‘ï¼ˆUSDTï¼‰
    pub remaining_deposit_usdt: u32,
    
    /// å‰©ä½™æŠ¼é‡‘ï¼ˆDUSTï¼‰
    pub remaining_deposit_dust: BalanceOf<T>,
    
    /// å½’æ¡£æ—¶æ±‡ç‡
    pub archive_exchange_rate: u64,
    
    /// å…ƒæ•°æ®ï¼ˆå¯é€‰ï¼‰
    pub metadata: Option<ArchivedMetadata>,
}

/// å½’æ¡£å…ƒæ•°æ®ï¼ˆä¾¿äºæ£€ç´¢ï¼‰
#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug, TypeInfo, MaxEncodedLen)]
pub struct ArchivedMetadata {
    /// æ ‡é¢˜/æè¿°ï¼ˆå¯é€‰ï¼‰
    pub title: Option<BoundedVec<u8, ConstU32<128>>>,
    
    /// æ ‡ç­¾ï¼ˆå¯é€‰ï¼‰
    pub tags: BoundedVec<BoundedVec<u8, ConstU32<32>>, ConstU32<5>>,
    
    /// éšç§æ¨¡å¼
    pub privacy_mode: PrivacyMode,
    
    /// æ•°æ®å¤§å°ï¼ˆå­—èŠ‚ï¼‰
    pub data_size: u32,
}
```

### 2. å½’æ¡£é…ç½®

```rust
/// å½’æ¡£é…ç½®å‚æ•°
#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug, TypeInfo)]
pub struct ArchiveConfig {
    /// æ˜¯å¦å¯ç”¨å½’æ¡£åŠŸèƒ½
    pub enabled: bool,
    
    /// å½’æ¡£æŠ¼é‡‘é€€è¿˜æ¯”ä¾‹ï¼ˆåŸºç‚¹ï¼Œ10000 = 100%ï¼‰
    pub refund_ratio_bps: u16,  // é»˜è®¤ 5000 = 50%
    
    /// æœ€å°å½’æ¡£å¹´é¾„ï¼ˆåŒºå—æ•°ï¼‰
    pub min_archive_age: u32,  // é»˜è®¤ 100,800 = 7å¤©
    
    /// IPFSå­˜å‚¨å±‚çº§
    pub ipfs_tier: IpfsTier,  // Standard/Temporary
    
    /// å½’æ¡£æ•°æ®ä¿ç•™æœŸï¼ˆåŒºå—æ•°ï¼‰
    pub retention_period: u32,  // é»˜è®¤ 5,259,600 = 1å¹´
    
    /// æ¯æ¬¡å½’æ¡£è´¹ç”¨ï¼ˆUSDTï¼‰
    pub archive_fee_usdt: u32,  // é»˜è®¤ 0.1 USDT
    
    /// æ¯æ¬¡è§£æ¡£è´¹ç”¨ï¼ˆUSDTï¼‰
    pub unarchive_fee_usdt: u32,  // é»˜è®¤ 0.2 USDT
    
    /// æœ€å¤§å½’æ¡£è®°å½•æ•°ï¼ˆæ¯ç”¨æˆ·ï¼‰
    pub max_archived_per_user: u32,  // é»˜è®¤ 100
}

impl Default for ArchiveConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            refund_ratio_bps: 5000,      // 50%é€€è¿˜
            min_archive_age: 100_800,    // 7å¤©
            ipfs_tier: IpfsTier::Standard,
            retention_period: 5_259_600, // 1å¹´
            archive_fee_usdt: 100_000,   // 0.1 USDT
            unarchive_fee_usdt: 200_000, // 0.2 USDT
            max_archived_per_user: 100,
        }
    }
}

/// IPFSå­˜å‚¨å±‚çº§
#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug, TypeInfo)]
pub enum IpfsTier {
    Standard,   // æ ‡å‡†å±‚ï¼š3å‰¯æœ¬ï¼Œ24å°æ—¶å·¡æ£€
    Temporary,  // ä¸´æ—¶å±‚ï¼š1å‰¯æœ¬ï¼Œ7å¤©å·¡æ£€ï¼ˆæ›´ä¾¿å®œï¼‰
}
```

### 3. å­˜å‚¨é¡¹å®šä¹‰

```rust
/// å½’æ¡£é…ç½®
#[pallet::storage]
pub type ArchiveConfigStorage<T: Config> = StorageValue<
    _,
    ArchiveConfig,
    ValueQuery,
>;

/// å½’æ¡£è®°å½•ç´¢å¼•
#[pallet::storage]
pub type ArchivedRecordIndexes<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    (DivinationType, u64), // (ç±»å‹, è®°å½•ID)
    ArchivedRecordIndex<T>,
>;

/// ç”¨æˆ·å½’æ¡£è®°å½•åˆ—è¡¨
#[pallet::storage]
pub type UserArchivedRecords<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::AccountId,
    BoundedVec<(DivinationType, u64), ConstU32<100>>,
    ValueQuery,
>;

/// å½’æ¡£ç»Ÿè®¡
#[pallet::storage]
pub type ArchiveStats<T: Config> = StorageValue<
    _,
    ArchiveStatistics,
    ValueQuery,
>;

/// å½’æ¡£ç»Ÿè®¡æ•°æ®
#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug, TypeInfo, Default)]
pub struct ArchiveStatistics {
    /// æ€»å½’æ¡£è®°å½•æ•°
    pub total_archived: u64,
    
    /// æ€»è§£æ¡£è®°å½•æ•°
    pub total_unarchived: u64,
    
    /// å½“å‰å½’æ¡£è®°å½•æ•°
    pub current_archived: u64,
    
    /// æ€»èŠ‚çœå­˜å‚¨ç©ºé—´ï¼ˆå­—èŠ‚ï¼‰
    pub total_space_saved: u64,
    
    /// æ€»é€€è¿˜æŠ¼é‡‘ï¼ˆUSDTï¼‰
    pub total_refunded_usdt: u64,
}
```

---

## ğŸ”§ æ ¸å¿ƒåŠŸèƒ½å®ç°

### 1. å½’æ¡£è®°å½•

```rust
/// å½’æ¡£å åœè®°å½•
#[pallet::call_index(100)]
#[pallet::weight(T::WeightInfo::archive_record())]
pub fn archive_record(
    origin: OriginFor<T>,
    record_id: u64,
    divination_type: DivinationType,
    metadata: Option<ArchivedMetadata>,
) -> DispatchResult {
    let who = ensure_signed(origin)?;
    
    // 1. éªŒè¯æ‰€æœ‰æƒ
    Self::ensure_record_owner(&who, record_id, divination_type)?;
    
    // 2. æ£€æŸ¥å½’æ¡£æ¡ä»¶
    Self::check_archive_conditions(&who, record_id, divination_type)?;
    
    // 3. åºåˆ—åŒ–å®Œæ•´æ•°æ®
    let full_data = Self::serialize_record(record_id, divination_type)?;
    
    // 4. ä¸Šä¼ åˆ°IPFS
    let ipfs_cid = Self::upload_to_ipfs(&who, &full_data, divination_type)?;
    
    // 5. è®¡ç®—é€€è¿˜æŠ¼é‡‘
    let (refund_usdt, refund_dust, remaining_usdt, remaining_dust) = 
        Self::calculate_archive_refund(record_id, divination_type)?;
    
    // 6. é€€è¿˜éƒ¨åˆ†æŠ¼é‡‘
    Self::refund_partial_deposit(&who, refund_dust)?;
    
    // 7. æ¸…ç†é“¾ä¸Šæ•°æ®
    Self::clear_onchain_data(record_id, divination_type)?;
    
    // 8. åˆ›å»ºå½’æ¡£ç´¢å¼•
    let archive_index = ArchivedRecordIndex {
        record_id,
        divination_type,
        owner: who.clone(),
        ipfs_cid: ipfs_cid.clone(),
        data_hash: Self::hash_data(&full_data),
        archived_at: <frame_system::Pallet<T>>::block_number(),
        created_at: Self::get_record_created_at(record_id, divination_type)?,
        remaining_deposit_usdt: remaining_usdt,
        remaining_deposit_dust: remaining_dust,
        archive_exchange_rate: T::ExchangeRateProvider::get_rate()?,
        metadata,
    };
    
    ArchivedRecordIndexes::<T>::insert(
        (divination_type, record_id),
        archive_index,
    );
    
    // 9. æ›´æ–°ç”¨æˆ·å½’æ¡£åˆ—è¡¨
    UserArchivedRecords::<T>::mutate(&who, |records| {
        let _ = records.try_push((divination_type, record_id));
    });
    
    // 10. æ›´æ–°ç»Ÿè®¡
    ArchiveStats::<T>::mutate(|stats| {
        stats.total_archived = stats.total_archived.saturating_add(1);
        stats.current_archived = stats.current_archived.saturating_add(1);
        stats.total_space_saved = stats.total_space_saved
            .saturating_add(full_data.len() as u64);
        stats.total_refunded_usdt = stats.total_refunded_usdt
            .saturating_add(refund_usdt as u64);
    });
    
    // 11. å‘å‡ºäº‹ä»¶
    Self::deposit_event(Event::RecordArchived {
        record_id,
        divination_type,
        owner: who,
        ipfs_cid,
        refunded_usdt: refund_usdt,
        refunded_dust: refund_dust,
    });
    
    Ok(())
}
```

### 2. è§£æ¡£è®°å½•

```rust
/// è§£æ¡£å åœè®°å½•ï¼ˆæ¢å¤åˆ°é“¾ä¸Šï¼‰
#[pallet::call_index(101)]
#[pallet::weight(T::WeightInfo::unarchive_record())]
pub fn unarchive_record(
    origin: OriginFor<T>,
    record_id: u64,
    divination_type: DivinationType,
) -> DispatchResult {
    let who = ensure_signed(origin)?;
    
    // 1. è·å–å½’æ¡£ç´¢å¼•
    let archive_index = ArchivedRecordIndexes::<T>::get((divination_type, record_id))
        .ok_or(Error::<T>::ArchiveNotFound)?;
    
    // 2. éªŒè¯æ‰€æœ‰æƒ
    ensure!(
        archive_index.owner == who,
        Error::<T>::NotArchiveOwner
    );
    
    // 3. ä»IPFSè·å–æ•°æ®
    let full_data = Self::fetch_from_ipfs(&archive_index.ipfs_cid)?;
    
    // 4. éªŒè¯æ•°æ®å®Œæ•´æ€§
    ensure!(
        Self::hash_data(&full_data) == archive_index.data_hash,
        Error::<T>::DataIntegrityCheckFailed
    );
    
    // 5. è®¡ç®—éœ€è¦è¡¥å……çš„æŠ¼é‡‘
    let additional_deposit = Self::calculate_unarchive_deposit(
        &archive_index,
        divination_type,
    )?;
    
    // 6. æ”¶å–è§£æ¡£è´¹ç”¨
    let unarchive_fee = Self::calculate_unarchive_fee()?;
    T::Currency::transfer(
        &who,
        &T::TreasuryAccount::get(),
        unarchive_fee,
        ExistenceRequirement::KeepAlive,
    )?;
    
    // 7. é”å®šè¡¥å……æŠ¼é‡‘
    T::Currency::reserve(&who, additional_deposit)?;
    
    // 8. ååºåˆ—åŒ–å¹¶æ¢å¤é“¾ä¸Šæ•°æ®
    Self::deserialize_and_restore(record_id, divination_type, &full_data)?;
    
    // 9. æ¸…ç†å½’æ¡£ç´¢å¼•
    ArchivedRecordIndexes::<T>::remove((divination_type, record_id));
    
    // 10. æ›´æ–°ç”¨æˆ·å½’æ¡£åˆ—è¡¨
    UserArchivedRecords::<T>::mutate(&who, |records| {
        records.retain(|&(t, id)| !(t == divination_type && id == record_id));
    });
    
    // 11. æ›´æ–°ç»Ÿè®¡
    ArchiveStats::<T>::mutate(|stats| {
        stats.total_unarchived = stats.total_unarchived.saturating_add(1);
        stats.current_archived = stats.current_archived.saturating_sub(1);
    });
    
    // 12. å‘å‡ºäº‹ä»¶
    Self::deposit_event(Event::RecordUnarchived {
        record_id,
        divination_type,
        owner: who,
        additional_deposit,
    });
    
    Ok(())
}
```

### 3. åˆ é™¤å½’æ¡£è®°å½•

```rust
/// åˆ é™¤å½’æ¡£è®°å½•ï¼ˆå®Œå…¨æ¸…é™¤ï¼‰
#[pallet::call_index(102)]
#[pallet::weight(T::WeightInfo::delete_archived_record())]
pub fn delete_archived_record(
    origin: OriginFor<T>,
    record_id: u64,
    divination_type: DivinationType,
) -> DispatchResult {
    let who = ensure_signed(origin)?;
    
    // 1. è·å–å½’æ¡£ç´¢å¼•
    let archive_index = ArchivedRecordIndexes::<T>::get((divination_type, record_id))
        .ok_or(Error::<T>::ArchiveNotFound)?;
    
    // 2. éªŒè¯æ‰€æœ‰æƒ
    ensure!(
        archive_index.owner == who,
        Error::<T>::NotArchiveOwner
    );
    
    // 3. è¯·æ±‚IPFSå–æ¶ˆå›ºå®šï¼ˆå¯é€‰ï¼‰
    let _ = Self::request_ipfs_unpin(&archive_index.ipfs_cid);
    
    // 4. é€€è¿˜å‰©ä½™æŠ¼é‡‘
    T::Currency::unreserve(&who, archive_index.remaining_deposit_dust);
    
    // 5. æ¸…ç†å½’æ¡£ç´¢å¼•
    ArchivedRecordIndexes::<T>::remove((divination_type, record_id));
    
    // 6. æ›´æ–°ç”¨æˆ·å½’æ¡£åˆ—è¡¨
    UserArchivedRecords::<T>::mutate(&who, |records| {
        records.retain(|&(t, id)| !(t == divination_type && id == record_id));
    });
    
    // 7. è®°å½•åˆ é™¤æ—¥å¿—
    DeletedRecords::<T>::insert(
        (divination_type, record_id),
        DeletedRecord {
            record_id,
            divination_type,
            owner: who.clone(),
            deleted_at: <frame_system::Pallet<T>>::block_number(),
            refunded_deposit: archive_index.remaining_deposit_dust,
            reason: Some(b"Archived record deleted".to_vec().try_into().unwrap()),
        },
    );
    
    // 8. æ›´æ–°ç»Ÿè®¡
    ArchiveStats::<T>::mutate(|stats| {
        stats.current_archived = stats.current_archived.saturating_sub(1);
    });
    
    // 9. å‘å‡ºäº‹ä»¶
    Self::deposit_event(Event::ArchivedRecordDeleted {
        record_id,
        divination_type,
        owner: who,
        refunded_usdt: archive_index.remaining_deposit_usdt,
        refunded_dust: archive_index.remaining_deposit_dust,
    });
    
    Ok(())
}
```

### 4. è¾…åŠ©å‡½æ•°

```rust
/// æ£€æŸ¥å½’æ¡£æ¡ä»¶
fn check_archive_conditions(
    who: &T::AccountId,
    record_id: u64,
    divination_type: DivinationType,
) -> DispatchResult {
    let config = ArchiveConfigStorage::<T>::get();
    
    // 1. å½’æ¡£åŠŸèƒ½å·²å¯ç”¨
    ensure!(config.enabled, Error::<T>::ArchiveDisabled);
    
    // 2. è®°å½•å­˜åœ¨ä¸”æ´»è·ƒ
    ensure!(
        Self::record_exists(record_id, divination_type),
        Error::<T>::RecordNotFound
    );
    
    // 3. è®°å½•å¹´é¾„æ»¡è¶³è¦æ±‚
    let created_at = Self::get_record_created_at(record_id, divination_type)?;
    let current_block = <frame_system::Pallet<T>>::block_number();
    let age = current_block.saturating_sub(created_at);
    
    ensure!(
        age >= config.min_archive_age.into(),
        Error::<T>::RecordTooYoung
    );
    
    // 4. ç”¨æˆ·å½’æ¡£æ•°é‡æœªè¶…é™
    let user_archived = UserArchivedRecords::<T>::get(who);
    ensure!(
        user_archived.len() < config.max_archived_per_user as usize,
        Error::<T>::TooManyArchivedRecords
    );
    
    // 5. è®°å½•æœªè¢«é”å®š
    ensure!(
        !Self::is_record_locked(record_id),
        Error::<T>::RecordLocked
    );
    
    // 6. æ— NFTå…³è”
    ensure!(
        !Self::has_nft_minted(record_id),
        Error::<T>::NftAlreadyMinted
    );
    
    Ok(())
}

/// è®¡ç®—å½’æ¡£é€€è¿˜æŠ¼é‡‘
fn calculate_archive_refund(
    record_id: u64,
    divination_type: DivinationType,
) -> Result<(u32, BalanceOf<T>, u32, BalanceOf<T>), DispatchError> {
    let config = ArchiveConfigStorage::<T>::get();
    
    // è·å–åŸæŠ¼é‡‘è®°å½•
    let deposit_record = DivinationDepositRecords::<T>::get((divination_type, record_id))
        .ok_or(Error::<T>::DepositRecordNotFound)?;
    
    // è®¡ç®—é€€è¿˜é‡‘é¢ï¼ˆ50%ï¼‰
    let refund_usdt = deposit_record.deposit_usdt
        .saturating_mul(config.refund_ratio_bps as u32)
        .saturating_div(10000);
    
    let refund_dust = deposit_record.deposit_dust
        .saturating_mul(config.refund_ratio_bps.into())
        .saturating_div(10000u32.into());
    
    // è®¡ç®—å‰©ä½™é‡‘é¢ï¼ˆ50%ï¼‰
    let remaining_usdt = deposit_record.deposit_usdt.saturating_sub(refund_usdt);
    let remaining_dust = deposit_record.deposit_dust.saturating_sub(refund_dust);
    
    Ok((refund_usdt, refund_dust, remaining_usdt, remaining_dust))
}

/// åºåˆ—åŒ–è®°å½•æ•°æ®
fn serialize_record(
    record_id: u64,
    divination_type: DivinationType,
) -> Result<Vec<u8>, DispatchError> {
    match divination_type {
        DivinationType::Bazi => {
            let chart = pallet_bazi::ChartById::<T>::get(record_id)
                .ok_or(Error::<T>::RecordNotFound)?;
            Ok(chart.encode())
        },
        DivinationType::Ziwei => {
            let chart = pallet_ziwei::Charts::<T>::get(record_id)
                .ok_or(Error::<T>::RecordNotFound)?;
            Ok(chart.encode())
        },
        DivinationType::Liuyao => {
            let gua = pallet_liuyao::Guas::<T>::get(record_id)
                .ok_or(Error::<T>::RecordNotFound)?;
            Ok(gua.encode())
        },
        // ... å…¶ä»–å åœç±»å‹
        _ => Err(Error::<T>::UnsupportedDivinationType.into()),
    }
}

/// ä¸Šä¼ åˆ°IPFS
fn upload_to_ipfs(
    who: &T::AccountId,
    data: &[u8],
    divination_type: DivinationType,
) -> Result<BoundedVec<u8, ConstU32<64>>, DispatchError> {
    let config = ArchiveConfigStorage::<T>::get();
    
    // ä½¿ç”¨pallet-stardust-ipfsä¸Šä¼ 
    let ipfs_tier = match config.ipfs_tier {
        IpfsTier::Standard => pallet_stardust_ipfs::PinTier::Standard,
        IpfsTier::Temporary => pallet_stardust_ipfs::PinTier::Temporary,
    };
    
    // ç”ŸæˆCIDï¼ˆå®é™…å®ç°éœ€è¦è°ƒç”¨IPFSæ¥å£ï¼‰
    let cid = Self::generate_ipfs_cid(data)?;
    
    // è¯·æ±‚å›ºå®š
    T::IpfsPinner::pin_cid(
        who.clone(),
        cid.clone(),
        Some(ipfs_tier),
    )?;
    
    Ok(cid)
}
```

