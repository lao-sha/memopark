# 买家信用 - 连续作恶处理机制分析与改进

**日期**: 2025-10-21  
**模块**: `pallet-buyer-credit`（买家信用风控管理）  
**分析目标**: 评估当前连续作恶处理机制的完整性，并提出改进建议

---

## 一、当前连续作恶处理机制

### 1.1 违约惩罚流程（`penalize_default`）

**触发条件**：
- OTC 订单超时未付款（48小时）
- 调用方：`pallet-otc-order::refund_on_timeout`

**惩罚步骤**：

#### 步骤 1：违约次数累加
```rust
credit.default_count += 1;
```

#### 步骤 2：风险分增加（等级越高，惩罚越轻）
```rust
let penalty = match credit.level {
    CreditLevel::Newbie => 50,   // 新手：+50分
    CreditLevel::Bronze => 30,   // 铜牌：+30分
    CreditLevel::Silver => 20,   // 银牌：+20分
    CreditLevel::Gold => 10,     // 金牌：+10分
    CreditLevel::Diamond => 5,   // 钻石：+5分
};
credit.risk_score = credit.risk_score.saturating_add(penalty);
```

#### 步骤 3：推荐关系失效 + 推荐人连带责任
```rust
// 使所有推荐失效
Endorsements::<T>::mutate(buyer, |endorsements| {
    for endorsement in endorsements.iter_mut() {
        endorsement.is_active = false;
        
        // 推荐人连带责任（风险分 +50）
        BuyerCredit::<T>::mutate(&endorsement.endorser, |endorser_credit| {
            endorser_credit.risk_score = endorser_credit.risk_score.saturating_add(50);
        });
    }
});
```

#### 步骤 4：触发事件
```rust
Event::DefaultPenalty {
    account: buyer.clone(),
    penalty,
    new_risk_score: credit.risk_score,
}
```

---

### 1.2 风险分禁止交易机制

**检查位置**：`check_buyer_limit` 函数

```rust
// 检查信用分（风险分 > 800 禁止交易）
ensure!(credit.risk_score <= 800, Error::<T>::CreditScoreTooLow);
```

**禁止交易阈值**：
- 风险分 > 800：**禁止创建任何 OTC 订单**

---

### 1.3 违约累计示例

**场景：用户连续违约 3 次**

| 违约次数 | 初始风险分 | 单次惩罚 | 累计惩罚 | 新风险分 | 是否禁止 |
|---------|-----------|---------|---------|---------|---------|
| 0 | 400 | - | - | 400 | ❌ 允许 |
| 1 | 400 | +30 | +30 | 430 | ❌ 允许 |
| 2 | 430 | +30 | +60 | 460 | ❌ 允许 |
| 3 | 460 | +30 | +90 | 490 | ❌ 允许 |

**Bronze 级别用户**：需要 **14 次连续违约** 才会被禁止（400 + 30 * 14 = 820 > 800）

---

## 二、当前机制存在的问题

### 问题 1：⚠️ **连续违约惩罚不够严厉**

**问题描述**：
- 单次违约惩罚：30-50分
- 禁止交易阈值：800分
- Bronze 用户需要 **14 次连续违约** 才会被禁止

**风险分析**：
- ❌ 恶意用户可以多次下单不付款（14 次）
- ❌ 浪费做市商资源（锁单 48 小时）
- ❌ 影响正常用户体验（订单被恶意占用）

**示例攻击**：
```
攻击者策略：
  1. 注册账户，初始风险分 400
  2. 连续下单 14 次，每次都超时不付款
  3. 累计风险分：400 + 30 * 14 = 820
  4. 第 15 次才被禁止
  
成本：0 DUST（下单无需抵押）
收益：扰乱市场 + 锁定做市商资金 14 * 48小时 = 672小时
```

---

### 问题 2：⚠️ **缺乏连续违约加速惩罚机制**

**问题描述**：
- 当前惩罚是固定的（每次 +30分）
- 无论是第 1 次违约还是第 10 次违约，惩罚都一样

**建议机制**：
- ✅ 连续违约应该 **指数级惩罚**
- ✅ 第 1 次违约：+30分
- ✅ 第 2 次违约：+60分（2倍）
- ✅ 第 3 次违约：+120分（4倍）
- ✅ 第 4 次违约：直接封禁

---

### 问题 3：⚠️ **缺乏短时间内连续违约检测**

**问题描述**：
- 当前只记录 `default_count`（累计违约次数）
- 无法区分"一周内连续 3 次违约"和"一年内分散 3 次违约"

**风险分析**：
- ❌ 短时间内频繁违约是典型的恶意行为
- ❌ 长时间偶尔违约可能是正常情况（如网络问题）
- ❌ 两者应区别对待

---

### 问题 4：⚠️ **推荐人连带责任固定惩罚过轻**

**问题描述**：
- 被推荐人违约 1 次：推荐人 +50分
- 被推荐人违约 10 次：推荐人仍然只 +50分（因为推荐关系在第 1 次违约后就失效了）

**问题**：
- ❌ 推荐人可能会推荐 10 个新用户，每人违约 1 次
- ❌ 推荐人承担：10 * 50 = 500分惩罚（但换取了 10 * 40 = 400分加成）
- ❌ 推荐人仍然有利可图

---

### 问题 5：⚠️ **缺乏"冷却期"机制**

**问题描述**：
- 用户违约后，可以立即再次下单
- 无冷却期限制

**风险分析**：
- ❌ 恶意用户可以连续快速违约
- ❌ 无法给予用户"改过自新"的缓冲期

---

## 三、改进方案设计

### 方案 A：连续违约指数级惩罚（推荐）

#### 核心逻辑

```rust
/// 函数级中文注释：违约惩罚（带连续违约检测）
pub fn penalize_default(buyer: &T::AccountId) {
    BuyerCredit::<T>::mutate(buyer, |credit| {
        credit.default_count += 1;
        
        // 🆕 检测连续违约（7天内的违约次数）
        let recent_defaults = Self::count_recent_defaults(buyer, 7 * DAYS);
        
        // 基础惩罚
        let base_penalty = match credit.level {
            CreditLevel::Newbie => 50,
            CreditLevel::Bronze => 30,
            CreditLevel::Silver => 20,
            CreditLevel::Gold => 10,
            CreditLevel::Diamond => 5,
        };
        
        // 🆕 连续违约加速惩罚（指数级）
        let penalty = match recent_defaults {
            1 => base_penalty,                    // 第1次：1x
            2 => base_penalty * 2,                // 第2次：2x
            3 => base_penalty * 4,                // 第3次：4x
            4 => base_penalty * 8,                // 第4次：8x（一般这时已超过800）
            _ => base_penalty * 16,               // 第5次+：16x（确保封禁）
        };
        
        credit.risk_score = credit.risk_score.saturating_add(penalty);
        
        // 🆕 短时间内连续违约 ≥ 3次，直接封禁
        if recent_defaults >= 3 {
            credit.risk_score = 1000; // 直接设置为最高风险分
            
            Self::deposit_event(Event::UserBanned {
                account: buyer.clone(),
                reason: "连续违约3次",
            });
        }
        
        Self::deposit_event(Event::DefaultPenalty {
            account: buyer.clone(),
            penalty,
            consecutive_defaults: recent_defaults,
            new_risk_score: credit.risk_score,
        });
    });
    
    // 推荐关系失效 + 推荐人连带责任（同现有逻辑）
    // ...
}

/// 函数级中文注释：统计近期违约次数
fn count_recent_defaults(buyer: &T::AccountId, within_blocks: BlockNumber) -> u32 {
    let current_block = <frame_system::Pallet<T>>::block_number();
    let cutoff_block = current_block.saturating_sub(within_blocks);
    
    DefaultHistory::<T>::get(buyer)
        .iter()
        .filter(|&block| *block >= cutoff_block)
        .count() as u32
}
```

#### 效果对比

| 违约次数 | 基础惩罚 | 旧机制累计风险分 | **新机制累计风险分** | 是否禁止 |
|---------|---------|----------------|-------------------|---------|
| 1 | +30 | 430 | **430** | ❌ |
| 2 | +60 | 460 | **490 (430+60)** | ❌ |
| 3 | +120 | 490 | **直接封禁（1000）** | ✅ **封禁** |

**优势**：
- ✅ **3 次连续违约即封禁**（旧机制需要 14 次）
- ✅ 恶意用户成本大幅提高
- ✅ 保护做市商资源

---

### 方案 B：违约冷却期机制

#### 核心逻辑

```rust
/// 函数级中文注释：检查是否在冷却期内
pub fn check_buyer_limit(buyer: &T::AccountId, amount_usdt: u64) -> Result<(), Error<T>> {
    let mut credit = BuyerCredit::<T>::get(buyer);
    
    // 如果是新用户（未初始化），先初始化
    if credit.account_created_at.is_zero() {
        let _tier = Self::initialize_new_user_credit(buyer);
        credit = BuyerCredit::<T>::get(buyer);
    }
    
    // 检查信用分（风险分 > 800 禁止交易）
    ensure!(credit.risk_score <= 800, Error::<T>::CreditScoreTooLow);
    
    // 🆕 检查违约冷却期
    if credit.default_count > 0 {
        let cooldown_blocks = Self::calculate_cooldown_period(&credit);
        let current_block = <frame_system::Pallet<T>>::block_number();
        let last_default_block = DefaultHistory::<T>::get(buyer)
            .last()
            .copied()
            .unwrap_or(Zero::zero());
        let required_block = last_default_block.saturating_add(cooldown_blocks);
        
        ensure!(current_block >= required_block, Error::<T>::InCooldownPeriod);
    }
    
    // ... 其他检查逻辑
}

/// 函数级中文注释：计算冷却期（违约次数越多，冷却期越长）
fn calculate_cooldown_period(credit: &CreditScore<T>) -> BlockNumber {
    let recent_defaults = Self::count_recent_defaults(&credit, 30 * DAYS);
    
    let cooldown_days = match recent_defaults {
        0 => 0,
        1 => 1,      // 第1次违约：冷却1天
        2 => 3,      // 第2次违约：冷却3天
        3 => 7,      // 第3次违约：冷却7天
        4 => 14,     // 第4次违约：冷却14天
        _ => 30,     // 第5次+违约：冷却30天
    };
    
    T::BlocksPerDay::get().saturating_mul(cooldown_days.into())
}
```

#### 效果

| 违约次数 | 冷却期 | 说明 |
|---------|--------|------|
| 0 | 无 | 正常用户 |
| 1 | 1 天 | 轻微警告 |
| 2 | 3 天 | 严重警告 |
| 3 | 7 天 | 临时封禁 |
| 4 | 14 天 | 长期封禁 |
| 5+ | 30 天 | 超长封禁 |

**优势**：
- ✅ 给予用户"改过自新"的机会
- ✅ 防止恶意用户快速连续违约
- ✅ 时间成本惩罚（比风险分更直观）

---

### 方案 C：推荐人梯度连带责任

#### 核心逻辑

```rust
/// 函数级中文注释：违约惩罚（推荐人梯度连带）
pub fn penalize_default(buyer: &T::AccountId) {
    // ... 买家惩罚逻辑 ...
    
    // 🆕 推荐人梯度连带责任
    Endorsements::<T>::mutate(buyer, |endorsements| {
        for endorsement in endorsements.iter_mut() {
            if endorsement.is_active {
                endorsement.is_active = false;
                
                // 根据被推荐人的违约次数，梯度惩罚推荐人
                let endorsee_defaults = BuyerCredit::<T>::get(buyer).default_count;
                
                let penalty = match endorsee_defaults {
                    1 => 50,        // 第1次违约：+50分
                    2 => 100,       // 第2次违约：+100分
                    3 => 200,       // 第3次违约：+200分
                    _ => 500,       // 第4次+违约：+500分（严重连带）
                };
                
                BuyerCredit::<T>::mutate(&endorsement.endorser, |endorser_credit| {
                    endorser_credit.risk_score = endorser_credit.risk_score.saturating_add(penalty);
                });
                
                Self::deposit_event(Event::EndorserPenalized {
                    endorser: endorsement.endorser.clone(),
                    endorsee: buyer.clone(),
                    penalty,
                });
            }
        }
    });
}
```

#### 效果

| 被推荐人违约次数 | 旧机制推荐人惩罚 | **新机制推荐人惩罚** |
|----------------|----------------|-------------------|
| 1 | +50 | +50 |
| 2 | ~~+0~~（推荐已失效） | **+100** |
| 3 | ~~+0~~ | **+200** |
| 4+ | ~~+0~~ | **+500** |

**优势**：
- ✅ 推荐人对被推荐人的持续行为负责
- ✅ 提高推荐门槛，减少"滥推荐"
- ✅ 更真实的社交信任网络

---

### 方案 D：违约黑名单机制（严格版）

#### 核心逻辑

```rust
/// 函数级中文注释：检查是否在黑名单中
pub fn check_buyer_limit(buyer: &T::AccountId, amount_usdt: u64) -> Result<(), Error<T>> {
    // 🆕 检查黑名单
    ensure!(!Blacklist::<T>::contains_key(buyer), Error::<T>::UserBlacklisted);
    
    // ... 其他检查逻辑
}

/// 函数级中文注释：违约惩罚（含黑名单判定）
pub fn penalize_default(buyer: &T::AccountId) {
    // ... 违约惩罚逻辑 ...
    
    // 🆕 连续违约 ≥ 3次，加入黑名单
    let recent_defaults = Self::count_recent_defaults(buyer, 30 * DAYS);
    
    if recent_defaults >= 3 {
        Blacklist::<T>::insert(buyer, current_block);
        
        Self::deposit_event(Event::UserBlacklisted {
            account: buyer.clone(),
            reason: "30天内连续违约3次",
            banned_until: current_block + 90 * DAYS, // 黑名单期限：90天
        });
    }
}

/// 函数级中文注释：治理解除黑名单（Root 权限）
#[pallet::call_index(10)]
pub fn unban_user(
    origin: OriginFor<T>,
    who: T::AccountId,
) -> DispatchResult {
    ensure_root(origin)?;
    
    Blacklist::<T>::remove(&who);
    
    Self::deposit_event(Event::UserUnbanned {
        account: who,
    });
    
    Ok(())
}
```

#### 特点

- ✅ **硬性禁止**：黑名单用户无法下单（比风险分更严格）
- ✅ **有限期**：黑名单期限 90 天，给予用户恢复机会
- ✅ **治理解除**：Root 可手动解除（特殊情况）

---

## 四、推荐实施方案

### 阶段 1：立即实施（核心防护）

✅ **方案 A：连续违约指数级惩罚**
- 代码修改量：中等（~50 行）
- 效果：显著（3 次违约即封禁）
- 优先级：🔴 高

✅ **方案 B：违约冷却期机制**
- 代码修改量：小（~30 行）
- 效果：中等（时间成本惩罚）
- 优先级：🟡 中

### 阶段 2：后续优化（社交防护）

✅ **方案 C：推荐人梯度连带责任**
- 代码修改量：小（~20 行）
- 效果：中等（提高推荐质量）
- 优先级：🟡 中

### 阶段 3：长期完善（治理工具）

✅ **方案 D：违约黑名单机制**
- 代码修改量：中等（~60 行 + 治理接口）
- 效果：高（硬性封禁）
- 优先级：🟢 低（可选）

---

## 五、数据结构扩展

### 新增存储

```rust
/// 函数级中文注释：违约历史记录（用于连续违约检测）
#[pallet::storage]
pub type DefaultHistory<T: Config> = 
    StorageMap<_, Blake2_128Concat, T::AccountId, BoundedVec<BlockNumberFor<T>, ConstU32<50>>, ValueQuery>;

/// 函数级中文注释：黑名单（含封禁到期时间）
#[pallet::storage]
pub type Blacklist<T: Config> = 
    StorageMap<_, Blake2_128Concat, T::AccountId, BlockNumberFor<T>, OptionQuery>;
```

### 新增事件

```rust
/// 连续违约封禁
UserBanned {
    account: T::AccountId,
    reason: BoundedVec<u8, ConstU32<128>>,
},

/// 推荐人被连带惩罚
EndorserPenalized {
    endorser: T::AccountId,
    endorsee: T::AccountId,
    penalty: u16,
},

/// 用户加入黑名单
UserBlacklisted {
    account: T::AccountId,
    reason: BoundedVec<u8, ConstU32<128>>,
    banned_until: BlockNumberFor<T>,
},

/// 用户解除黑名单
UserUnbanned {
    account: T::AccountId,
},
```

### 新增错误

```rust
/// 用户在冷却期内
InCooldownPeriod,

/// 用户在黑名单中
UserBlacklisted,
```

---

## 六、效果对比总结

| 机制 | 旧方案 | **新方案（方案A+B）** | 改进效果 |
|------|-------|---------------------|---------|
| **封禁条件** | 14次连续违约 | **3次连续违约** | ✅ 提升 78% |
| **单次惩罚** | 固定 +30分 | **指数级（30/60/120/...）** | ✅ 动态惩罚 |
| **冷却期** | ❌ 无 | **1/3/7/14/30天** | ✅ 时间成本 |
| **推荐人惩罚** | 仅第1次 +50 | **梯度（50/100/200/500）** | ✅ 持续连带 |
| **恶意成本** | 14次 * 48h = 672h | **3次 * 48h = 144h** | ✅ 降低 79% |

---

## 七、安全性分析

### 潜在风险

#### 风险 1：误判正常用户

**场景**：用户因网络问题连续 3 次超时

**缓解措施**：
- ✅ 保留风险分恢复机制（完成订单可降低风险分）
- ✅ 冷却期而非永久封禁
- ✅ 治理可手动解除黑名单

#### 风险 2：推荐人过度惩罚

**场景**：推荐人好心推荐，但被推荐人连续违约

**缓解措施**：
- ✅ 推荐门槛（信用分 ≥ 700）
- ✅ 梯度惩罚（第1次 +50，不会直接严重）
- ✅ 推荐人可选择承担风险

---

## 八、前端集成

### 用户提示

**场景 1：用户在冷却期内**
```
⚠️ 您的账户因近期违约，暂时无法下单
冷却期剩余：2天5小时
建议：耐心等待冷却期结束，保持良好信用记录
```

**场景 2：用户连续违约警告**
```
⚠️ 警告：您已违约 2 次
- 再违约 1 次将被封禁
- 当前风险分：490 / 800
- 建议：确保按时付款，维护信用记录
```

**场景 3：用户被封禁**
```
❌ 您的账户已被暂时封禁
- 原因：30天内连续违约3次
- 封禁期限：90天
- 解封条件：等待期满或联系治理解封
```

---

## 九、实施建议

### 立即实施（高优先级）

1. ✅ **方案 A：连续违约指数级惩罚**
   - 修改 `penalize_default` 函数
   - 添加 `DefaultHistory` 存储
   - 添加 `count_recent_defaults` 函数
   - 测试：3次连续违约封禁

2. ✅ **方案 B：违约冷却期机制**
   - 修改 `check_buyer_limit` 函数
   - 添加 `calculate_cooldown_period` 函数
   - 测试：违约后冷却期生效

### 后续优化（中优先级）

3. ✅ **方案 C：推荐人梯度连带责任**
   - 修改 `penalize_default` 中的推荐人惩罚逻辑
   - 测试：被推荐人连续违约，推荐人梯度惩罚

### 长期完善（低优先级）

4. ✅ **方案 D：违约黑名单机制**
   - 添加 `Blacklist` 存储
   - 添加 `unban_user` extrinsic
   - 前端支持黑名单显示

---

## 十、总结

### 当前机制问题

- ⚠️ **惩罚过轻**：需要 14 次连续违约才封禁
- ⚠️ **无连续检测**：无法区分集中违约和分散违约
- ⚠️ **无冷却期**：恶意用户可以快速连续违约
- ⚠️ **推荐人惩罚不足**：仅第 1 次违约有惩罚

### 改进效果

- ✅ **封禁条件提升 78%**：14 次 → 3 次
- ✅ **恶意成本降低 79%**：672h → 144h
- ✅ **动态惩罚机制**：指数级惩罚 + 冷却期
- ✅ **社交网络保护**：推荐人梯度连带责任

### 实施难度

- 🟢 **代码修改量**：中等（~150 行新代码）
- 🟢 **测试成本**：中等（需要模拟连续违约场景）
- 🟢 **向后兼容**：完全兼容（仅扩展功能）

---

**报告生成时间**: 2025-10-21  
**分析结论**: ✅ **推荐立即实施方案 A + B**  
**核心理由**: 当前机制对连续作恶的惩罚过轻，需要引入指数级惩罚和冷却期机制  
**建议行动**: 优先实施连续违约指数级惩罚，保护做市商资源和正常用户体验

