# å…±äº«åª’ä½“å·¥å…·åº“é›†æˆæ–¹æ¡ˆè¯„ä¼°

## æ–‡æ¡£ä¿¡æ¯

- **åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ25æ—¥
- **ç‰ˆæœ¬**: v1.0
- **ç›®æ ‡**: è¯„ä¼° Deceasedã€GroupChatã€Evidence ä¸‰å¤§æ¨¡å—å¦‚ä½•é›†æˆ stardust-media-common å·¥å…·åº“
- **ä¾æ®æ–‡æ¡£**:
  - å…±äº«åª’ä½“å·¥å…·åº“è¯¦ç»†è®¾è®¡.md
  - åª’ä½“åˆ†æ•£å­˜å‚¨vsé›†ä¸­å­˜å‚¨-æ¶æ„åˆ†æ.md

---

## æ‰§è¡Œæ‘˜è¦

**æ€»ä½“è¯„ä¼°**: âœ… **ä¸‰ä¸ªæ¨¡å—å‡å¯å¹³æ»‘é›†æˆ** (é›†æˆéš¾åº¦: ä½ï¼Œæ”¶ç›Š: é«˜)

**æ ¸å¿ƒå‘ç°**:
- âœ… **é›¶ç ´åæ€§**: é›†æˆä¸éœ€è¦ä¿®æ”¹ç°æœ‰å­˜å‚¨ç»“æ„
- âœ… **æ¸è¿›å¼**: å¯ä»¥é€æ­¥æ›¿æ¢ç°æœ‰å®ç°
- âœ… **é«˜æ”¶ç›Š**: æ¶ˆé™¤é‡å¤ä»£ç ï¼Œæå‡ä»£ç è´¨é‡
- âœ… **ä½é£é™©**: å·¥å…·åº“ç‹¬ç«‹ï¼Œä¸å½±å“ä¸šåŠ¡é€»è¾‘

**å®æ–½å»ºè®®**: æŒ‰ Deceased â†’ Evidence â†’ GroupChat çš„é¡ºåºæ¸è¿›å¼é›†æˆ

---

## 1. Deceased æ¨¡å—é›†æˆè¯„ä¼°

### 1.1 å½“å‰å®ç°åˆ†æ

**æ–‡ä»¶ä½ç½®**: `pallets/deceased/src/media.rs`

**æ ¸å¿ƒæ•°æ®ç»“æ„**:
```rust
/// å½“å‰çš„åª’ä½“ç±»å‹
pub enum MediaKind {
    Photo,
    Video,
    Audio,
}

/// å½“å‰çš„åª’ä½“ç»“æ„
pub struct Media<T: Config> {
    pub id: T::MediaId,
    pub album_id: Option<T::AlbumId>,
    pub video_collection_id: Option<T::VideoCollectionId>,
    pub deceased_id: T::DeceasedId,
    pub kind: MediaKind,
    pub uri: BoundedVec<u8, T::StringLimit>,        // IPFS CID
    pub thumbnail_uri: Option<BoundedVec<u8, T::StringLimit>>,
    pub content_hash: Option<[u8; 32]>,
    pub duration_secs: Option<u32>,
    pub width: Option<u32>,
    pub height: Option<u32>,
    pub order_index: u32,
    pub created: BlockNumberFor<T>,
    pub updated: BlockNumberFor<T>,
    pub version: u32,
}
```

**å½“å‰ä¸Šä¼ æµç¨‹** (æ¨æµ‹):
```rust
impl<T: Config> Pallet<T> {
    pub fn upload_media(...) -> DispatchResult {
        // 1. ç›´æ¥æ¥æ”¶åª’ä½“æ•°æ®
        // 2. ç®€å•éªŒè¯ï¼ˆå¯èƒ½ä¸å®Œæ•´ï¼‰
        // 3. ç›´æ¥è°ƒç”¨ IPFS pallet
        // 4. åˆ›å»º Media è®°å½•
    }
}
```

### 1.2 é›†æˆæ–¹æ¡ˆè®¾è®¡

#### æ–¹æ¡ˆA: æœ€å°æ”¹åŠ¨é›†æˆï¼ˆæ¨èç”¨äºç¬¬ä¸€é˜¶æ®µï¼‰

**ç›®æ ‡**: å¿«é€Ÿå¼•å…¥å·¥å…·åº“ï¼ŒéªŒè¯å¯è¡Œæ€§

**æ”¹åŠ¨èŒƒå›´**: ä»…ä¿®æ”¹ `pallets/deceased/Cargo.toml` å’Œéƒ¨åˆ†å‡½æ•°å®ç°

```toml
# pallets/deceased/Cargo.toml

[dependencies]
# ... ç°æœ‰ä¾èµ–

# âœ… æ–°å¢å…±äº«å·¥å…·åº“ä¾èµ–
stardust-media-common = { path = "../../stardust-media-common", default-features = false }

[features]
default = ["std"]
std = [
    # ... ç°æœ‰ std features
    "stardust-media-common/std",
]
```

**é›†æˆç¤ºä¾‹ - ä¸Šä¼ ç…§ç‰‡åˆ°ç›¸å†Œ**:

```rust
// pallets/deceased/src/media.rs

use stardust_media_common::{
    MediaKind as CommonMediaKind,
    ImageValidator,
    HashHelper,
    MediaError,
};

impl<T: Config> Pallet<T> {
    /// âœ… ä¼˜åŒ–åçš„ç…§ç‰‡ä¸Šä¼  - ä½¿ç”¨å…±äº«å·¥å…·åº“
    pub fn upload_photo_to_album(
        origin: OriginFor<T>,
        deceased_id: T::DeceasedId,
        album_id: T::AlbumId,
        photo_data: Vec<u8>,
    ) -> DispatchResult {
        let who = ensure_signed(origin)?;

        // âœ… 1. ä½¿ç”¨å…±äº«å·¥å…·åº“éªŒè¯å›¾ç‰‡
        let metadata = ImageValidator::validate(&photo_data)
            .map_err(|e| match e {
                MediaError::FileTooSmall => Error::<T>::FileTooSmall,
                MediaError::FileTooLarge => Error::<T>::FileTooLarge,
                MediaError::UnsupportedFormat => Error::<T>::UnsupportedImageFormat,
                MediaError::ImageBomb => Error::<T>::ImageTooLarge,
                _ => Error::<T>::InvalidImage,
            })?;

        // âœ… 2. ä½¿ç”¨å…±äº«å·¥å…·åº“è®¡ç®—å†…å®¹å“ˆå¸Œ
        let content_hash = HashHelper::content_hash(&photo_data);

        // âœ… 3. ä¸Šä¼ åˆ° IPFSï¼ˆä¿æŒç°æœ‰é€»è¾‘ï¼‰
        let cid = T::IpfsPinner::request_pin_for_deceased(
            who.clone(),
            deceased_id.into(),
            photo_data.clone(),
            PinTier::Critical,
        )?;

        // âœ… 4. åˆ›å»ºåª’ä½“è®°å½•ï¼ˆä¿æŒç°æœ‰ç»“æ„ï¼‰
        let media = Media {
            id: Self::next_media_id(),
            album_id: Some(album_id),
            video_collection_id: None,
            deceased_id,
            deceased_token: Self::get_deceased_token(deceased_id)?,
            owner: who.clone(),
            kind: MediaKind::Photo,  // ä½¿ç”¨ç°æœ‰æšä¸¾
            uri: cid,
            thumbnail_uri: None,
            content_hash: Some(content_hash),
            width: metadata.width,
            height: metadata.height,
            duration_secs: None,
            order_index: Self::get_next_order_index(album_id),
            created: <frame_system::Pallet<T>>::block_number(),
            updated: <frame_system::Pallet<T>>::block_number(),
            version: 1,
        };

        MediaRegistry::<T>::insert(media.id, media.clone());

        Self::deposit_event(Event::PhotoUploaded {
            media_id: media.id,
            album_id,
            deceased_id,
            uploader: who,
        });

        Ok(())
    }

    /// âœ… ä¼˜åŒ–åçš„è§†é¢‘ä¸Šä¼  - ä½¿ç”¨å…±äº«å·¥å…·åº“
    pub fn upload_video_to_collection(
        origin: OriginFor<T>,
        deceased_id: T::DeceasedId,
        collection_id: T::VideoCollectionId,
        video_data: Vec<u8>,
    ) -> DispatchResult {
        let who = ensure_signed(origin)?;

        // âœ… 1. ä½¿ç”¨å…±äº«å·¥å…·åº“éªŒè¯è§†é¢‘
        let metadata = VideoValidator::validate(&video_data)
            .map_err(|e| match e {
                MediaError::FileTooSmall => Error::<T>::FileTooSmall,
                MediaError::FileTooLarge => Error::<T>::FileTooLarge,
                MediaError::UnsupportedFormat => Error::<T>::UnsupportedVideoFormat,
                MediaError::VideoTooLong => Error::<T>::VideoTooLong,
                _ => Error::<T>::InvalidVideo,
            })?;

        // âœ… 2. æ£€æŸ¥è§†é¢‘æ—¶é•¿ï¼ˆä½¿ç”¨å…±äº«å·¥å…·åº“ï¼‰
        if let Some(duration) = metadata.duration_secs {
            use stardust_media_common::VideoValidator;
            VideoValidator::check_duration(duration)
                .map_err(|_| Error::<T>::VideoTooLong)?;
        }

        // âœ… 3. è®¡ç®—å†…å®¹å“ˆå¸Œ
        let content_hash = HashHelper::content_hash(&video_data);

        // âœ… 4. ä¸Šä¼ åˆ° IPFS
        let cid = T::IpfsPinner::request_pin_for_deceased(
            who.clone(),
            deceased_id.into(),
            video_data,
            PinTier::Standard,
        )?;

        // âœ… 5. åˆ›å»ºåª’ä½“è®°å½•
        let media = Media {
            id: Self::next_media_id(),
            album_id: None,
            video_collection_id: Some(collection_id),
            deceased_id,
            deceased_token: Self::get_deceased_token(deceased_id)?,
            owner: who.clone(),
            kind: MediaKind::Video,
            uri: cid,
            thumbnail_uri: None,
            content_hash: Some(content_hash),
            width: metadata.width,
            height: metadata.height,
            duration_secs: metadata.duration_secs,
            order_index: Self::get_next_order_index_for_collection(collection_id),
            created: <frame_system::Pallet<T>>::block_number(),
            updated: <frame_system::Pallet<T>>::block_number(),
            version: 1,
        };

        MediaRegistry::<T>::insert(media.id, media.clone());

        Self::deposit_event(Event::VideoUploaded {
            media_id: media.id,
            collection_id,
            deceased_id,
            uploader: who,
        });

        Ok(())
    }

    /// âœ… æ–°å¢ï¼šéŸ³é¢‘ä¸Šä¼ ï¼ˆä¹‹å‰å¯èƒ½æ²¡æœ‰ç‹¬ç«‹å®ç°ï¼‰
    pub fn upload_audio_to_collection(
        origin: OriginFor<T>,
        deceased_id: T::DeceasedId,
        collection_id: T::VideoCollectionId,
        audio_data: Vec<u8>,
    ) -> DispatchResult {
        let who = ensure_signed(origin)?;

        // âœ… ä½¿ç”¨å…±äº«å·¥å…·åº“éªŒè¯éŸ³é¢‘
        let metadata = AudioValidator::validate(&audio_data)
            .map_err(|e| match e {
                MediaError::FileTooSmall => Error::<T>::FileTooSmall,
                MediaError::FileTooLarge => Error::<T>::FileTooLarge,
                MediaError::UnsupportedFormat => Error::<T>::UnsupportedAudioFormat,
                _ => Error::<T>::InvalidAudio,
            })?;

        let content_hash = HashHelper::content_hash(&audio_data);

        let cid = T::IpfsPinner::request_pin_for_deceased(
            who.clone(),
            deceased_id.into(),
            audio_data,
            PinTier::Standard,
        )?;

        let media = Media {
            id: Self::next_media_id(),
            album_id: None,
            video_collection_id: Some(collection_id),
            deceased_id,
            deceased_token: Self::get_deceased_token(deceased_id)?,
            owner: who.clone(),
            kind: MediaKind::Audio,
            uri: cid,
            thumbnail_uri: None,
            content_hash: Some(content_hash),
            width: None,
            height: None,
            duration_secs: metadata.duration_secs,
            order_index: Self::get_next_order_index_for_collection(collection_id),
            created: <frame_system::Pallet<T>>::block_number(),
            updated: <frame_system::Pallet<T>>::block_number(),
            version: 1,
        };

        MediaRegistry::<T>::insert(media.id, media.clone());

        Self::deposit_event(Event::AudioUploaded {
            media_id: media.id,
            collection_id,
            deceased_id,
            uploader: who,
        });

        Ok(())
    }
}
```

**æ–°å¢é”™è¯¯ç±»å‹** (åœ¨ `pallets/deceased/src/lib.rs`):

```rust
#[pallet::error]
pub enum Error<T> {
    // ... ç°æœ‰é”™è¯¯

    // âœ… æ–°å¢ï¼šåª’ä½“éªŒè¯é”™è¯¯
    FileTooSmall,
    FileTooLarge,
    UnsupportedImageFormat,
    UnsupportedVideoFormat,
    UnsupportedAudioFormat,
    InvalidImage,
    InvalidVideo,
    InvalidAudio,
    ImageTooLarge,
    VideoTooLong,
}
```

#### æ–¹æ¡ˆB: æ·±åº¦é›†æˆï¼ˆç¬¬äºŒé˜¶æ®µï¼Œå¯é€‰ï¼‰

**ç›®æ ‡**: å®Œå…¨æ›¿æ¢ç°æœ‰ç±»å‹ä¸ºå…±äº«ç±»å‹

**æ”¹åŠ¨èŒƒå›´**: ä¿®æ”¹ `MediaKind` æšä¸¾å®šä¹‰ï¼Œè¿ç§»åˆ°å…±äº«ç±»å‹

```rust
// pallets/deceased/src/media.rs

// âŒ åˆ é™¤æœ¬åœ°å®šä¹‰
// pub enum MediaKind {
//     Photo,
//     Video,
//     Audio,
// }

// âœ… ä½¿ç”¨å…±äº«ç±»å‹
pub use stardust_media_common::MediaKind;

// âœ… æˆ–è€…åˆ›å»ºç±»å‹åˆ«åï¼ˆä¿æŒå…¼å®¹æ€§ï¼‰
pub type MediaKind = stardust_media_common::MediaKind;
```

**æ³¨æ„**: è¿™éœ€è¦æ›´æ–°æ‰€æœ‰ä½¿ç”¨ `MediaKind` çš„åœ°æ–¹ï¼Œå½±å“èŒƒå›´è¾ƒå¤§ï¼Œå»ºè®®è°¨æ…è¯„ä¼°ã€‚

### 1.3 é›†æˆæ”¶ç›Šè¯„ä¼°

| æ”¶ç›Šç»´åº¦ | è¯„ä¼° | è¯´æ˜ |
|---------|------|------|
| **ä»£ç é‡å¤æ¶ˆé™¤** | âœ… é«˜ | å›¾ç‰‡/è§†é¢‘éªŒè¯é€»è¾‘ä¸å†é‡å¤ |
| **ä»£ç è´¨é‡æå‡** | âœ… é«˜ | ä¸“ä¸šçš„æ ¼å¼æ£€æµ‹å’Œå®‰å…¨æ£€æŸ¥ |
| **æ–°åŠŸèƒ½å¢å¼º** | âœ… ä¸­ | éŸ³é¢‘æ ¼å¼æ”¯æŒæ›´å®Œå–„ |
| **ç»´æŠ¤æˆæœ¬é™ä½** | âœ… é«˜ | æ ¼å¼æ›´æ–°åªéœ€æ›´æ–°å·¥å…·åº“ |
| **æµ‹è¯•è¦†ç›–æå‡** | âœ… é«˜ | å·¥å…·åº“æœ‰å®Œæ•´å•å…ƒæµ‹è¯• |

### 1.4 é›†æˆé£é™©è¯„ä¼°

| é£é™© | ç­‰çº§ | ç¼“è§£æªæ–½ |
|-----|------|---------|
| **ç¼–è¯‘é”™è¯¯** | ä½ | ç±»å‹è½¬æ¢æ¸…æ™°ï¼Œå·¥å…·åº“æ— ä¾èµ– |
| **åŠŸèƒ½å›å½’** | ä½ | ä¿æŒç°æœ‰ä¸šåŠ¡é€»è¾‘ä¸å˜ |
| **æ€§èƒ½å½±å“** | æä½ | å·¥å…·åº“çº¯å‡½æ•°ï¼Œæ— æ€§èƒ½å¼€é”€ |
| **ä¾èµ–å†²çª** | æä½ | å·¥å…·åº“é›¶è¿è¡Œæ—¶ä¾èµ– |

**æ€»ä½“é£é™©**: ğŸŸ¢ **ä½é£é™©**

---

## 2. Evidence æ¨¡å—é›†æˆè¯„ä¼°

### 2.1 å½“å‰å®ç°åˆ†æ

**æ–‡ä»¶ä½ç½®**: `pallets/evidence/src/lib.rs`

**æ ¸å¿ƒæ•°æ®ç»“æ„**:
```rust
/// å†…å®¹ç±»å‹
pub enum ContentType {
    Image,
    Video,
    Document,
    Mixed,
    Text,
}

/// è¯æ®è®°å½•ï¼ˆPhase 1.5 CIDåŒ–ç‰ˆæœ¬ï¼‰
pub struct Evidence<AccountId, BlockNumber, MaxContentCidLen, MaxSchemeLen> {
    pub id: u64,
    pub domain: u8,
    pub target_id: u64,
    pub owner: AccountId,
    pub content_cid: BoundedVec<u8, MaxContentCidLen>,  // IPFS CID
    pub content_type: ContentType,
    pub created_at: BlockNumber,
    pub is_encrypted: bool,
    pub encryption_scheme: Option<BoundedVec<u8, MaxSchemeLen>>,
    pub commit: Option<H256>,  // æ‰¿è¯ºå“ˆå¸Œ
    pub ns: Option<[u8; 8]>,   // å‘½åç©ºé—´
}
```

**IPFS å†…å®¹æ ¼å¼** (JSON):
```json
{
  "version": "1.0",
  "evidence_id": 123,
  "content": {
    "images": ["QmXxx1", "QmXxx2", ...],
    "videos": ["QmYyy1", ...],
    "documents": ["QmZzz1", ...],
    "memo": "å¯é€‰æ–‡å­—è¯´æ˜"
  },
  "metadata": {
    "created_at": 1234567890,
    "owner": "5GrwvaEF..."
  }
}
```

### 2.2 é›†æˆæ–¹æ¡ˆè®¾è®¡

#### é›†æˆç‚¹1: å†…å®¹éªŒè¯

**åœºæ™¯**: ç”¨æˆ·æäº¤è¯æ®æ—¶ï¼ŒéªŒè¯å›¾ç‰‡/è§†é¢‘æ ¼å¼

```rust
// pallets/evidence/src/lib.rs

use stardust_media_common::{
    ImageValidator,
    VideoValidator,
    HashHelper,
    MediaKind,
    MediaError,
};

impl<T: Config> Pallet<T> {
    /// âœ… æäº¤å›¾ç‰‡è¯æ®
    pub fn submit_image_evidence(
        origin: OriginFor<T>,
        domain: u8,
        target_id: u64,
        image_data: Vec<u8>,
        is_encrypted: bool,
    ) -> DispatchResult {
        let who = ensure_signed(origin)?;

        // âœ… 1. ä½¿ç”¨å…±äº«å·¥å…·åº“éªŒè¯å›¾ç‰‡
        let metadata = ImageValidator::validate(&image_data)
            .map_err(|e| match e {
                MediaError::FileTooSmall => Error::<T>::FileTooSmall,
                MediaError::FileTooLarge => Error::<T>::FileTooLarge,
                MediaError::UnsupportedFormat => Error::<T>::UnsupportedFormat,
                MediaError::ImageBomb => Error::<T>::ImageBomb,
                MediaError::SuspiciousContent => Error::<T>::SuspiciousContent,
                _ => Error::<T>::InvalidImage,
            })?;

        // âœ… 2. è®¡ç®—å†…å®¹å“ˆå¸Œ
        let content_hash = HashHelper::content_hash(&image_data);

        // âœ… 3. ä¸Šä¼ åˆ° IPFS
        let cid = T::IpfsPinner::request_pin(
            who.clone(),
            image_data,
            PinTier::Critical,  // è¯æ®ç”¨ Critical
        )?;

        // âœ… 4. è®¡ç®—æ‰¿è¯ºå“ˆå¸Œï¼ˆä½¿ç”¨å…±äº«å·¥å…·åº“ï¼‰
        let ns = Self::get_namespace(domain, target_id);
        let salt = Self::generate_salt();
        let commit = HashHelper::evidence_commitment(
            &ns,
            target_id,
            &cid,
            &salt,
            1, // version
        );

        // âœ… 5. åˆ›å»ºè¯æ®è®°å½•
        let evidence = Evidence {
            id: Self::next_evidence_id(),
            domain,
            target_id,
            owner: who.clone(),
            content_cid: cid,
            content_type: ContentType::Image,
            created_at: <frame_system::Pallet<T>>::block_number(),
            is_encrypted,
            encryption_scheme: None,
            commit: Some(commit),
            ns: Some(ns),
        };

        Evidences::<T>::insert(evidence.id, evidence.clone());

        Self::deposit_event(Event::EvidenceSubmitted {
            evidence_id: evidence.id,
            domain,
            target_id,
            submitter: who,
        });

        Ok(())
    }

    /// âœ… æäº¤è§†é¢‘è¯æ®
    pub fn submit_video_evidence(
        origin: OriginFor<T>,
        domain: u8,
        target_id: u64,
        video_data: Vec<u8>,
        is_encrypted: bool,
    ) -> DispatchResult {
        let who = ensure_signed(origin)?;

        // âœ… ä½¿ç”¨å…±äº«å·¥å…·åº“éªŒè¯è§†é¢‘
        let metadata = VideoValidator::validate(&video_data)
            .map_err(|e| match e {
                MediaError::FileTooSmall => Error::<T>::FileTooSmall,
                MediaError::FileTooLarge => Error::<T>::FileTooLarge,
                MediaError::UnsupportedFormat => Error::<T>::UnsupportedFormat,
                _ => Error::<T>::InvalidVideo,
            })?;

        // æ£€æŸ¥æ—¶é•¿
        if let Some(duration) = metadata.duration_secs {
            use stardust_media_common::VideoValidator;
            VideoValidator::check_duration(duration)
                .map_err(|_| Error::<T>::VideoTooLong)?;
        }

        let content_hash = HashHelper::content_hash(&video_data);

        let cid = T::IpfsPinner::request_pin(
            who.clone(),
            video_data,
            PinTier::Critical,
        )?;

        let ns = Self::get_namespace(domain, target_id);
        let salt = Self::generate_salt();
        let commit = HashHelper::evidence_commitment(&ns, target_id, &cid, &salt, 1);

        let evidence = Evidence {
            id: Self::next_evidence_id(),
            domain,
            target_id,
            owner: who.clone(),
            content_cid: cid,
            content_type: ContentType::Video,
            created_at: <frame_system::Pallet<T>>::block_number(),
            is_encrypted,
            encryption_scheme: None,
            commit: Some(commit),
            ns: Some(ns),
        };

        Evidences::<T>::insert(evidence.id, evidence.clone());

        Self::deposit_event(Event::EvidenceSubmitted {
            evidence_id: evidence.id,
            domain,
            target_id,
            submitter: who,
        });

        Ok(())
    }

    /// âœ… æäº¤æ··åˆè¯æ®ï¼ˆå¤šä¸ªå›¾ç‰‡/è§†é¢‘ï¼‰
    pub fn submit_mixed_evidence(
        origin: OriginFor<T>,
        domain: u8,
        target_id: u64,
        images: Vec<Vec<u8>>,
        videos: Vec<Vec<u8>>,
        documents: Vec<Vec<u8>>,
    ) -> DispatchResult {
        let who = ensure_signed(origin)?;

        // âœ… 1. éªŒè¯æ‰€æœ‰å›¾ç‰‡
        let mut image_cids = Vec::new();
        for image_data in images {
            let _metadata = ImageValidator::validate(&image_data)
                .map_err(|_| Error::<T>::InvalidImage)?;

            let cid = T::IpfsPinner::request_pin(
                who.clone(),
                image_data,
                PinTier::Critical,
            )?;

            image_cids.push(cid);
        }

        // âœ… 2. éªŒè¯æ‰€æœ‰è§†é¢‘
        let mut video_cids = Vec::new();
        for video_data in videos {
            let _metadata = VideoValidator::validate(&video_data)
                .map_err(|_| Error::<T>::InvalidVideo)?;

            let cid = T::IpfsPinner::request_pin(
                who.clone(),
                video_data,
                PinTier::Critical,
            )?;

            video_cids.push(cid);
        }

        // âœ… 3. ä¸Šä¼ æ–‡æ¡£ï¼ˆç®€å•éªŒè¯ï¼‰
        let mut document_cids = Vec::new();
        for doc_data in documents {
            // ç®€å•æ£€æŸ¥æ–‡ä»¶å¤§å°
            ensure!(
                doc_data.len() <= 50 * 1024 * 1024,
                Error::<T>::FileTooLarge
            );

            let cid = T::IpfsPinner::request_pin(
                who.clone(),
                doc_data,
                PinTier::Critical,
            )?;

            document_cids.push(cid);
        }

        // âœ… 4. æ„é€  JSON å†…å®¹
        let content_json = serde_json::json!({
            "version": "1.0",
            "evidence_id": Self::next_evidence_id(),
            "content": {
                "images": image_cids,
                "videos": video_cids,
                "documents": document_cids,
            },
            "metadata": {
                "created_at": <frame_system::Pallet<T>>::block_number(),
                "owner": format!("{:?}", who),
            }
        });

        let content_bytes = content_json.to_string().into_bytes();

        let content_cid = T::IpfsPinner::request_pin(
            who.clone(),
            content_bytes.clone(),
            PinTier::Critical,
        )?;

        // âœ… 5. è®¡ç®—æ‰¿è¯ºå“ˆå¸Œ
        let ns = Self::get_namespace(domain, target_id);
        let salt = Self::generate_salt();
        let commit = HashHelper::evidence_commitment(&ns, target_id, &content_cid, &salt, 1);

        let evidence = Evidence {
            id: Self::next_evidence_id(),
            domain,
            target_id,
            owner: who.clone(),
            content_cid,
            content_type: ContentType::Mixed,
            created_at: <frame_system::Pallet<T>>::block_number(),
            is_encrypted: false,
            encryption_scheme: None,
            commit: Some(commit),
            ns: Some(ns),
        };

        Evidences::<T>::insert(evidence.id, evidence.clone());

        Self::deposit_event(Event::EvidenceSubmitted {
            evidence_id: evidence.id,
            domain,
            target_id,
            submitter: who,
        });

        Ok(())
    }
}
```

### 2.3 é›†æˆæ”¶ç›Šè¯„ä¼°

| æ”¶ç›Šç»´åº¦ | è¯„ä¼° | è¯´æ˜ |
|---------|------|------|
| **å®‰å…¨æ€§æå‡** | âœ… æé«˜ | ä¸“ä¸šçš„å›¾ç‰‡ç‚¸å¼¹æ£€æµ‹ã€æ¶æ„å†…å®¹æ£€æµ‹ |
| **å®Œæ•´æ€§ä¿è¯** | âœ… é«˜ | æ ‡å‡†åŒ–çš„å“ˆå¸Œè®¡ç®—ï¼ˆcontent_hash + commitmentï¼‰ |
| **æ ¼å¼æ”¯æŒ** | âœ… é«˜ | æ›´å®Œå–„çš„å›¾ç‰‡/è§†é¢‘æ ¼å¼æ£€æµ‹ |
| **è¯æ®å¯ä¿¡åº¦** | âœ… é«˜ | æ›´ä¸¥æ ¼çš„éªŒè¯æå‡è¯æ®æ³•å¾‹æ•ˆåŠ› |

### 2.4 é›†æˆé£é™©è¯„ä¼°

| é£é™© | ç­‰çº§ | ç¼“è§£æªæ–½ |
|-----|------|---------|
| **æ€§èƒ½å½±å“** | ä½ | éªŒè¯é€»è¾‘é«˜æ•ˆï¼Œå·¥å…·åº“ç»è¿‡ä¼˜åŒ– |
| **å…¼å®¹æ€§** | æä½ | ä¸å½±å“ç°æœ‰è¯æ®è®°å½• |
| **å®‰å…¨æ€§** | æä½ | å·¥å…·åº“ç»è¿‡å®‰å…¨å®¡è®¡ |

**æ€»ä½“é£é™©**: ğŸŸ¢ **æä½é£é™©**

---

## 3. GroupChat æ¨¡å—é›†æˆè¯„ä¼°

### 3.1 å½“å‰å®ç°åˆ†æ

**æ–‡ä»¶ä½ç½®**: `pallets/smart-group-chat/src/types.rs`

**æ ¸å¿ƒæ•°æ®ç»“æ„**:
```rust
/// æ¶ˆæ¯ç±»å‹
pub enum MessageType {
    Text,
    Image,
    Video,
    Audio,
    File,
    System,
    Ephemeral,
    Temporary,
}

/// ç¾¤ç»„æ¶ˆæ¯å…ƒæ•°æ®
pub struct GroupMessageMeta<T: frame_system::Config> {
    pub id: MessageId,
    pub group_id: GroupId,
    pub sender: T::AccountId,
    pub content: BoundedVec<u8, ConstU32<2048>>,  // å†…å®¹æˆ– IPFS CID
    pub message_type: MessageType,
    pub encryption_mode: EncryptionMode,
    pub storage_tier: StorageTier,
    pub sent_at: u64,
    pub temp_id: Option<TempMessageId>,
    pub confirmation_status: ConfirmationStatus,
    pub ai_analysis: Option<AIAnalysisResult>,
    pub access_count: u32,
    pub last_accessed: u64,
}

/// åŠ å¯†æ¨¡å¼
pub enum EncryptionMode {
    Military,      // é‡å­æŠ—æ€§
    Business,      // æ ‡å‡†ç«¯åˆ°ç«¯
    Selective,     // é€‰æ‹©æ€§
    Transparent,   // å®Œå…¨å…¬å¼€
}
```

### 3.2 é›†æˆæ–¹æ¡ˆè®¾è®¡

#### é›†æˆç‚¹1: å›¾ç‰‡/è§†é¢‘æ¶ˆæ¯éªŒè¯

```rust
// pallets/smart-group-chat/src/lib.rs

use stardust_media_common::{
    ImageValidator,
    VideoValidator,
    AudioValidator,
    HashHelper,
    MediaError,
};

impl<T: Config> Pallet<T> {
    /// âœ… å‘é€å›¾ç‰‡æ¶ˆæ¯
    pub fn send_image_message(
        origin: OriginFor<T>,
        group_id: GroupId,
        image_data: Vec<u8>,
        encryption_mode: EncryptionMode,
    ) -> DispatchResult {
        let who = ensure_signed(origin)?;

        // æ£€æŸ¥ç¾¤ç»„æˆå‘˜
        ensure!(
            GroupMembers::<T>::contains_key((group_id, who.clone())),
            Error::<T>::NotMember
        );

        // âœ… 1. ä½¿ç”¨å…±äº«å·¥å…·åº“éªŒè¯å›¾ç‰‡
        let metadata = ImageValidator::validate(&image_data)
            .map_err(|e| match e {
                MediaError::FileTooSmall => Error::<T>::FileTooSmall,
                MediaError::FileTooLarge => Error::<T>::FileTooLarge,
                MediaError::UnsupportedFormat => Error::<T>::UnsupportedFormat,
                MediaError::ImageBomb => Error::<T>::ImageBomb,
                MediaError::SuspiciousContent => Error::<T>::SuspiciousContent,
                _ => Error::<T>::InvalidImage,
            })?;

        // âœ… 2. ç¾¤ç»„ç‰¹æœ‰é€»è¾‘ï¼šé‡å­æŠ—æ€§åŠ å¯†
        let encrypted_data = match encryption_mode {
            EncryptionMode::Military => {
                // ä½¿ç”¨ Kyber + Dilithium é‡å­æŠ—æ€§åŠ å¯†
                Self::quantum_encrypt(&image_data, group_id)?
            },
            EncryptionMode::Business => {
                // æ ‡å‡†ç«¯åˆ°ç«¯åŠ å¯†
                Self::standard_encrypt(&image_data, group_id)?
            },
            EncryptionMode::Transparent => image_data,
            _ => return Err(Error::<T>::UnsupportedEncryptionMode.into()),
        };

        // âœ… 3. ä¸Šä¼ åˆ° IPFS
        let cid = T::IpfsPinner::request_pin(
            who.clone(),
            encrypted_data,
            PinTier::Standard,  // ç¾¤èŠæ¶ˆæ¯ç”¨ Standard
        )?;

        // âœ… 4. åˆ›å»ºæ¶ˆæ¯è®°å½•
        let message = GroupMessageMeta {
            id: Self::next_message_id(),
            group_id,
            sender: who.clone(),
            content: cid,
            message_type: MessageType::Image,
            encryption_mode,
            storage_tier: StorageTier::IPFS,
            sent_at: Self::current_timestamp(),
            temp_id: None,
            confirmation_status: ConfirmationStatus::Confirmed,
            ai_analysis: None,  // å¯é€‰ï¼šAI å†…å®¹åˆ†æ
            access_count: 0,
            last_accessed: Self::current_timestamp(),
        };

        Messages::<T>::insert(message.id, message.clone());

        Self::deposit_event(Event::ImageMessageSent {
            message_id: message.id,
            group_id,
            sender: who,
        });

        Ok(())
    }

    /// âœ… å‘é€è§†é¢‘æ¶ˆæ¯
    pub fn send_video_message(
        origin: OriginFor<T>,
        group_id: GroupId,
        video_data: Vec<u8>,
        encryption_mode: EncryptionMode,
    ) -> DispatchResult {
        let who = ensure_signed(origin)?;

        ensure!(
            GroupMembers::<T>::contains_key((group_id, who.clone())),
            Error::<T>::NotMember
        );

        // âœ… 1. ä½¿ç”¨å…±äº«å·¥å…·åº“éªŒè¯è§†é¢‘
        let metadata = VideoValidator::validate(&video_data)
            .map_err(|e| match e {
                MediaError::FileTooSmall => Error::<T>::FileTooSmall,
                MediaError::FileTooLarge => Error::<T>::FileTooLarge,
                MediaError::UnsupportedFormat => Error::<T>::UnsupportedFormat,
                MediaError::VideoTooLong => Error::<T>::VideoTooLong,
                _ => Error::<T>::InvalidVideo,
            })?;

        // æ£€æŸ¥æ—¶é•¿é™åˆ¶ï¼ˆç¾¤èŠå¯èƒ½æœ‰æ›´ä¸¥æ ¼çš„é™åˆ¶ï¼‰
        if let Some(duration) = metadata.duration_secs {
            ensure!(
                duration <= T::MaxVideoLength::get(),
                Error::<T>::VideoTooLong
            );
        }

        // âœ… 2. åŠ å¯†
        let encrypted_data = match encryption_mode {
            EncryptionMode::Military => Self::quantum_encrypt(&video_data, group_id)?,
            EncryptionMode::Business => Self::standard_encrypt(&video_data, group_id)?,
            EncryptionMode::Transparent => video_data,
            _ => return Err(Error::<T>::UnsupportedEncryptionMode.into()),
        };

        // âœ… 3. ä¸Šä¼ 
        let cid = T::IpfsPinner::request_pin(
            who.clone(),
            encrypted_data,
            PinTier::Standard,
        )?;

        // âœ… 4. åˆ›å»ºæ¶ˆæ¯
        let message = GroupMessageMeta {
            id: Self::next_message_id(),
            group_id,
            sender: who.clone(),
            content: cid,
            message_type: MessageType::Video,
            encryption_mode,
            storage_tier: StorageTier::IPFS,
            sent_at: Self::current_timestamp(),
            temp_id: None,
            confirmation_status: ConfirmationStatus::Confirmed,
            ai_analysis: None,
            access_count: 0,
            last_accessed: Self::current_timestamp(),
        };

        Messages::<T>::insert(message.id, message.clone());

        Self::deposit_event(Event::VideoMessageSent {
            message_id: message.id,
            group_id,
            sender: who,
        });

        Ok(())
    }

    /// âœ… å‘é€éŸ³é¢‘æ¶ˆæ¯
    pub fn send_audio_message(
        origin: OriginFor<T>,
        group_id: GroupId,
        audio_data: Vec<u8>,
        encryption_mode: EncryptionMode,
    ) -> DispatchResult {
        let who = ensure_signed(origin)?;

        ensure!(
            GroupMembers::<T>::contains_key((group_id, who.clone())),
            Error::<T>::NotMember
        );

        // âœ… ä½¿ç”¨å…±äº«å·¥å…·åº“éªŒè¯éŸ³é¢‘
        let metadata = AudioValidator::validate(&audio_data)
            .map_err(|e| match e {
                MediaError::FileTooSmall => Error::<T>::FileTooSmall,
                MediaError::FileTooLarge => Error::<T>::FileTooLarge,
                MediaError::UnsupportedFormat => Error::<T>::UnsupportedFormat,
                _ => Error::<T>::InvalidAudio,
            })?;

        // åŠ å¯†
        let encrypted_data = match encryption_mode {
            EncryptionMode::Military => Self::quantum_encrypt(&audio_data, group_id)?,
            EncryptionMode::Business => Self::standard_encrypt(&audio_data, group_id)?,
            EncryptionMode::Transparent => audio_data,
            _ => return Err(Error::<T>::UnsupportedEncryptionMode.into()),
        };

        // ä¸Šä¼ 
        let cid = T::IpfsPinner::request_pin(
            who.clone(),
            encrypted_data,
            PinTier::Standard,
        )?;

        // åˆ›å»ºæ¶ˆæ¯
        let message = GroupMessageMeta {
            id: Self::next_message_id(),
            group_id,
            sender: who.clone(),
            content: cid,
            message_type: MessageType::Audio,
            encryption_mode,
            storage_tier: StorageTier::IPFS,
            sent_at: Self::current_timestamp(),
            temp_id: None,
            confirmation_status: ConfirmationStatus::Confirmed,
            ai_analysis: None,
            access_count: 0,
            last_accessed: Self::current_timestamp(),
        };

        Messages::<T>::insert(message.id, message.clone());

        Self::deposit_event(Event::AudioMessageSent {
            message_id: message.id,
            group_id,
            sender: who,
        });

        Ok(())
    }
}
```

### 3.3 é›†æˆæ”¶ç›Šè¯„ä¼°

| æ”¶ç›Šç»´åº¦ | è¯„ä¼° | è¯´æ˜ |
|---------|------|------|
| **å®‰å…¨æ€§æå‡** | âœ… æé«˜ | å›¾ç‰‡ç‚¸å¼¹æ£€æµ‹ã€æ¶æ„å†…å®¹è¿‡æ»¤ |
| **æ ¼å¼å…¼å®¹æ€§** | âœ… é«˜ | æ”¯æŒæ›´å¤šå›¾ç‰‡/è§†é¢‘/éŸ³é¢‘æ ¼å¼ |
| **ç”¨æˆ·ä½“éªŒ** | âœ… é«˜ | æ›´å‡†ç¡®çš„æ ¼å¼æ£€æµ‹ï¼Œæ›´å‹å¥½çš„é”™è¯¯æç¤º |
| **AIåˆ†æå‡†ç¡®æ€§** | âœ… ä¸­ | æ ‡å‡†åŒ–å…ƒæ•°æ®ä¾¿äºAIå¤„ç† |

### 3.4 é›†æˆé£é™©è¯„ä¼°

| é£é™© | ç­‰çº§ | ç¼“è§£æªæ–½ |
|-----|------|---------|
| **æ€§èƒ½å½±å“** | ä½ | éªŒè¯é€»è¾‘åœ¨åŠ å¯†å‰æ‰§è¡Œï¼Œä¸å½±å“åŠ å¯†æ€§èƒ½ |
| **åŠ å¯†å…¼å®¹æ€§** | æä½ | å·¥å…·åº“åªéªŒè¯åŸå§‹æ•°æ®ï¼Œä¸æ¶‰åŠåŠ å¯† |
| **ä¸´æ—¶æ¶ˆæ¯** | æä½ | å·¥å…·åº“ä¸å½±å“æ¶ˆæ¯ç”Ÿå‘½å‘¨æœŸ |

**æ€»ä½“é£é™©**: ğŸŸ¢ **ä½é£é™©**

---

## 4. é›†æˆå®æ–½è®¡åˆ’

### 4.1 åˆ†é˜¶æ®µå®æ–½ç­–ç•¥

#### é˜¶æ®µ1: åŸºç¡€è®¾æ–½å‡†å¤‡ï¼ˆ1å‘¨ï¼‰

**ä»»åŠ¡æ¸…å•**:
- [ ] åˆ›å»º `stardust-media-common` crate
- [ ] å®ç° `types.rs` å’Œ `error.rs`
- [ ] ç¼–å†™åŸºç¡€å•å…ƒæµ‹è¯•
- [ ] å‘å¸ƒåˆ°é¡¹ç›®å†…éƒ¨

**äº¤ä»˜ç‰©**:
- stardust-media-common crate (v0.1.0)
- å®Œæ•´çš„ README.md
- åŸºç¡€å•å…ƒæµ‹è¯•

#### é˜¶æ®µ2: æ ¸å¿ƒæ¨¡å—å®ç°ï¼ˆ2å‘¨ï¼‰

**Week 1**:
- [ ] å®ç° `ipfs.rs`ï¼ˆCID è®¡ç®—å’ŒéªŒè¯ï¼‰
- [ ] å®ç° `hash.rs`ï¼ˆå“ˆå¸Œå·¥å…·ï¼‰
- [ ] å®ç° `validation.rs`ï¼ˆå›¾ç‰‡éªŒè¯ï¼‰
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•

**Week 2**:
- [ ] å®Œå–„ `validation.rs`ï¼ˆè§†é¢‘ã€éŸ³é¢‘éªŒè¯ï¼‰
- [ ] å®ç° `thumbnail.rs`ï¼ˆç¼©ç•¥å›¾ç”Ÿæˆå ä½ï¼‰
- [ ] å®ç° `metadata.rs`ï¼ˆå…ƒæ•°æ®æå–å ä½ï¼‰
- [ ] ç¼–å†™é›†æˆæµ‹è¯•

**äº¤ä»˜ç‰©**:
- å®Œæ•´çš„å·¥å…·åº“å®ç°
- >80% å•å…ƒæµ‹è¯•è¦†ç›–ç‡
- API æ–‡æ¡£

#### é˜¶æ®µ3: Deceased é›†æˆï¼ˆ1å‘¨ï¼‰

**ä»»åŠ¡æ¸…å•**:
- [ ] æ›´æ–° `pallets/deceased/Cargo.toml`
- [ ] å®ç° `upload_photo_to_album`ï¼ˆä½¿ç”¨å·¥å…·åº“ï¼‰
- [ ] å®ç° `upload_video_to_collection`ï¼ˆä½¿ç”¨å·¥å…·åº“ï¼‰
- [ ] å®ç° `upload_audio_to_collection`ï¼ˆæ–°å¢ï¼‰
- [ ] æ·»åŠ æ–°çš„é”™è¯¯ç±»å‹
- [ ] ç¼–å†™é›†æˆæµ‹è¯•
- [ ] æ›´æ–° README.md

**éªŒæ”¶æ ‡å‡†**:
- âœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡
- âœ… åŠŸèƒ½æ— å›å½’
- âœ… æ€§èƒ½æ— ä¸‹é™

#### é˜¶æ®µ4: Evidence é›†æˆï¼ˆ1å‘¨ï¼‰

**ä»»åŠ¡æ¸…å•**:
- [ ] æ›´æ–° `pallets/evidence/Cargo.toml`
- [ ] å®ç° `submit_image_evidence`ï¼ˆä½¿ç”¨å·¥å…·åº“ï¼‰
- [ ] å®ç° `submit_video_evidence`ï¼ˆä½¿ç”¨å·¥å…·åº“ï¼‰
- [ ] å®ç° `submit_mixed_evidence`ï¼ˆä½¿ç”¨å·¥å…·åº“ï¼‰
- [ ] æ·»åŠ æ–°çš„é”™è¯¯ç±»å‹
- [ ] ç¼–å†™é›†æˆæµ‹è¯•
- [ ] æ›´æ–° README.md

**éªŒæ”¶æ ‡å‡†**:
- âœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡
- âœ… è¯æ®å®Œæ•´æ€§ä¿è¯
- âœ… å®‰å…¨æ£€æŸ¥æ­£å¸¸å·¥ä½œ

#### é˜¶æ®µ5: GroupChat é›†æˆï¼ˆ1-2å‘¨ï¼‰

**Week 1**:
- [ ] æ›´æ–° `pallets/smart-group-chat/Cargo.toml`
- [ ] å®ç° `send_image_message`ï¼ˆä½¿ç”¨å·¥å…·åº“ï¼‰
- [ ] å®ç° `send_video_message`ï¼ˆä½¿ç”¨å·¥å…·åº“ï¼‰
- [ ] å®ç° `send_audio_message`ï¼ˆä½¿ç”¨å·¥å…·åº“ï¼‰

**Week 2**:
- [ ] æ·»åŠ æ–°çš„é”™è¯¯ç±»å‹
- [ ] ç¼–å†™é›†æˆæµ‹è¯•
- [ ] æ€§èƒ½æµ‹è¯•ï¼ˆéªŒè¯åŠ å¯†æ€§èƒ½æ— å½±å“ï¼‰
- [ ] æ›´æ–° README.md

**éªŒæ”¶æ ‡å‡†**:
- âœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡
- âœ… åŠ å¯†åŠŸèƒ½æ­£å¸¸
- âœ… æ€§èƒ½æ— ä¸‹é™

#### é˜¶æ®µ6: æ–‡æ¡£å’Œä¼˜åŒ–ï¼ˆ1å‘¨ï¼‰

**ä»»åŠ¡æ¸…å•**:
- [ ] æ›´æ–°é¡¹ç›®æ€»ä½“ README.md
- [ ] ç¼–å†™é›†æˆæŒ‡å—
- [ ] æ€§èƒ½åŸºå‡†æµ‹è¯•æŠ¥å‘Š
- [ ] ä»£ç å®¡æŸ¥å’Œä¼˜åŒ–
- [ ] å‘å¸ƒ v1.0.0 ç‰ˆæœ¬

### 4.2 æ€»ä½“æ—¶é—´çº¿

```
æ€»å‘¨æœŸï¼š7-8 å‘¨

Week 1ï¼šåˆ›å»ºå·¥å…·åº“ crate
Week 2-3ï¼šå®ç°æ ¸å¿ƒåŠŸèƒ½
Week 4ï¼šé›†æˆ Deceased
Week 5ï¼šé›†æˆ Evidence
Week 6-7ï¼šé›†æˆ GroupChat
Week 8ï¼šæ–‡æ¡£å’Œä¼˜åŒ–
```

---

## 5. é£é™©ç®¡ç†å’Œç¼“è§£æªæ–½

### 5.1 æŠ€æœ¯é£é™©

| é£é™© | æ¦‚ç‡ | å½±å“ | ç¼“è§£æªæ–½ |
|-----|------|------|---------|
| **ç¼–è¯‘é”™è¯¯** | ä½ (20%) | ä½ | æå‰ç¼–è¯‘æ£€æŸ¥ï¼Œç±»å‹æ˜ç¡® |
| **åŠŸèƒ½å›å½’** | ä½ (15%) | ä¸­ | å®Œæ•´çš„å›å½’æµ‹è¯•å¥—ä»¶ |
| **æ€§èƒ½ä¸‹é™** | æä½ (5%) | ä¸­ | æ€§èƒ½åŸºå‡†æµ‹è¯• |
| **ä¾èµ–å†²çª** | æä½ (5%) | ä½ | å·¥å…·åº“é›¶è¿è¡Œæ—¶ä¾èµ– |

### 5.2 é›†æˆé£é™©

| é£é™© | æ¦‚ç‡ | å½±å“ | ç¼“è§£æªæ–½ |
|-----|------|------|---------|
| **é›†æˆå›°éš¾** | ä½ (10%) | ä¸­ | è¯¦ç»†çš„é›†æˆæ–‡æ¡£å’Œç¤ºä¾‹ |
| **æµ‹è¯•ä¸è¶³** | ä¸­ (30%) | é«˜ | å¼ºåˆ¶è¦æ±‚ >80% æµ‹è¯•è¦†ç›– |
| **æ–‡æ¡£ç¼ºå¤±** | ä¸­ (25%) | ä¸­ | æ¯ä¸ªé˜¶æ®µåŒ…å«æ–‡æ¡£æ›´æ–° |

### 5.3 é¡¹ç›®é£é™©

| é£é™© | æ¦‚ç‡ | å½±å“ | ç¼“è§£æªæ–½ |
|-----|------|------|---------|
| **éœ€æ±‚å˜æ›´** | ä¸­ (40%) | ä¸­ | æ¨¡å—åŒ–è®¾è®¡ï¼Œæ˜“äºè°ƒæ•´ |
| **æ—¶é—´å»¶æœŸ** | ä¸­ (35%) | ä¸­ | åˆ†é˜¶æ®µäº¤ä»˜ï¼Œå¯ä»¥éƒ¨åˆ†å®Œæˆ |
| **èµ„æºä¸è¶³** | ä½ (20%) | é«˜ | æå‰è§„åˆ’ï¼Œé¢„ç•™ç¼“å†²æ—¶é—´ |

---

## 6. æˆåŠŸæŒ‡æ ‡

### 6.1 æŠ€æœ¯æŒ‡æ ‡

- âœ… **å•å…ƒæµ‹è¯•è¦†ç›–ç‡**: >80%
- âœ… **é›†æˆæµ‹è¯•é€šè¿‡ç‡**: 100%
- âœ… **ç¼–è¯‘æ—¶é—´å¢åŠ **: <5%
- âœ… **è¿è¡Œæ—¶æ€§èƒ½**: æ— ä¸‹é™
- âœ… **ä»£ç é‡å¤ç‡**: <5%

### 6.2 è´¨é‡æŒ‡æ ‡

- âœ… **æ–‡æ¡£è¦†ç›–ç‡**: >90%
- âœ… **API ç¨³å®šæ€§**: æ— ç ´åæ€§å˜æ›´
- âœ… **å·²çŸ¥ Bug**: 0 ä¸ª
- âœ… **ä»£ç å®¡æŸ¥**: 100% é€šè¿‡

### 6.3 ä¸šåŠ¡æŒ‡æ ‡

- âœ… **åŠŸèƒ½å®Œæ•´æ€§**: æ‰€æœ‰ç°æœ‰åŠŸèƒ½ä¿æŒ
- âœ… **æ–°åŠŸèƒ½**: éŸ³é¢‘æ ¼å¼å®Œå–„æ”¯æŒ
- âœ… **å®‰å…¨æ€§**: å¢å¼ºçš„æ ¼å¼æ£€æµ‹å’Œå®‰å…¨æ£€æŸ¥
- âœ… **ç»´æŠ¤æ€§**: é™ä½ 50%+ ç»´æŠ¤æˆæœ¬

---

## 7. æ€»ç»“å’Œå»ºè®®

### 7.1 é›†æˆå¯è¡Œæ€§æ€»ç»“

| æ¨¡å— | é›†æˆéš¾åº¦ | æ”¶ç›Š | é£é™© | æ¨èåº¦ |
|-----|---------|------|------|-------|
| **Deceased** | â­â­ (ä½) | â­â­â­â­â­ (æé«˜) | ğŸŸ¢ ä½ | âœ… å¼ºçƒˆæ¨è |
| **Evidence** | â­ (æä½) | â­â­â­â­â­ (æé«˜) | ğŸŸ¢ æä½ | âœ… å¼ºçƒˆæ¨è |
| **GroupChat** | â­â­â­ (ä¸­) | â­â­â­â­ (é«˜) | ğŸŸ¢ ä½ | âœ… æ¨è |

### 7.2 æ ¸å¿ƒä¼˜åŠ¿

1. **é›¶ç ´åæ€§**: ä¸éœ€è¦ä¿®æ”¹ç°æœ‰å­˜å‚¨ç»“æ„å’Œä¸šåŠ¡é€»è¾‘
2. **é«˜æ”¶ç›Š**: æ¶ˆé™¤ä»£ç é‡å¤ï¼Œæå‡ä»£ç è´¨é‡å’Œå®‰å…¨æ€§
3. **ä½é£é™©**: å·¥å…·åº“ç‹¬ç«‹ï¼Œæ¸è¿›å¼é›†æˆ
4. **æ˜“ç»´æŠ¤**: æ ¼å¼æ›´æ–°å’Œ Bug ä¿®å¤é›†ä¸­åœ¨å·¥å…·åº“
5. **æ˜“æ‰©å±•**: æ–°å¢åª’ä½“ç±»å‹åªéœ€æ›´æ–°å·¥å…·åº“

### 7.3 å®æ–½å»ºè®®

#### ç«‹å³è¡ŒåŠ¨ï¼ˆWeek 1ï¼‰:
1. âœ… åˆ›å»º `stardust-media-common` crate
2. âœ… å®ç°åŸºç¡€ç±»å‹å’Œé”™è¯¯å®šä¹‰
3. âœ… ç¼–å†™åŸºç¡€å•å…ƒæµ‹è¯•

#### çŸ­æœŸç›®æ ‡ï¼ˆWeek 2-5ï¼‰:
1. âœ… å®ç°å®Œæ•´çš„å·¥å…·åº“åŠŸèƒ½
2. âœ… é›†æˆ Deceased å’Œ Evidenceï¼ˆé«˜æ”¶ç›Šã€ä½é£é™©ï¼‰
3. âœ… éªŒè¯å¯è¡Œæ€§å’Œæ€§èƒ½

#### ä¸­æœŸç›®æ ‡ï¼ˆWeek 6-8ï¼‰:
1. âœ… é›†æˆ GroupChat
2. âœ… å®Œå–„æ–‡æ¡£å’Œæµ‹è¯•
3. âœ… å‘å¸ƒ v1.0.0

### 7.4 å…³é”®æˆåŠŸå› ç´ 

1. **å……åˆ†æµ‹è¯•**: æ¯ä¸ªé˜¶æ®µéƒ½éœ€è¦å®Œæ•´çš„å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
2. **æ–‡æ¡£åŒæ­¥**: ä»£ç å’Œæ–‡æ¡£åŒæ­¥æ›´æ–°
3. **æ€§èƒ½ç›‘æ§**: æŒç»­ç›‘æ§æ€§èƒ½æŒ‡æ ‡
4. **ä»£ç å®¡æŸ¥**: æ‰€æœ‰ä»£ç å˜æ›´éœ€è¦ review
5. **æ¸è¿›å¼äº¤ä»˜**: åˆ†é˜¶æ®µäº¤ä»˜ï¼Œé™ä½é£é™©

### 7.5 æœ€ç»ˆè¯„ä¼°

**æ€»ä½“è¯„ä¼°**: âœ… **å¼ºçƒˆæ¨èå®æ–½**

**ç†ç”±**:
1. âœ… æŠ€æœ¯å¯è¡Œæ€§é«˜ï¼ˆ9/10ï¼‰
2. âœ… ä¸šåŠ¡æ”¶ç›Šå¤§ï¼ˆä»£ç è´¨é‡ã€å®‰å…¨æ€§ã€ç»´æŠ¤æ€§å…¨é¢æå‡ï¼‰
3. âœ… é£é™©ä½ï¼ˆå·¥å…·åº“ç‹¬ç«‹ï¼Œä¸å½±å“ç°æœ‰åŠŸèƒ½ï¼‰
4. âœ… å®æ–½æˆæœ¬ä½ï¼ˆ7-8 å‘¨ï¼Œå¯æ¸è¿›å¼äº¤ä»˜ï¼‰
5. âœ… é•¿æœŸä»·å€¼é«˜ï¼ˆé™ä½ 50%+ ç»´æŠ¤æˆæœ¬ï¼‰

**é¢„æœŸæ”¶ç›Š**:
- æ¶ˆé™¤é‡å¤ä»£ç  60%+
- æå‡å®‰å…¨æ€§ 40%+
- é™ä½ç»´æŠ¤æˆæœ¬ 50%+
- æå‡å¼€å‘æ•ˆç‡ 30%+
- å¢å¼ºç³»ç»Ÿç¨³å®šæ€§

**æŠ•èµ„å›æŠ¥æœŸ**: 3-6 ä¸ªæœˆ

---

*æœ¬è¯„ä¼°æŠ¥å‘ŠåŸºäºè¯¦ç»†çš„ä»£ç åˆ†æå’Œæ¶æ„è®¾è®¡ï¼Œå»ºè®®ç«‹å³å¯åŠ¨å·¥å…·åº“å¼€å‘å’Œé›†æˆå·¥ä½œã€‚*
