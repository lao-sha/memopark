# æŠ¼é‡‘ä¸ç”³è¯‰æ²»ç†ç³»ç»Ÿ - æµ‹è¯•æ–¹æ¡ˆ

> ä¸»æ–‡æ¡£ï¼š`æŠ¼é‡‘ä¸ç”³è¯‰æ²»ç†ç³»ç»Ÿ-å®Œæ•´è®¾è®¡æ–¹æ¡ˆ.md`

## ğŸ¯ æµ‹è¯•ç›®æ ‡

### æ ¸å¿ƒç›®æ ‡

1. **åŠŸèƒ½æ­£ç¡®æ€§** - æ‰€æœ‰åŠŸèƒ½æŒ‰é¢„æœŸå·¥ä½œ
2. **èµ„é‡‘å®‰å…¨æ€§** - æŠ¼é‡‘èµ„é‡‘ç»å¯¹å®‰å…¨ï¼Œæ— æ¼æ´
3. **æ€§èƒ½è¾¾æ ‡** - æ»¡è¶³æ€§èƒ½æŒ‡æ ‡è¦æ±‚
4. **ç”¨æˆ·ä½“éªŒ** - å‰ç«¯äº¤äº’æµç•…ï¼Œæ˜“ç”¨
5. **ç¨³å®šå¯é ** - é•¿æ—¶é—´è¿è¡Œæ— æ•…éšœ

### æµ‹è¯•ç­–ç•¥

```
é‡‘å­—å¡”æµ‹è¯•æ¨¡å‹ï¼š
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  E2Eæµ‹è¯•    â”‚  10%  å‰ç«¯åˆ°é“¾ç«¯å®Œæ•´æµç¨‹
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚  é›†æˆæµ‹è¯•    â”‚  30%  æ¨¡å—é—´äº¤äº’
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚  å•å…ƒæµ‹è¯•    â”‚  60%  å•ä¸ªå‡½æ•°/ç»„ä»¶
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ§ª å•å…ƒæµ‹è¯•

### pallet-deposits å•å…ƒæµ‹è¯•

#### æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡ï¼š>90%

**æµ‹è¯•æ–‡ä»¶**ï¼š`pallets/deposits/src/tests.rs`

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use frame_support::{assert_ok, assert_noop};
    use mock::*;

    // ========== reserve_depositæµ‹è¯• ==========
    
    #[test]
    fn reserve_deposit_works() {
        new_test_ext().execute_with(|| {
            let alice = 1;
            let amount = 100;
            
            // ç»™aliceåˆå§‹ä½™é¢
            Balances::make_free_balance_be(&alice, 1000);
            
            // å†»ç»“æŠ¼é‡‘
            let purpose = DepositPurpose::Appeal {
                appeal_id: 1,
                domain: 1,
                target: 123,
                action: 10,
            };
            
            let result = Deposits::reserve_deposit(
                Origin::signed(alice),
                purpose.clone(),
                amount,
            );
            
            assert_ok!(result);
            let deposit_id = result.unwrap();
            
            // éªŒè¯ä½™é¢å˜åŒ–
            assert_eq!(Balances::reserved_balance(&alice), amount);
            assert_eq!(Balances::free_balance(&alice), 900);
            
            // éªŒè¯å­˜å‚¨
            let deposit = Deposits::<Test>::get(deposit_id).unwrap();
            assert_eq!(deposit.who, alice);
            assert_eq!(deposit.amount, amount);
            assert_eq!(deposit.status, DepositStatus::Reserved);
            
            // éªŒè¯äº‹ä»¶
            System::assert_last_event(Event::DepositReserved {
                deposit_id,
                who: alice,
                amount,
                purpose,
            });
        });
    }
    
    #[test]
    fn reserve_deposit_fails_insufficient_balance() {
        new_test_ext().execute_with(|| {
            let alice = 1;
            Balances::make_free_balance_be(&alice, 50);
            
            let purpose = DepositPurpose::Appeal {
                appeal_id: 1,
                domain: 1,
                target: 123,
                action: 10,
            };
            
            // ä½™é¢ä¸è¶³ï¼Œåº”è¯¥å¤±è´¥
            assert_noop!(
                Deposits::reserve_deposit(
                    Origin::signed(alice),
                    purpose,
                    100,
                ),
                pallet_balances::Error::<Test>::InsufficientBalance
            );
        });
    }
    
    #[test]
    fn reserve_deposit_creates_index() {
        new_test_ext().execute_with(|| {
            let alice = 1;
            Balances::make_free_balance_be(&alice, 1000);
            
            // åˆ›å»º3ä¸ªæŠ¼é‡‘
            for i in 1..=3 {
                let purpose = DepositPurpose::Appeal {
                    appeal_id: i,
                    domain: 1,
                    target: 123,
                    action: 10,
                };
                
                assert_ok!(Deposits::reserve_deposit(
                    Origin::signed(alice),
                    purpose,
                    100,
                ));
            }
            
            // éªŒè¯ç´¢å¼•
            let ids = DepositsByAccount::<Test>::get(alice);
            assert_eq!(ids.len(), 3);
            assert_eq!(ids.to_vec(), vec![0, 1, 2]);
        });
    }
    
    // ========== release_depositæµ‹è¯• ==========
    
    #[test]
    fn release_deposit_works() {
        new_test_ext().execute_with(|| {
            let alice = 1;
            Balances::make_free_balance_be(&alice, 1000);
            
            // å…ˆå†»ç»“
            let purpose = DepositPurpose::Appeal {
                appeal_id: 1,
                domain: 1,
                target: 123,
                action: 10,
            };
            let deposit_id = Deposits::reserve_deposit(
                Origin::signed(alice),
                purpose,
                100,
            ).unwrap();
            
            // é‡Šæ”¾æŠ¼é‡‘ï¼ˆRootæƒé™ï¼‰
            assert_ok!(Deposits::release_deposit(
                Origin::root(),
                deposit_id,
            ));
            
            // éªŒè¯ä½™é¢æ¢å¤
            assert_eq!(Balances::reserved_balance(&alice), 0);
            assert_eq!(Balances::free_balance(&alice), 1000);
            
            // éªŒè¯çŠ¶æ€æ›´æ–°
            let deposit = Deposits::<Test>::get(deposit_id).unwrap();
            assert_eq!(deposit.status, DepositStatus::Released);
            assert!(deposit.released_at.is_some());
        });
    }
    
    #[test]
    fn release_deposit_fails_wrong_status() {
        new_test_ext().execute_with(|| {
            let alice = 1;
            Balances::make_free_balance_be(&alice, 1000);
            
            let purpose = DepositPurpose::Appeal {
                appeal_id: 1,
                domain: 1,
                target: 123,
                action: 10,
            };
            let deposit_id = Deposits::reserve_deposit(
                Origin::signed(alice),
                purpose,
                100,
            ).unwrap();
            
            // ç¬¬ä¸€æ¬¡é‡Šæ”¾æˆåŠŸ
            assert_ok!(Deposits::release_deposit(Origin::root(), deposit_id));
            
            // ç¬¬äºŒæ¬¡é‡Šæ”¾å¤±è´¥ï¼ˆå·²ç»æ˜¯ReleasedçŠ¶æ€ï¼‰
            assert_noop!(
                Deposits::release_deposit(Origin::root(), deposit_id),
                Error::<Test>::InvalidStatus
            );
        });
    }
    
    #[test]
    fn release_deposit_requires_root() {
        new_test_ext().execute_with(|| {
            let alice = 1;
            let bob = 2;
            Balances::make_free_balance_be(&alice, 1000);
            
            let purpose = DepositPurpose::Appeal {
                appeal_id: 1,
                domain: 1,
                target: 123,
                action: 10,
            };
            let deposit_id = Deposits::reserve_deposit(
                Origin::signed(alice),
                purpose,
                100,
            ).unwrap();
            
            // æ™®é€šç”¨æˆ·æ— æƒé‡Šæ”¾
            assert_noop!(
                Deposits::release_deposit(Origin::signed(bob), deposit_id),
                BadOrigin
            );
        });
    }
    
    // ========== slash_depositæµ‹è¯• ==========
    
    #[test]
    fn slash_deposit_works_partial() {
        new_test_ext().execute_with(|| {
            let alice = 1;
            let treasury = 100;
            Balances::make_free_balance_be(&alice, 1000);
            Balances::make_free_balance_be(&treasury, 0);
            
            let purpose = DepositPurpose::Appeal {
                appeal_id: 1,
                domain: 1,
                target: 123,
                action: 10,
            };
            let deposit_id = Deposits::reserve_deposit(
                Origin::signed(alice),
                purpose,
                100,
            ).unwrap();
            
            // ç½šæ²¡30%
            let slash_ratio = Perbill::from_percent(30);
            assert_ok!(Deposits::slash_deposit(
                Origin::root(),
                deposit_id,
                slash_ratio,
                treasury,
            ));
            
            // éªŒè¯ä½™é¢å˜åŒ–
            assert_eq!(Balances::free_balance(&alice), 970);  // 900 + 70é€€å›
            assert_eq!(Balances::free_balance(&treasury), 30);  // 30ç½šæ²¡
            
            // éªŒè¯çŠ¶æ€
            let deposit = Deposits::<Test>::get(deposit_id).unwrap();
            assert_eq!(
                deposit.status,
                DepositStatus::PartiallySlashed { amount: 30 }
            );
        });
    }
    
    #[test]
    fn slash_deposit_works_full() {
        new_test_ext().execute_with(|| {
            let alice = 1;
            let treasury = 100;
            Balances::make_free_balance_be(&alice, 1000);
            Balances::make_free_balance_be(&treasury, 0);
            
            let purpose = DepositPurpose::Appeal {
                appeal_id: 1,
                domain: 1,
                target: 123,
                action: 10,
            };
            let deposit_id = Deposits::reserve_deposit(
                Origin::signed(alice),
                purpose,
                100,
            ).unwrap();
            
            // ç½šæ²¡100%
            let slash_ratio = Perbill::from_percent(100);
            assert_ok!(Deposits::slash_deposit(
                Origin::root(),
                deposit_id,
                slash_ratio,
                treasury,
            ));
            
            // éªŒè¯ä½™é¢å˜åŒ–
            assert_eq!(Balances::free_balance(&alice), 900);  // æ— é€€å›
            assert_eq!(Balances::free_balance(&treasury), 100);  // å…¨éƒ¨ç½šæ²¡
            
            // éªŒè¯çŠ¶æ€
            let deposit = Deposits::<Test>::get(deposit_id).unwrap();
            assert_eq!(deposit.status, DepositStatus::Slashed);
        });
    }
    
    // ========== åŠ¨æ€å®šä»·æµ‹è¯• ==========
    
    #[test]
    fn dynamic_pricing_works() {
        new_test_ext().execute_with(|| {
            // Mock pricingæ¨¡å—è¿”å›ä»·æ ¼
            MockPricing::set_price(2_000_000);  // $2 per DUST
            
            let alice = 1;
            let purpose = DepositPurpose::Appeal {
                appeal_id: 1,
                domain: 1,  // grave
                target: 123,
                action: 10,  // clear_cover, å€æ•°1.0Ã—
            };
            
            // è®¡ç®—æŠ¼é‡‘ï¼š$10 / $2 Ã— 1.0 = 5 DUST
            let deposit = calc_deposit(&alice, &purpose);
            assert_eq!(deposit, Some(5_000_000_000_000));  // 5 DUST
        });
    }
    
    #[test]
    fn dynamic_pricing_with_multiplier() {
        new_test_ext().execute_with(|| {
            MockPricing::set_price(2_000_000);  // $2 per DUST
            
            let alice = 1;
            let purpose = DepositPurpose::Appeal {
                appeal_id: 1,
                domain: 1,  // grave
                target: 123,
                action: 11,  // transfer_owner, å€æ•°2.0Ã—
            };
            
            // è®¡ç®—æŠ¼é‡‘ï¼š$10 / $2 Ã— 2.0 = 10 DUST
            let deposit = calc_deposit(&alice, &purpose);
            assert_eq!(deposit, Some(10_000_000_000_000));  // 10 DUST
        });
    }
}
```

**æµ‹è¯•æ¸…å•**ï¼š

- [ ] reserve_depositæ­£å¸¸æµç¨‹
- [ ] reserve_depositä½™é¢ä¸è¶³
- [ ] reserve_depositåˆ›å»ºç´¢å¼•
- [ ] release_depositæ­£å¸¸æµç¨‹
- [ ] release_deposité‡å¤é‡Šæ”¾
- [ ] release_depositæƒé™æ£€æŸ¥
- [ ] slash_depositéƒ¨åˆ†ç½šæ²¡
- [ ] slash_depositå…¨éƒ¨ç½šæ²¡
- [ ] slash_depositæƒé™æ£€æŸ¥
- [ ] åŠ¨æ€å®šä»·è®¡ç®—æ­£ç¡®
- [ ] åŠ¨æ€å®šä»·å€æ•°è®¡ç®—
- [ ] è¾¹ç•Œå€¼æµ‹è¯•
- [ ] å¹¶å‘æµ‹è¯•

---

### pallet-stardust-appeals å•å…ƒæµ‹è¯•

#### æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡ï¼š>90%

**æµ‹è¯•æ–‡ä»¶**ï¼š`pallets/stardust-appeals/src/tests.rs`

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    // ========== submit_appealæµ‹è¯• ==========
    
    #[test]
    fn submit_appeal_works() {
        new_test_ext().execute_with(|| {
            let alice = 1;
            Balances::make_free_balance_be(&alice, 1000);
            
            assert_ok!(MemoAppeals::submit_appeal(
                Origin::signed(alice),
                1,  // domain: grave
                123,  // target
                10,  // action: clear_cover
                vec![1, 2, 3].try_into().unwrap(),  // reason_cid
                vec![4, 5, 6].try_into().unwrap(),  // evidence_cid
            ));
            
            // éªŒè¯ç”³è¯‰è®°å½•
            let appeal = Appeals::<Test>::get(0).unwrap();
            assert_eq!(appeal.who, alice);
            assert_eq!(appeal.domain, 1);
            assert_eq!(appeal.target, 123);
            assert_eq!(appeal.action, 10);
            assert_eq!(appeal.status, 0);  // submitted
            
            // éªŒè¯æŠ¼é‡‘å·²å†»ç»“
            assert!(appeal.deposit_id > 0);
            let deposit = Deposits::<Test>::get(appeal.deposit_id).unwrap();
            assert_eq!(deposit.status, DepositStatus::Reserved);
        });
    }
    
    #[test]
    fn submit_appeal_rate_limit_works() {
        new_test_ext().execute_with(|| {
            let alice = 1;
            Balances::make_free_balance_be(&alice, 10000);
            
            // æäº¤5æ¬¡æˆåŠŸ
            for i in 0..5 {
                assert_ok!(MemoAppeals::submit_appeal(
                    Origin::signed(alice),
                    1, 123, 10,
                    vec![i].try_into().unwrap(),
                    vec![i].try_into().unwrap(),
                ));
            }
            
            // ç¬¬6æ¬¡å¤±è´¥ï¼ˆé™é¢‘ï¼‰
            assert_noop!(
                MemoAppeals::submit_appeal(
                    Origin::signed(alice),
                    1, 123, 10,
                    vec![6].try_into().unwrap(),
                    vec![6].try_into().unwrap(),
                ),
                Error::<Test>::TooManySubmissions
            );
        });
    }
    
    // ========== approve_appealæµ‹è¯• ==========
    
    #[test]
    fn approve_appeal_works() {
        new_test_ext().execute_with(|| {
            let alice = 1;
            Balances::make_free_balance_be(&alice, 1000);
            
            // æäº¤ç”³è¯‰
            assert_ok!(MemoAppeals::submit_appeal(
                Origin::signed(alice),
                1, 123, 10,
                vec![1].try_into().unwrap(),
                vec![2].try_into().unwrap(),
            ));
            
            // å§”å‘˜ä¼šæ‰¹å‡†
            assert_ok!(MemoAppeals::approve_appeal(
                Origin::root(),
                0,  // appeal_id
                None,  // ä½¿ç”¨é»˜è®¤å…¬ç¤ºæœŸ
            ));
            
            // éªŒè¯çŠ¶æ€æ›´æ–°
            let appeal = Appeals::<Test>::get(0).unwrap();
            assert_eq!(appeal.status, 1);  // approved
            assert!(appeal.execute_at.is_some());
            assert!(appeal.approved_at.is_some());
            
            // éªŒè¯æ‰§è¡Œé˜Ÿåˆ—
            let execute_at = appeal.execute_at.unwrap();
            let queue = QueueByBlock::<Test>::get(execute_at).unwrap();
            assert_eq!(queue.to_vec(), vec![0]);
        });
    }
    
    #[test]
    fn approve_appeal_requires_governance() {
        new_test_ext().execute_with(|| {
            let alice = 1;
            let bob = 2;
            Balances::make_free_balance_be(&alice, 1000);
            
            assert_ok!(MemoAppeals::submit_appeal(
                Origin::signed(alice),
                1, 123, 10,
                vec![1].try_into().unwrap(),
                vec![2].try_into().unwrap(),
            ));
            
            // æ™®é€šç”¨æˆ·æ— æƒæ‰¹å‡†
            assert_noop!(
                MemoAppeals::approve_appeal(Origin::signed(bob), 0, None),
                BadOrigin
            );
        });
    }
    
    // ========== reject_appealæµ‹è¯• ==========
    
    #[test]
    fn reject_appeal_slashes_deposit() {
        new_test_ext().execute_with(|| {
            let alice = 1;
            let treasury = 100;
            Balances::make_free_balance_be(&alice, 1000);
            Balances::make_free_balance_be(&treasury, 0);
            
            assert_ok!(MemoAppeals::submit_appeal(
                Origin::signed(alice),
                1, 123, 10,
                vec![1].try_into().unwrap(),
                vec![2].try_into().unwrap(),
            ));
            
            let initial_free = Balances::free_balance(&alice);
            let appeal = Appeals::<Test>::get(0).unwrap();
            let deposit_amount = Deposits::<Test>::get(appeal.deposit_id).unwrap().amount;
            
            // é©³å›ç”³è¯‰
            assert_ok!(MemoAppeals::reject_appeal(Origin::root(), 0));
            
            // éªŒè¯çŠ¶æ€
            let appeal = Appeals::<Test>::get(0).unwrap();
            assert_eq!(appeal.status, 2);  // rejected
            
            // éªŒè¯æŠ¼é‡‘ç½šæ²¡30%
            let expected_slash = deposit_amount * 30 / 100;
            let expected_refund = deposit_amount - expected_slash;
            assert_eq!(
                Balances::free_balance(&alice),
                initial_free + expected_refund
            );
            assert_eq!(Balances::free_balance(&treasury), expected_slash);
        });
    }
    
    // ========== withdraw_appealæµ‹è¯• ==========
    
    #[test]
    fn withdraw_appeal_works() {
        new_test_ext().execute_with(|| {
            let alice = 1;
            Balances::make_free_balance_be(&alice, 1000);
            
            assert_ok!(MemoAppeals::submit_appeal(
                Origin::signed(alice),
                1, 123, 10,
                vec![1].try_into().unwrap(),
                vec![2].try_into().unwrap(),
            ));
            
            // æ’¤å›ç”³è¯‰
            assert_ok!(MemoAppeals::withdraw_appeal(Origin::signed(alice), 0));
            
            // éªŒè¯çŠ¶æ€
            let appeal = Appeals::<Test>::get(0).unwrap();
            assert_eq!(appeal.status, 3);  // withdrawn
            
            // éªŒè¯ç½šæ²¡10%
            let deposit = Deposits::<Test>::get(appeal.deposit_id).unwrap();
            let expected_slash = deposit.amount * 10 / 100;
            // ï¼ˆéªŒè¯ä½™é¢å˜åŒ–...ï¼‰
        });
    }
    
    // ========== è‡ªåŠ¨æ‰§è¡Œæµ‹è¯• ==========
    
    #[test]
    fn auto_execute_works() {
        new_test_ext().execute_with(|| {
            let alice = 1;
            Balances::make_free_balance_be(&alice, 1000);
            
            // æäº¤å¹¶æ‰¹å‡†ç”³è¯‰
            assert_ok!(MemoAppeals::submit_appeal(
                Origin::signed(alice),
                1, 123, 10,
                vec![1].try_into().unwrap(),
                vec![2].try_into().unwrap(),
            ));
            assert_ok!(MemoAppeals::approve_appeal(
                Origin::root(),
                0,
                Some(10),  // 10å—å…¬ç¤ºæœŸ
            ));
            
            let appeal = Appeals::<Test>::get(0).unwrap();
            let execute_at = appeal.execute_at.unwrap();
            
            // å¿«è¿›åˆ°æ‰§è¡Œå—
            run_to_block(execute_at);
            
            // éªŒè¯å·²æ‰§è¡Œ
            let appeal = Appeals::<Test>::get(0).unwrap();
            assert_eq!(appeal.status, 4);  // executed
            
            // éªŒè¯æŠ¼é‡‘å·²é‡Šæ”¾
            let deposit = Deposits::<Test>::get(appeal.deposit_id).unwrap();
            assert_eq!(deposit.status, DepositStatus::Released);
        });
    }
}
```

---

## ğŸ”— é›†æˆæµ‹è¯•

### ç«¯åˆ°ç«¯æµç¨‹æµ‹è¯•

#### æµ‹è¯•1ï¼šå®Œæ•´ç”³è¯‰æµç¨‹ï¼ˆæˆåŠŸï¼‰

**åœºæ™¯**ï¼šaliceæäº¤ç”³è¯‰ â†’ å§”å‘˜ä¼šæ‰¹å‡† â†’ è‡ªåŠ¨æ‰§è¡Œ â†’ æŠ¼é‡‘é€€å›

```rust
#[test]
fn integration_test_successful_appeal() {
    new_test_ext().execute_with(|| {
        let alice = 1;
        let committee = vec![10, 11, 12];
        let treasury = 100;
        
        // åˆå§‹åŒ–
        Balances::make_free_balance_be(&alice, 10_000);
        for member in &committee {
            Balances::make_free_balance_be(member, 1_000);
        }
        
        let initial_alice_balance = Balances::free_balance(&alice);
        
        // 1. æäº¤ç”³è¯‰
        assert_ok!(MemoAppeals::submit_appeal(
            Origin::signed(alice),
            1,  // grave
            123,
            10,  // clear_cover
            b"è¿è§„å†…å®¹".to_vec().try_into().unwrap(),
            b"è¯æ®CID".to_vec().try_into().unwrap(),
        ));
        
        let appeal = Appeals::<Test>::get(0).unwrap();
        let deposit_amount = Deposits::<Test>::get(appeal.deposit_id).unwrap().amount;
        
        // éªŒè¯æŠ¼é‡‘å†»ç»“
        assert_eq!(
            Balances::free_balance(&alice),
            initial_alice_balance - deposit_amount
        );
        
        // 2. å§”å‘˜ä¼šæŠ•ç¥¨ï¼ˆ2/3é€šè¿‡ï¼‰
        for member in &committee[0..2] {
            assert_ok!(Collective::vote(
                Origin::signed(*member),
                0,  // proposal_id
                true,  // approve
            ));
        }
        
        // 3. æ‰¹å‡†ç”³è¯‰
        assert_ok!(MemoAppeals::approve_appeal(
            Origin::root(),
            0,
            Some(100),  // 100å—å…¬ç¤ºæœŸ
        ));
        
        let appeal = Appeals::<Test>::get(0).unwrap();
        assert_eq!(appeal.status, 1);  // approved
        
        // 4. ç­‰å¾…å…¬ç¤ºæœŸåˆ°æœŸ
        let execute_at = appeal.execute_at.unwrap();
        run_to_block(execute_at);
        
        // 5. éªŒè¯è‡ªåŠ¨æ‰§è¡Œ
        let appeal = Appeals::<Test>::get(0).unwrap();
        assert_eq!(appeal.status, 4);  // executed
        
        // 6. éªŒè¯æŠ¼é‡‘å…¨é¢é€€å›
        assert_eq!(
            Balances::free_balance(&alice),
            initial_alice_balance  // å…¨é¢é€€å›
        );
        
        // 7. éªŒè¯ç›®æ ‡å¯¹è±¡å·²ä¿®æ”¹
        // ï¼ˆæ ¹æ®å…·ä½“ä¸šåŠ¡é€»è¾‘éªŒè¯ï¼‰
    });
}
```

#### æµ‹è¯•2ï¼šç”³è¯‰è¢«é©³å›æµç¨‹

```rust
#[test]
fn integration_test_rejected_appeal() {
    new_test_ext().execute_with(|| {
        let alice = 1;
        let treasury = 100;
        Balances::make_free_balance_be(&alice, 10_000);
        Balances::make_free_balance_be(&treasury, 0);
        
        let initial_alice_balance = Balances::free_balance(&alice);
        
        // 1. æäº¤ç”³è¯‰
        assert_ok!(MemoAppeals::submit_appeal(
            Origin::signed(alice),
            1, 123, 10,
            vec![1].try_into().unwrap(),
            vec![2].try_into().unwrap(),
        ));
        
        let appeal = Appeals::<Test>::get(0).unwrap();
        let deposit_amount = Deposits::<Test>::get(appeal.deposit_id).unwrap().amount;
        
        // 2. å§”å‘˜ä¼šé©³å›
        assert_ok!(MemoAppeals::reject_appeal(Origin::root(), 0));
        
        // 3. éªŒè¯æŠ¼é‡‘ç½šæ²¡30%
        let slash_amount = deposit_amount * 30 / 100;
        let refund_amount = deposit_amount - slash_amount;
        
        assert_eq!(
            Balances::free_balance(&alice),
            initial_alice_balance - slash_amount  // æŸå¤±30%
        );
        assert_eq!(Balances::free_balance(&treasury), slash_amount);
    });
}
```

---

## ğŸ–¥ï¸ å‰ç«¯æµ‹è¯•

### å•å…ƒæµ‹è¯•ï¼ˆJest + React Testing Libraryï¼‰

#### Hooksæµ‹è¯•

```typescript
// __tests__/hooks/useMemoAppeals.test.ts

import { renderHook, act } from '@testing-library/react-hooks';
import { useMemoAppeals } from '@/hooks/useMemoAppeals';

describe('useMemoAppeals', () => {
  it('fetches appeals successfully', async () => {
    const { result, waitForNextUpdate } = renderHook(() => useMemoAppeals());
    
    act(() => {
      result.current.fetchAppeals();
    });
    
    await waitForNextUpdate();
    
    expect(result.current.appeals).toHaveLength(2);
    expect(result.current.loading).toBe(false);
  });
  
  it('submits appeal successfully', async () => {
    const { result } = renderHook(() => useMemoAppeals());
    
    const params = {
      domain: 1,
      target: 123,
      action: 10,
      reason: 'è¿è§„å†…å®¹',
      evidence: ['è¯æ®1'],
    };
    
    let response;
    await act(async () => {
      response = await result.current.submitAppeal(params);
    });
    
    expect(response.success).toBe(true);
    expect(response.appealId).toBeGreaterThan(0);
  });
});
```

#### ç»„ä»¶æµ‹è¯•

```typescript
// __tests__/components/AppealCard.test.tsx

import { render, screen } from '@testing-library/react';
import { AppealCard } from '@/components/Appeals/AppealCard';

describe('AppealCard', () => {
  const mockAppeal = {
    id: 1,
    who: 'alice...',
    domain: 1,
    target: 123,
    action: 10,
    status: 0,
    depositAmount: '12.5',
    usdValue: '10',
    createdAt: '2025-10-20',
  };
  
  it('renders appeal information correctly', () => {
    render(<AppealCard appeal={mockAppeal} />);
    
    expect(screen.getByText('ç”³è¯‰ #1')).toBeInTheDocument();
    expect(screen.getByText('å¢“åœ°')).toBeInTheDocument();
    expect(screen.getByText('12.5 DUST')).toBeInTheDocument();
    expect(screen.getByText('($10 USD)')).toBeInTheDocument();
  });
  
  it('calls onClick when clicked', () => {
    const handleClick = jest.fn();
    render(<AppealCard appeal={mockAppeal} onClick={handleClick} />);
    
    const card = screen.getByRole('article');
    fireEvent.click(card);
    
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

### E2Eæµ‹è¯•ï¼ˆCypressï¼‰

```typescript
// cypress/e2e/appeals.cy.ts

describe('Appeals Flow', () => {
  beforeEach(() => {
    cy.visit('/appeals');
    cy.login('alice');  // è‡ªå®šä¹‰ç™»å½•å‘½ä»¤
  });
  
  it('submits an appeal successfully', () => {
    // ç‚¹å‡»"æäº¤ç”³è¯‰"
    cy.contains('æäº¤ç”³è¯‰').click();
    
    // Step 1: é€‰æ‹©å¯¹è±¡
    cy.get('[name="domain"]').select('å¢“åœ°');
    cy.get('[name="target"]').type('123');
    cy.contains('ä¸‹ä¸€æ­¥').click();
    
    // Step 2: é€‰æ‹©æ“ä½œ
    cy.get('[name="action"]').select('æ¸…ç©ºå°é¢');
    cy.contains('ä¸‹ä¸€æ­¥').click();
    
    // Step 3: å¡«å†™ç†ç”±
    cy.get('[name="reason"]').type('è¯¥å¢“åœ°å°é¢å­˜åœ¨ä¸å½“å†…å®¹ï¼Œè¿åç¤¾åŒºè§„èŒƒã€‚'.repeat(3));
    cy.get('[name="evidence"]').attachFile('evidence.jpg');
    cy.contains('ä¸‹ä¸€æ­¥').click();
    
    // Step 4: ç¡®è®¤æŠ¼é‡‘
    cy.contains('12.5 DUST').should('be.visible');
    cy.contains('ç¡®è®¤æäº¤ç”³è¯‰').click();
    
    // ç­‰å¾…äº¤æ˜“ç¡®è®¤
    cy.contains('æäº¤æˆåŠŸ', { timeout: 30000 }).should('be.visible');
    
    // éªŒè¯è·³è½¬åˆ°è¯¦æƒ…é¡µ
    cy.url().should('include', '/appeals/');
    cy.contains('ç”³è¯‰ #').should('be.visible');
  });
  
  it('displays appeals list correctly', () => {
    cy.get('.appeal-card').should('have.length.at.least', 1);
    
    cy.get('.appeal-card').first().within(() => {
      cy.contains('ç”³è¯‰ #').should('be.visible');
      cy.contains('DUST').should('be.visible');
      cy.contains('æŸ¥çœ‹è¯¦æƒ…').should('be.visible');
    });
  });
  
  it('filters appeals by status', () => {
    cy.get('[name="status"]').select('å¾…å®¡æ‰¹');
    
    cy.get('.appeal-card').each(($card) => {
      cy.wrap($card).contains('[å¾…å®¡æ‰¹]').should('be.visible');
    });
  });
});
```

---

## âš¡ æ€§èƒ½æµ‹è¯•

### æµ‹è¯•å·¥å…·

- **é“¾ç«¯**ï¼šSubstrate benchmarking
- **å‰ç«¯**ï¼šLighthouse + Web Vitals

### æ€§èƒ½æŒ‡æ ‡

| æŒ‡æ ‡ | ç›®æ ‡ | æµ‹è¯•æ–¹æ³• |
|-----|------|---------|
| **é“¾ç«¯æ€§èƒ½** | | |
| submit_appeal | <500ms | benchmark |
| approve_appeal | <300ms | benchmark |
| on_initializeï¼ˆæ‰§è¡Œ100ä¸ªï¼‰ | <2s | benchmark |
| **å‰ç«¯æ€§èƒ½** | | |
| é¦–å±åŠ è½½ | <2s | Lighthouse |
| ç”³è¯‰åˆ—è¡¨æ¸²æŸ“ï¼ˆ100æ¡ï¼‰ | <1s | æ‰‹åŠ¨æµ‹è¯• |
| æäº¤ç”³è¯‰è¡¨å•æäº¤ | <3s | æ‰‹åŠ¨æµ‹è¯• |
| **APIæ€§èƒ½** | | |
| æŸ¥è¯¢å•ä¸ªç”³è¯‰ | <100ms | curl |
| æŸ¥è¯¢ç”³è¯‰åˆ—è¡¨ï¼ˆ100æ¡ï¼‰ | <500ms | curl |
| æŸ¥è¯¢æŠ¼é‡‘åˆ—è¡¨ï¼ˆ100æ¡ï¼‰ | <500ms | curl |

### Benchmarkå®ç°

```rust
// pallets/stardust-appeals/benches/benchmarking.rs

benchmarks! {
    submit_appeal {
        let caller = funded_account::<T>("caller", 0);
        let reason_cid = vec![1u8; 128];
        let evidence_cid = vec![2u8; 128];
    }: _(
        RawOrigin::Signed(caller),
        1,  // domain
        123,  // target
        10,  // action
        reason_cid.try_into().unwrap(),
        evidence_cid.try_into().unwrap()
    )
    verify {
        assert_eq!(Appeals::<T>::iter().count(), 1);
    }
    
    approve_appeal {
        // Setup: å…ˆæäº¤ä¸€ä¸ªç”³è¯‰
        let alice = funded_account::<T>("alice", 0);
        MemoAppeals::<T>::submit_appeal(
            RawOrigin::Signed(alice).into(),
            1, 123, 10,
            vec![1; 128].try_into().unwrap(),
            vec![2; 128].try_into().unwrap(),
        ).unwrap();
    }: _(RawOrigin::Root, 0, None)
    verify {
        let appeal = Appeals::<T>::get(0).unwrap();
        assert_eq!(appeal.status, 1);
    }
}
```

---

## ğŸ”’ å®‰å…¨æµ‹è¯•

### å®‰å…¨æµ‹è¯•æ¸…å•

- [ ] **æƒé™æµ‹è¯•**
  - [ ] æ™®é€šç”¨æˆ·æ— æ³•æ‰¹å‡†ç”³è¯‰
  - [ ] æ™®é€šç”¨æˆ·æ— æ³•é‡Šæ”¾ä»–äººæŠ¼é‡‘
  - [ ] æ™®é€šç”¨æˆ·åªèƒ½æ’¤å›è‡ªå·±çš„ç”³è¯‰

- [ ] **èµ„é‡‘å®‰å…¨æµ‹è¯•**
  - [ ] æŠ¼é‡‘å¿…é¡»å†»ç»“æ‰èƒ½åˆ›å»ºç”³è¯‰
  - [ ] æŠ¼é‡‘ä¸èƒ½é‡å¤é‡Šæ”¾
  - [ ] ç½šæ²¡é‡‘é¢è®¡ç®—æ­£ç¡®
  - [ ] æ— æ³•é€šè¿‡æº¢å‡ºæ”»å‡»ç›—å–èµ„é‡‘

- [ ] **DoSé˜²æŠ¤æµ‹è¯•**
  - [ ] é™é¢‘æœºåˆ¶æœ‰æ•ˆ
  - [ ] æ‰§è¡Œé˜Ÿåˆ—ä¸ä¼šæ— é™å¢é•¿
  - [ ] æ¶æ„å¤§é‡ç”³è¯‰è¢«æ‹’ç»

- [ ] **æ•°æ®å®Œæ•´æ€§æµ‹è¯•**
  - [ ] CIDæ ¼å¼éªŒè¯
  - [ ] ç†ç”±æœ€å°é•¿åº¦éªŒè¯
  - [ ] domain/actionèŒƒå›´éªŒè¯

---

## ğŸ“Š æµ‹è¯•æŠ¥å‘Šæ¨¡æ¿

### å•å…ƒæµ‹è¯•æŠ¥å‘Š

```
æµ‹è¯•æ—¥æœŸ: 2025-10-XX
æµ‹è¯•äººå‘˜: XXX
ç¯å¢ƒ: æµ‹è¯•ç¯å¢ƒ

æµ‹è¯•ç»“æœ:
- æ€»ç”¨ä¾‹æ•°: 150
- é€šè¿‡: 148
- å¤±è´¥: 2
- è¦†ç›–ç‡: 92.5%

å¤±è´¥ç”¨ä¾‹:
1. test_slash_deposit_overflow - æº¢å‡ºæ£€æŸ¥å¤±è´¥
2. test_rate_limit_edge_case - è¾¹ç•Œæ¡ä»¶æœªå¤„ç†

ä¿®å¤è®¡åˆ’:
- 2å¤©å†…ä¿®å¤æ‰€æœ‰å¤±è´¥ç”¨ä¾‹
- è¡¥å……è¾¹ç•Œæµ‹è¯•ç”¨ä¾‹
```

### æ€§èƒ½æµ‹è¯•æŠ¥å‘Š

```
æµ‹è¯•æ—¥æœŸ: 2025-10-XX
æµ‹è¯•ç¯å¢ƒ: æœ¬åœ°æµ‹è¯•é“¾

æ€§èƒ½æŒ‡æ ‡:
- submit_appeal: 350ms âœ… (ç›®æ ‡<500ms)
- approve_appeal: 280ms âœ… (ç›®æ ‡<300ms)
- on_initialize(100): 1.8s âœ… (ç›®æ ‡<2s)
- å‰ç«¯é¦–å±: 1.5s âœ… (ç›®æ ‡<2s)

ç»“è®º: æ‰€æœ‰æ€§èƒ½æŒ‡æ ‡è¾¾æ ‡
```

---

**æ€»ç»“**ï¼šå®Œæ•´çš„æµ‹è¯•æ–¹æ¡ˆæ¶µç›–äº†å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€å‰ç«¯æµ‹è¯•ã€æ€§èƒ½æµ‹è¯•å’Œå®‰å…¨æµ‹è¯•ï¼Œç¡®ä¿ç³»ç»Ÿè´¨é‡ã€‚

