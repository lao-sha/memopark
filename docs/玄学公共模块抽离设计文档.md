# 玄学公共模块抽离设计文档

> 版本：v1.0.0
> 日期：2025-11-29
> 作者：Stardust 开发团队

## 一、背景与目标

### 1.1 现状分析

当前 Stardust 链上已实现两套传统玄学系统：

| 系统 | 核心 Pallet | 辅助 Pallet | 状态 |
|------|-------------|-------------|------|
| 梅花易数 | pallet-meihua | meihua-ai, meihua-market, meihua-nft | ✅ 完成 |
| 八字排盘 | pallet-bazi-chart | (无) | ✅ 核心完成 |

**问题**：
- 八字系统缺少 AI 解读、服务市场、NFT 功能
- 未来扩展其他玄学系统（六爻、奇门遁甲、紫微斗数等）需要重复开发
- 三个辅助模块（AI、Market、NFT）70% 代码可复用

### 1.2 目标

将 `pallet-meihua-ai`、`pallet-meihua-market`、`pallet-meihua-nft` 抽离为通用公共模块：

```
pallet-divination-ai      # 通用 AI 解读服务
pallet-divination-market  # 通用占卜服务市场
pallet-divination-nft     # 通用玄学 NFT 系统
```

使其可同时服务于：
- 梅花易数 (Meihua)
- 八字排盘 (Bazi)
- 六爻占卜 (Liuyao) - 未来
- 奇门遁甲 (Qimen) - 未来
- 紫微斗数 (Ziwei) - 未来

---

## 二、可行性分析

### 2.1 现有耦合度分析

| 依赖关系 | 耦合类型 | 抽离难度 | 说明 |
|---------|---------|---------|------|
| meihua-ai → meihua | ID 引用 | ⭐ 低 | 仅通过 `hexagram_id: u64` 关联 |
| meihua-market → meihua | ID 引用 | ⭐ 低 | Order 中包含 `hexagram_id` |
| meihua-nft → meihua | **Trait 依赖** | ⭐⭐⭐ 高 | 需实现 `HexagramProvider` trait |

### 2.2 核心抽象点

#### 2.2.1 占卜结果的统一抽象

```rust
/// 通用占卜结果 trait
pub trait DivinationResult {
    /// 结果唯一标识符
    fn result_id(&self) -> u64;

    /// 创建者账户
    fn creator(&self) -> Self::AccountId;

    /// 结果类型标识（meihua/bazi/liuyao 等）
    fn result_type(&self) -> DivinationType;

    /// 稀有度计算数据
    fn rarity_data(&self) -> RarityInput;

    /// 是否可 NFT 化
    fn is_nftable(&self) -> bool;
}

/// 占卜类型枚举
#[derive(Clone, Copy, PartialEq, Eq, Encode, Decode, TypeInfo)]
pub enum DivinationType {
    Meihua = 0,    // 梅花易数
    Bazi = 1,      // 八字排盘
    Liuyao = 2,    // 六爻占卜
    Qimen = 3,     // 奇门遁甲
    Ziwei = 4,     // 紫微斗数
}

/// 稀有度计算输入
pub struct RarityInput {
    pub primary_factor: u8,      // 主要因素（如卦象类型、日主强弱）
    pub secondary_factor: u8,    // 次要因素（如动爻位置、格局类型）
    pub special_date: bool,      // 特殊日期（节气、节日）
    pub special_combination: bool, // 特殊组合（纯卦、六冲六合等）
}
```

#### 2.2.2 Provider Trait 泛化

```rust
/// 通用占卜结果提供者 trait
pub trait DivinationProvider<AccountId> {
    /// 检查结果是否存在
    fn result_exists(result_type: DivinationType, result_id: u64) -> bool;

    /// 获取创建者
    fn result_creator(result_type: DivinationType, result_id: u64) -> Option<AccountId>;

    /// 获取稀有度计算数据
    fn rarity_data(result_type: DivinationType, result_id: u64) -> Option<RarityInput>;

    /// 获取结果摘要（用于 AI 解读）
    fn result_summary(result_type: DivinationType, result_id: u64) -> Option<Vec<u8>>;
}
```

### 2.3 业务逻辑复用率分析

| 模块 | 可复用代码 | 需定制代码 | 复用率 |
|------|-----------|-----------|--------|
| AI 解读 | 请求管理、预言机、费用分配、争议处理 | 解读 prompt 模板 | 85% |
| 服务市场 | 提供者管理、订单流程、评价系统、提现 | 服务类型定义 | 80% |
| NFT 系统 | 铸造、交易、出价、收藏集、版税 | 稀有度算法 | 75% |

---

## 三、架构设计

### 3.1 模块层次结构

```
┌─────────────────────────────────────────────────────────────────┐
│                        应用层 (Application Layer)                │
├─────────────┬─────────────┬─────────────┬─────────────┬─────────┤
│ pallet-     │ pallet-     │ pallet-     │ pallet-     │ ...     │
│ meihua      │ bazi-chart  │ liuyao      │ qimen       │         │
│ (梅花易数)   │ (八字排盘)   │ (六爻占卜)   │ (奇门遁甲)   │         │
├─────────────┴─────────────┴─────────────┴─────────────┴─────────┤
│                        公共服务层 (Common Service Layer)          │
├─────────────────────┬─────────────────────┬─────────────────────┤
│ pallet-divination-  │ pallet-divination-  │ pallet-divination-  │
│ ai                  │ market              │ nft                 │
│ (AI 解读服务)        │ (占卜服务市场)        │ (玄学 NFT)          │
├─────────────────────┴─────────────────────┴─────────────────────┤
│                        基础设施层 (Infrastructure Layer)          │
├─────────────────────┬─────────────────────┬─────────────────────┤
│ pallet-fee-         │ pallet-reputation   │ frame-system        │
│ distribution        │ (评分信誉)           │ pallet-balances     │
│ (费用分配)           │                     │ pallet-timestamp    │
└─────────────────────┴─────────────────────┴─────────────────────┘
```

### 3.2 模块间通信

```
                    ┌──────────────────┐
                    │   用户请求        │
                    └────────┬─────────┘
                             │
        ┌────────────────────┼────────────────────┐
        ▼                    ▼                    ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│ pallet-meihua │   │ pallet-bazi   │   │ pallet-liuyao │
│               │   │               │   │               │
│ - 起卦        │   │ - 排盘        │   │ - 摇卦        │
│ - 存储卦象    │   │ - 存储命盘    │   │ - 存储卦象    │
└───────┬───────┘   └───────┬───────┘   └───────┬───────┘
        │                   │                   │
        │ DivinationProvider trait              │
        └───────────────────┼───────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        ▼                   ▼                   ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│ divination-ai │   │ divination-   │   │ divination-   │
│               │   │ market        │   │ nft           │
│ - AI 解读     │   │ - 人工服务    │   │ - NFT 铸造    │
│ - 预言机管理  │   │ - 订单管理    │   │ - 交易市场    │
└───────────────┘   └───────────────┘   └───────────────┘
```

### 3.3 关键 Trait 定义

#### 3.3.1 pallet-divination-common（公共类型库）

```rust
// pallets/divination-common/src/lib.rs

#![cfg_attr(not(feature = "std"), no_std)]

use codec::{Decode, Encode, MaxEncodedLen};
use scale_info::TypeInfo;
use sp_std::vec::Vec;

/// 占卜类型
#[derive(Clone, Copy, PartialEq, Eq, Encode, Decode, TypeInfo, MaxEncodedLen, Debug)]
pub enum DivinationType {
    Meihua = 0,    // 梅花易数
    Bazi = 1,      // 八字排盘
    Liuyao = 2,    // 六爻占卜
    Qimen = 3,     // 奇门遁甲
    Ziwei = 4,     // 紫微斗数
    Custom(u8),    // 自定义类型（预留扩展）
}

/// 稀有度等级
#[derive(Clone, Copy, PartialEq, Eq, Encode, Decode, TypeInfo, MaxEncodedLen, Debug)]
pub enum Rarity {
    Common = 0,     // 普通
    Rare = 1,       // 稀有
    Epic = 2,       // 史诗
    Legendary = 3,  // 传说
}

/// 稀有度计算输入数据
#[derive(Clone, Encode, Decode, TypeInfo, MaxEncodedLen, Debug)]
pub struct RarityInput {
    /// 主要因素权重 (0-100)
    pub primary_score: u8,
    /// 次要因素权重 (0-100)
    pub secondary_score: u8,
    /// 是否特殊日期
    pub is_special_date: bool,
    /// 是否特殊组合
    pub is_special_combination: bool,
    /// 自定义稀有度因子
    pub custom_factors: [u8; 4],
}

impl RarityInput {
    /// 计算稀有度
    pub fn calculate_rarity(&self) -> Rarity {
        let mut score = 0u16;

        // 主要因素权重
        score += self.primary_score as u16 * 3;

        // 次要因素权重
        score += self.secondary_score as u16 * 2;

        // 特殊日期加成
        if self.is_special_date {
            score += 50;
        }

        // 特殊组合加成
        if self.is_special_combination {
            score += 100;
        }

        // 自定义因子
        for factor in self.custom_factors.iter() {
            score += *factor as u16;
        }

        match score {
            0..=100 => Rarity::Common,
            101..=200 => Rarity::Rare,
            201..=350 => Rarity::Epic,
            _ => Rarity::Legendary,
        }
    }
}

/// 占卜结果提供者 trait
pub trait DivinationProvider<AccountId> {
    /// 检查占卜结果是否存在
    fn result_exists(divination_type: DivinationType, result_id: u64) -> bool;

    /// 获取创建者账户
    fn result_creator(divination_type: DivinationType, result_id: u64) -> Option<AccountId>;

    /// 获取稀有度计算数据
    fn rarity_data(divination_type: DivinationType, result_id: u64) -> Option<RarityInput>;

    /// 获取结果摘要（用于 AI 解读输入）
    fn result_summary(divination_type: DivinationType, result_id: u64) -> Option<Vec<u8>>;

    /// 检查是否可 NFT 化（未被铸造过）
    fn is_nftable(divination_type: DivinationType, result_id: u64) -> bool;

    /// 标记已 NFT 化
    fn mark_as_nfted(divination_type: DivinationType, result_id: u64);
}

/// AI 解读类型
#[derive(Clone, Copy, PartialEq, Eq, Encode, Decode, TypeInfo, MaxEncodedLen, Debug)]
pub enum InterpretationType {
    Basic = 0,         // 基础解读
    Detailed = 1,      // 详细解读
    Professional = 2,  // 专业解读
    Career = 3,        // 事业方向
    Relationship = 4,  // 感情婚姻
    Health = 5,        // 健康运势
    Wealth = 6,        // 财运投资
}

/// 解读状态
#[derive(Clone, Copy, PartialEq, Eq, Encode, Decode, TypeInfo, MaxEncodedLen, Debug)]
pub enum InterpretationStatus {
    Pending = 0,     // 等待处理
    Processing = 1,  // 处理中
    Completed = 2,   // 已完成
    Failed = 3,      // 失败
    Expired = 4,     // 已过期
    Disputed = 5,    // 争议中
}

/// 服务类型
#[derive(Clone, Copy, PartialEq, Eq, Encode, Decode, TypeInfo, MaxEncodedLen, Debug)]
pub enum ServiceType {
    TextReading = 0,       // 文字解读
    VoiceReading = 1,      // 语音解读
    VideoReading = 2,      // 视频解读
    LiveConsultation = 3,  // 实时咨询
}

/// 订单状态
#[derive(Clone, Copy, PartialEq, Eq, Encode, Decode, TypeInfo, MaxEncodedLen, Debug)]
pub enum OrderStatus {
    PendingPayment = 0,
    Paid = 1,
    Accepted = 2,
    Completed = 3,
    Reviewed = 4,
    Cancelled = 5,
    Refunded = 6,
    Disputed = 7,
}
```

#### 3.3.2 pallet-divination-ai 配置

```rust
// pallets/divination-ai/src/lib.rs (配置部分)

#[pallet::config]
pub trait Config: frame_system::Config + pallet_timestamp::Config {
    type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;

    /// 货币类型
    type Currency: Currency<Self::AccountId> + ReservableCurrency<Self::AccountId>;

    /// 占卜结果提供者（关键：泛化依赖）
    type DivinationProvider: DivinationProvider<Self::AccountId>;

    /// 基础解读费用
    #[pallet::constant]
    type BaseInterpretationFee: Get<BalanceOf<Self>>;

    /// 预言机最低质押
    #[pallet::constant]
    type MinOracleStake: Get<BalanceOf<Self>>;

    /// 请求超时（区块数）
    #[pallet::constant]
    type RequestTimeout: Get<BlockNumberFor<Self>>;

    /// 国库账户
    type TreasuryAccount: Get<Self::AccountId>;

    /// 治理来源
    type GovernanceOrigin: EnsureOrigin<Self::RuntimeOrigin>;

    /// 仲裁来源
    type ArbitratorOrigin: EnsureOrigin<Self::RuntimeOrigin>;
}
```

### 3.4 Runtime 集成示例

```rust
// runtime/src/configs/mod.rs

/// 梅花易数占卜提供者实现
pub struct MeihuaDivinationProvider;

impl divination_common::DivinationProvider<AccountId> for MeihuaDivinationProvider {
    fn result_exists(divination_type: DivinationType, result_id: u64) -> bool {
        match divination_type {
            DivinationType::Meihua => Meihua::hexagrams(result_id).is_some(),
            _ => false,
        }
    }

    fn result_creator(divination_type: DivinationType, result_id: u64) -> Option<AccountId> {
        match divination_type {
            DivinationType::Meihua => {
                Meihua::hexagrams(result_id).map(|h| h.ben_gua.diviner)
            },
            _ => None,
        }
    }

    fn rarity_data(divination_type: DivinationType, result_id: u64) -> Option<RarityInput> {
        match divination_type {
            DivinationType::Meihua => {
                Meihua::hexagrams(result_id).map(|h| {
                    let ben_gua = &h.ben_gua;
                    let is_pure = ben_gua.shang_gua.bagua == ben_gua.xia_gua.bagua;

                    RarityInput {
                        primary_score: if is_pure { 80 } else { 30 },
                        secondary_score: match ben_gua.dong_yao {
                            1 | 6 => 20,  // 初爻或上爻
                            _ => 10,
                        },
                        is_special_date: false,  // TODO: 节气判断
                        is_special_combination: is_pure,
                        custom_factors: [0, 0, 0, 0],
                    }
                })
            },
            _ => None,
        }
    }

    fn result_summary(divination_type: DivinationType, result_id: u64) -> Option<Vec<u8>> {
        match divination_type {
            DivinationType::Meihua => {
                Meihua::hexagrams(result_id).map(|h| {
                    // 序列化卦象摘要用于 AI 解读
                    h.encode()
                })
            },
            _ => None,
        }
    }

    fn is_nftable(divination_type: DivinationType, result_id: u64) -> bool {
        match divination_type {
            DivinationType::Meihua => {
                !DivinationNft::nft_exists(divination_type, result_id)
            },
            _ => false,
        }
    }

    fn mark_as_nfted(divination_type: DivinationType, result_id: u64) {
        // 由 NFT pallet 内部处理
    }
}

/// 八字排盘占卜提供者实现
pub struct BaziDivinationProvider;

impl divination_common::DivinationProvider<AccountId> for BaziDivinationProvider {
    fn result_exists(divination_type: DivinationType, result_id: u64) -> bool {
        match divination_type {
            DivinationType::Bazi => BaziChart::chart_exists(result_id),
            _ => false,
        }
    }

    fn result_creator(divination_type: DivinationType, result_id: u64) -> Option<AccountId> {
        match divination_type {
            DivinationType::Bazi => BaziChart::chart_owner(result_id),
            _ => None,
        }
    }

    fn rarity_data(divination_type: DivinationType, result_id: u64) -> Option<RarityInput> {
        match divination_type {
            DivinationType::Bazi => {
                BaziChart::get_chart(result_id).map(|chart| {
                    // 基于八字特征计算稀有度
                    let is_special_pattern = chart.has_special_pattern();
                    let day_master_strength = chart.wuxing_strength.day_master_score();

                    RarityInput {
                        primary_score: day_master_strength,
                        secondary_score: if is_special_pattern { 50 } else { 20 },
                        is_special_date: chart.is_solar_term_birth(),
                        is_special_combination: is_special_pattern,
                        custom_factors: [0, 0, 0, 0],
                    }
                })
            },
            _ => None,
        }
    }

    fn result_summary(divination_type: DivinationType, result_id: u64) -> Option<Vec<u8>> {
        match divination_type {
            DivinationType::Bazi => {
                BaziChart::get_chart(result_id).map(|chart| chart.encode())
            },
            _ => None,
        }
    }

    fn is_nftable(divination_type: DivinationType, result_id: u64) -> bool {
        match divination_type {
            DivinationType::Bazi => {
                !DivinationNft::nft_exists(divination_type, result_id)
            },
            _ => false,
        }
    }

    fn mark_as_nfted(_: DivinationType, _: u64) {}
}

/// 组合提供者（支持多种占卜类型）
pub struct CombinedDivinationProvider;

impl divination_common::DivinationProvider<AccountId> for CombinedDivinationProvider {
    fn result_exists(divination_type: DivinationType, result_id: u64) -> bool {
        match divination_type {
            DivinationType::Meihua => MeihuaDivinationProvider::result_exists(divination_type, result_id),
            DivinationType::Bazi => BaziDivinationProvider::result_exists(divination_type, result_id),
            _ => false,
        }
    }

    // ... 其他方法类似委托
}

// Runtime 配置
impl pallet_divination_ai::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type Currency = Balances;
    type DivinationProvider = CombinedDivinationProvider;  // 使用组合提供者
    type BaseInterpretationFee = ConstU128<{ 10 * UNIT }>;
    type MinOracleStake = ConstU128<{ 1000 * UNIT }>;
    type RequestTimeout = ConstU32<{ 10 * MINUTES }>;
    type TreasuryAccount = TreasuryPalletId;
    type GovernanceOrigin = EnsureRoot<AccountId>;
    type ArbitratorOrigin = EnsureSigned<AccountId>;
}
```

---

## 四、迁移方案

### 4.1 迁移步骤

```
Phase 1: 创建公共类型库 (1周)
├── 创建 pallets/divination-common
├── 定义 DivinationType、Rarity、RarityInput
├── 定义 DivinationProvider trait
└── 单元测试

Phase 2: 重构 AI 解读模块 (2周)
├── 复制 meihua-ai → divination-ai
├── 替换 hexagram_id → (divination_type, result_id)
├── 替换 HexagramProvider → DivinationProvider
├── 更新存储结构
├── 迁移测试用例
└── 数据迁移脚本

Phase 3: 重构服务市场模块 (2周)
├── 复制 meihua-market → divination-market
├── 添加 divination_type 字段
├── 更新订单结构
├── 迁移测试用例
└── 数据迁移脚本

Phase 4: 重构 NFT 模块 (2周)
├── 复制 meihua-nft → divination-nft
├── 替换 HexagramNft → DivinationNft
├── 添加 divination_type 字段
├── 实现通用稀有度算法
├── 迁移测试用例
└── 数据迁移脚本

Phase 5: Runtime 集成 (1周)
├── 实现各玄学系统的 Provider
├── 配置公共模块
├── 集成测试
└── 文档更新

Phase 6: 前端适配 (2周)
├── 更新 TypeScript 类型
├── 更新服务层
├── 组件泛化
└── 端到端测试

Total: 10周
```

### 4.2 数据迁移

```rust
// 存储迁移示例
pub struct MigrateToGenericDivinationNft;

impl OnRuntimeUpgrade for MigrateToGenericDivinationNft {
    fn on_runtime_upgrade() -> Weight {
        // 1. 读取旧的 meihua-nft 数据
        let old_nfts = pallet_meihua_nft::Nfts::<Runtime>::iter().collect::<Vec<_>>();

        // 2. 转换为新格式
        for (nft_id, old_nft) in old_nfts {
            let new_nft = pallet_divination_nft::DivinationNft {
                id: nft_id,
                divination_type: DivinationType::Meihua,  // 标记为梅花类型
                result_id: old_nft.hexagram_id,
                owner: old_nft.owner,
                creator: old_nft.creator,
                rarity: old_nft.rarity,
                // ... 其他字段
            };

            pallet_divination_nft::Nfts::<Runtime>::insert(nft_id, new_nft);
        }

        // 3. 删除旧存储（可选）
        // pallet_meihua_nft::Nfts::<Runtime>::remove_all(None);

        Weight::zero()
    }
}
```

---

## 五、技术难点与解决方案

### 5.1 难点1：多类型占卜结果的统一抽象

**问题**：
- 梅花卦象和八字命盘数据结构完全不同
- 稀有度计算逻辑差异大

**解决方案**：
```rust
// 使用 RarityInput 作为中间抽象层
// 各玄学系统自行实现数据到 RarityInput 的转换

// 梅花系统
impl From<FullDivination> for RarityInput {
    fn from(divination: FullDivination) -> Self {
        RarityInput {
            primary_score: if divination.is_pure_hexagram() { 80 } else { 30 },
            // ...
        }
    }
}

// 八字系统
impl From<BaziChart> for RarityInput {
    fn from(chart: BaziChart) -> Self {
        RarityInput {
            primary_score: chart.day_master_strength(),
            // ...
        }
    }
}
```

### 5.2 难点2：AI 解读的 Prompt 差异化

**问题**：
- 梅花解读需要卦象、体用关系、动爻等信息
- 八字解读需要四柱、大运、五行强度等信息

**解决方案**：
```rust
/// AI 解读上下文生成器
pub trait InterpretationContextGenerator<AccountId> {
    /// 生成 AI 解读的上下文 JSON
    fn generate_context(
        divination_type: DivinationType,
        result_id: u64,
        interpretation_type: InterpretationType,
    ) -> Option<Vec<u8>>;
}

// 实现示例
pub struct MeihuaContextGenerator;

impl InterpretationContextGenerator<AccountId> for MeihuaContextGenerator {
    fn generate_context(
        divination_type: DivinationType,
        result_id: u64,
        interpretation_type: InterpretationType,
    ) -> Option<Vec<u8>> {
        if divination_type != DivinationType::Meihua {
            return None;
        }

        let hexagram = Meihua::hexagrams(result_id)?;

        // 生成梅花易数专用的 AI prompt 上下文
        let context = json!({
            "type": "meihua",
            "ben_gua": {
                "shang": hexagram.ben_gua.shang_gua.to_string(),
                "xia": hexagram.ben_gua.xia_gua.to_string(),
            },
            "dong_yao": hexagram.ben_gua.dong_yao,
            "ti_yong": hexagram.ti_yong.to_string(),
            "interpretation_type": interpretation_type.to_string(),
        });

        Some(context.to_string().into_bytes())
    }
}
```

### 5.3 难点3：前端组件复用

**问题**：
- NFT 卡片展示内容不同
- 详情页布局差异

**解决方案**：
```tsx
// 使用组件插槽模式

interface DivinationNftCardProps<T> {
  nft: DivinationNft;
  // 自定义渲染插槽
  renderPreview: (data: T) => React.ReactNode;
  renderDetails: (data: T) => React.ReactNode;
}

// 梅花卦象预览组件
const MeihuaPreview: React.FC<{ hexagram: Hexagram }> = ({ hexagram }) => (
  <div className="hexagram-display">
    <span className="trigram">{TRIGRAM_SYMBOLS[hexagram.upperTrigram]}</span>
    <span className="trigram">{TRIGRAM_SYMBOLS[hexagram.lowerTrigram]}</span>
  </div>
);

// 八字命盘预览组件
const BaziPreview: React.FC<{ chart: BaziChart }> = ({ chart }) => (
  <div className="bazi-display">
    <div className="pillar year">{chart.yearPillar}</div>
    <div className="pillar month">{chart.monthPillar}</div>
    <div className="pillar day">{chart.dayPillar}</div>
    <div className="pillar hour">{chart.hourPillar}</div>
  </div>
);

// 通用 NFT 卡片
const DivinationNftCard: React.FC<DivinationNftCardProps<any>> = ({
  nft,
  renderPreview,
  renderDetails,
}) => {
  const previewData = useDivinationData(nft.divinationType, nft.resultId);

  return (
    <Card>
      {renderPreview(previewData)}
      <Tag color={RARITY_COLORS[nft.rarity]}>{RARITY_NAMES[nft.rarity]}</Tag>
      {renderDetails(previewData)}
    </Card>
  );
};
```

---

## 六、优势与收益分析

### 6.1 代码复用

| 指标 | 当前状态 | 重构后 | 节省 |
|------|---------|--------|------|
| AI 模块代码行数 | 1,200 × N | 1,200 + 200×N | ~70% |
| Market 模块代码 | 1,500 × N | 1,500 + 250×N | ~65% |
| NFT 模块代码 | 1,000 × N | 1,000 + 150×N | ~75% |
| 测试代码 | 800 × N | 800 + 100×N | ~80% |

> N = 玄学系统数量

### 6.2 维护成本

- **Bug 修复**：修复一处，所有系统受益
- **功能升级**：统一升级公共模块
- **安全审计**：审计范围减少 60%

### 6.3 扩展效率

添加新玄学系统的工作量：

| 工作项 | 当前模式 | 公共模块模式 |
|--------|---------|-------------|
| AI 解读集成 | 2周 | 2天 |
| 服务市场集成 | 3周 | 3天 |
| NFT 系统集成 | 2周 | 2天 |
| **总计** | **7周** | **1周** |

---

## 七、风险评估

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|---------|
| 迁移过程数据丢失 | 低 | 高 | 完整备份，分阶段迁移，回滚脚本 |
| 接口变更导致前端故障 | 中 | 中 | API 版本管理，渐进式迁移 |
| 性能下降（多层抽象） | 低 | 低 | 基准测试，必要时内联优化 |
| 复杂度增加 | 中 | 中 | 完善文档，清晰的模块边界 |

---

## 八、结论与建议

### 8.1 可行性结论

**技术可行性：✅ 高**
- 现有模块耦合度低，已有良好的抽象基础
- Rust trait 系统支持优雅的泛化设计
- 无需修改底层 Substrate 框架

**业务可行性：✅ 高**
- 八字系统确实需要 AI、Market、NFT 功能
- 未来扩展需求明确（六爻、奇门等）
- 复用率高达 70-80%

**时间可行性：⚠️ 中等**
- 完整迁移需 10 周
- 可分阶段实施，不影响现有功能

### 8.2 实施建议

1. **优先级**：
   - P0: 创建 divination-common 公共类型库
   - P1: 重构 NFT 模块（复用率最高）
   - P2: 重构 AI 模块
   - P3: 重构 Market 模块

2. **里程碑**：
   - M1: 公共类型库 + NFT 模块（4周）
   - M2: AI 模块重构（3周）
   - M3: Market 模块重构（3周）

3. **并行工作**：
   - 在重构期间，八字系统可先使用旧的梅花模块（添加 adapter）
   - 前端可提前开始组件泛化设计

### 8.3 最终建议

**强烈建议实施公共模块抽离**，理由：

1. **投入产出比高**：10周投入，节省未来 6-7 周/系统
2. **架构质量提升**：更清晰的模块边界，更好的可维护性
3. **业务扩展加速**：快速支持六爻、奇门等新系统
4. **团队效率提升**：减少重复工作，专注业务创新

---

## 附录

### A. 文件结构（重构后）

```
pallets/
├── divination-common/          # 公共类型库
│   ├── src/
│   │   ├── lib.rs
│   │   ├── types.rs
│   │   └── traits.rs
│   └── Cargo.toml
│
├── divination-ai/              # 通用 AI 解读
│   ├── src/
│   │   ├── lib.rs
│   │   ├── types.rs
│   │   ├── oracle.rs
│   │   ├── dispute.rs
│   │   └── benchmarking.rs
│   └── Cargo.toml
│
├── divination-market/          # 通用服务市场
│   ├── src/
│   │   ├── lib.rs
│   │   ├── types.rs
│   │   ├── provider.rs
│   │   ├── order.rs
│   │   ├── review.rs
│   │   └── benchmarking.rs
│   └── Cargo.toml
│
├── divination-nft/             # 通用玄学 NFT
│   ├── src/
│   │   ├── lib.rs
│   │   ├── types.rs
│   │   ├── mint.rs
│   │   ├── trade.rs
│   │   ├── collection.rs
│   │   └── benchmarking.rs
│   └── Cargo.toml
│
├── meihua/                     # 梅花易数核心（保持）
├── bazi-chart/                 # 八字排盘核心（保持）
└── ...
```

### B. 前端目录结构（重构后）

```
stardust-dapp/src/
├── features/
│   ├── divination/             # 通用占卜组件
│   │   ├── components/
│   │   │   ├── NftCard.tsx
│   │   │   ├── NftMarket.tsx
│   │   │   ├── AiInterpretation.tsx
│   │   │   └── ServiceMarket.tsx
│   │   ├── hooks/
│   │   │   ├── useDivinationNft.ts
│   │   │   └── useDivinationService.ts
│   │   └── types.ts
│   │
│   ├── meihua/                 # 梅花易数专用
│   │   ├── DivinationPage.tsx
│   │   ├── HexagramPreview.tsx  # 插槽实现
│   │   └── ...
│   │
│   └── bazi/                   # 八字排盘专用
│       ├── ChartPage.tsx
│       ├── BaziPreview.tsx      # 插槽实现
│       └── ...
│
├── services/
│   ├── divinationService.ts    # 通用服务
│   ├── meihuaService.ts        # 梅花专用
│   └── baziService.ts          # 八字专用
│
└── types/
    ├── divination.ts           # 通用类型
    ├── meihua.ts
    └── bazi.ts
```

---

*文档结束*
