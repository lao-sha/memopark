# pallet-stardust-grave åˆ é™¤å¯è¡Œæ€§æ–¹æ¡ˆ

**ç‰ˆæœ¬**: v2.0.0-Final
**æ—¥æœŸ**: 2025-11-16
**çŠ¶æ€**: ğŸ¯ ç»¼åˆå¯è¡Œæ–¹æ¡ˆ
**ä½œè€…**: Stardust Dev Team

---

## ğŸ“‹ æ‰§è¡Œæ€»ç»“

æœ¬æ–¹æ¡ˆç»“åˆäº†ä¸‰ä»½ç‹¬ç«‹åˆ†ææ–‡æ¡£çš„æœ€ä½³å®è·µï¼Œè®¾è®¡äº†ä¸€ä¸ª**åˆ†é˜¶æ®µã€ä½é£é™©ã€å¯å›æ»š**çš„pallet-stardust-graveåˆ é™¤æ–¹æ¡ˆã€‚

**æ ¸å¿ƒç­–ç•¥**ï¼š
- ğŸ”„ **æ¸è¿›å¼è¿ç§»**ï¼šå…ˆä¿ç•™æ¥å£ï¼Œå†é€æ­¥è¿ç§»åŠŸèƒ½
- ğŸ›¡ï¸ **æ•°æ®å®‰å…¨ä¼˜å…ˆ**ï¼šå®Œæ•´å¤‡ä»½ + å¢é‡éªŒè¯
- ğŸ”€ **æ™ºèƒ½é‡å®šå‘**ï¼šä¸šåŠ¡é€»è¾‘è¿ç§»åˆ°æœ€é€‚åˆçš„pallet
- ğŸ“Š **ç”¨æˆ·ä½“éªŒä¿éšœ**ï¼šé€æ˜åŒ–è¿ç§»ï¼Œæœ€å°åŒ–æ„ŸçŸ¥

---

## ğŸ“‹ ç›®å½•

1. [æ–¹æ¡ˆå¯¹æ¯”ä¸é€‰æ‹©](#æ–¹æ¡ˆå¯¹æ¯”ä¸é€‰æ‹©)
2. [æœ€ä¼˜æ¶æ„è®¾è®¡](#æœ€ä¼˜æ¶æ„è®¾è®¡)
3. [åˆ†é˜¶æ®µå®æ–½è®¡åˆ’](#åˆ†é˜¶æ®µå®æ–½è®¡åˆ’)
4. [ä¸šåŠ¡é€»è¾‘é‡æ„](#ä¸šåŠ¡é€»è¾‘é‡æ„)
5. [æ•°æ®è¿ç§»ç­–ç•¥](#æ•°æ®è¿ç§»ç­–ç•¥)
6. [é£é™©æ§åˆ¶ä½“ç³»](#é£é™©æ§åˆ¶ä½“ç³»)
7. [è´¨é‡ä¿è¯](#è´¨é‡ä¿è¯)
8. [æˆæœ¬æ•ˆç›Šåˆ†æ](#æˆæœ¬æ•ˆç›Šåˆ†æ)

---

## æ–¹æ¡ˆå¯¹æ¯”ä¸é€‰æ‹©

### ğŸ“Š ä¸‰ç§æ–¹æ¡ˆå¯¹æ¯”åˆ†æ

| è¯„ä¼°ç»´åº¦ | å®Œå…¨åˆ é™¤æ–¹æ¡ˆ | æ¨¡å—åŒ–åˆ é™¤æ–¹æ¡ˆ | åŠŸèƒ½è¿ç§»æ–¹æ¡ˆ | **æ¨èæ–¹æ¡ˆ** |
|---------|-------------|---------------|-------------|-------------|
| **æŠ€æœ¯å¤æ‚åº¦** | ğŸ”´ æé«˜ | ğŸŸ¡ é«˜ | ğŸŸ¢ ä¸­ç­‰ | **ğŸŸ¢ ä¸­ç­‰** |
| **ä¸šåŠ¡é£é™©** | ğŸ”´ æé«˜ | ğŸŸ¡ ä¸­ç­‰ | ğŸŸ¢ ä½ | **ğŸŸ¢ ä½** |
| **è¿ç§»æ—¶é—´** | 45-60å¤© | 30-45å¤© | 25-35å¤© | **25-35å¤©** |
| **ç”¨æˆ·å½±å“** | ğŸ”´ é‡å¤§ | ğŸŸ¡ ä¸­ç­‰ | ğŸŸ¢ è½»å¾® | **ğŸŸ¢ è½»å¾®** |
| **å›æ»šéš¾åº¦** | ğŸ”´ å›°éš¾ | ğŸŸ¡ ä¸­ç­‰ | ğŸŸ¢ ç®€å• | **ğŸŸ¢ ç®€å•** |
| **é•¿æœŸç»´æŠ¤** | ğŸŸ¡ éœ€è¦é‡æ„ | ğŸŸ¡ éƒ¨åˆ†é‡æ„ | ğŸŸ¢ æ¶æ„æ¸…æ™° | **ğŸŸ¢ æ¶æ„æ¸…æ™°** |

### ğŸ¯ é€‰æ‹©ç†ç”±

**é‡‡ç”¨ã€ŒåŠŸèƒ½è¿ç§»æ–¹æ¡ˆã€**ï¼ŒåŸºäºä»¥ä¸‹æ ¸å¿ƒè€ƒè™‘ï¼š

1. **ä¸šåŠ¡è¿ç»­æ€§**ï¼šä¿è¯15çº§åˆ†é”€ä½“ç³»æ­£å¸¸è¿è¡Œ
2. **ç”¨æˆ·ä½“éªŒ**ï¼šæœ€å°åŒ–ç”¨æˆ·æ„ŸçŸ¥çš„å˜åŒ–
3. **æŠ€æœ¯å¯è¡Œæ€§**ï¼šå¤ç”¨ç°æœ‰æ¶æ„ï¼Œé™ä½å¼€å‘é£é™©
4. **æŠ•èµ„ä¿æŠ¤**ï¼šä¿æŠ¤ç°æœ‰æ•°æ®å’Œç”¨æˆ·æŠ•å…¥

---

## æœ€ä¼˜æ¶æ„è®¾è®¡

### ğŸ—ï¸ æ–°æ¶æ„æ€»è§ˆ

```mermaid
graph TB
    subgraph "åˆ é™¤å‰æ¶æ„"
        A1[pallet-stardust-grave<br/>56ä¸ªå‡½æ•°, 32ä¸ªå­˜å‚¨]
        A2[pallet-deceased]
        A3[pallet-memorial]
        A4[pallet-offerings]
        A1 --> A2
        A1 --> A3
        A1 --> A4
    end

    subgraph "åˆ é™¤åæ¶æ„"
        B1[pallet-deceased<br/>+ å¢“ä½åŠŸèƒ½]
        B2[pallet-memorial-space<br/>+ è™šæ‹Ÿç©ºé—´]
        B3[pallet-offerings<br/>+ å¢å¼ºä¾›å¥‰]
        B4[pallet-social<br/>+ å…³æ³¨ç³»ç»Ÿ]

        B1 --> B3
        B2 --> B3
        B4 --> B2
    end

    style A1 fill:#ffcccc
    style B1 fill:#ccffcc
    style B2 fill:#ccffcc
    style B3 fill:#ccffcc
    style B4 fill:#ccffcc
```

### ğŸ“¦ åŠŸèƒ½é‡æ–°åˆ†é…

#### 1. **pallet-deceased (å¢å¼ºç‰ˆ)**
æ¥ç®¡æ ¸å¿ƒå¢“ä½ç®¡ç†åŠŸèƒ½

```rust
// pallets/deceased/src/lib.rs

/// å¢å¼ºåçš„é€è€…æ¡£æ¡ˆ - é›†æˆå¢“ä½åŠŸèƒ½
#[derive(Encode, Decode, Clone, PartialEq, Eq, TypeInfo)]
pub struct DeceasedProfileWithGrave<AccountId, BlockNumber> {
    // åŸæœ‰é€è€…ä¿¡æ¯
    pub deceased_id: u64,
    pub name: BoundedVec<u8, ConstU32<128>>,
    pub uploader: AccountId,
    pub privacy_level: u8,

    // ğŸ†• æ–°å¢å¢“ä½ä¿¡æ¯
    pub memorial_location: Option<MemorialLocation>,
    pub interment_records: BoundedVec<IntermentRecord<BlockNumber>, ConstU32<10>>,
    pub primary_memorial_type: u8, // 0=ä¼ ç»Ÿå¢“ä½, 1=è™šæ‹Ÿçºªå¿µ, 2=çºªå¿µç¢‘
    pub memorial_permissions: MemorialPermissions<AccountId>,
}

/// çºªå¿µä½ç½®ä¿¡æ¯
#[derive(Encode, Decode, Clone, PartialEq, Eq, TypeInfo)]
pub struct MemorialLocation {
    pub location_type: u8, // 0=ç‰©ç†å¢“ä½, 1=è™šæ‹Ÿç©ºé—´, 2=çºªå¿µå›­
    pub park_id: Option<u64>,
    pub coordinates: Option<(u32, u32)>, // å›­åŒºå†…åæ ‡
    pub address: Option<BoundedVec<u8, ConstU32<256>>>, // åœ°å€æè¿°
}

/// çºªå¿µæƒé™ç®¡ç†
#[derive(Encode, Decode, Clone, PartialEq, Eq, TypeInfo)]
pub struct MemorialPermissions<AccountId> {
    pub admins: BoundedVec<AccountId, ConstU32<5>>,
    pub admission_policy: u8, // 0=ç§å¯†, 1=å®¶äºº, 2=å…¬å¼€
    pub allow_offerings: bool,
}

/// å®‰è‘¬è®°å½•
#[derive(Encode, Decode, Clone, PartialEq, Eq, TypeInfo)]
pub struct IntermentRecord<BlockNumber> {
    pub interment_date: BlockNumber,
    pub location_note: Option<BoundedVec<u8, ConstU32<128>>>,
    pub ceremony_type: u8, // 0=åœŸè‘¬, 1=ç«åŒ–, 2=è™šæ‹Ÿ
    pub witness: Option<AccountId>,
}

// æ–°å¢å­˜å‚¨é¡¹
#[pallet::storage]
pub type MemorialSpaces<T: Config> = StorageMap<
    _, Blake2_128Concat, u64, MemorialSpace<T::AccountId, BlockNumberFor<T>>
>;

#[pallet::storage]
pub type MemorialsByPark<T: Config> = StorageMap<
    _, Blake2_128Concat, u64, BoundedVec<u64, T::MaxMemorialsPerPark>
>;
```

**è¿ç§»çš„åŠŸèƒ½**ï¼š
- âœ… åŸºç¡€å®‰è‘¬/èµ·æ˜ç®¡ç†
- âœ… æƒé™å’Œè®¿é—®æ§åˆ¶
- âœ… ä½ç½®ä¿¡æ¯ç®¡ç†
- âœ… åŸºç¡€å…ƒæ•°æ®

#### 2. **pallet-memorial-space (æ–°å»º)**
ä¸“é—¨å¤„ç†çºªå¿µç©ºé—´å±•ç¤ºåŠŸèƒ½

```rust
// pallets/memorial-space/src/lib.rs

/// è™šæ‹Ÿçºªå¿µç©ºé—´
#[derive(Encode, Decode, Clone, PartialEq, Eq, TypeInfo)]
pub struct VirtualMemorialSpace<AccountId, BlockNumber> {
    pub space_id: u64,
    pub deceased_id: u64,
    pub owner: AccountId,
    pub space_type: u8, // 0=ä¸ªäºº, 1=å®¶æ—, 2=ä¸»é¢˜, 3=å…¬å…±
    pub layout_config: SpaceLayout,
    pub media_assets: BoundedVec<MediaAsset, ConstU32<50>>,
    pub visitor_settings: VisitorSettings,
    pub created_at: BlockNumber,
    pub last_updated: BlockNumber,
}

/// ç©ºé—´å¸ƒå±€é…ç½®
#[derive(Encode, Decode, Clone, PartialEq, Eq, TypeInfo)]
pub struct SpaceLayout {
    pub theme: u8, // 0=ç»å…¸, 1=ç°ä»£, 2=èŠ±å›­, 3=è‡ªå®šä¹‰
    pub background: MediaReference,
    pub music: Option<MediaReference>,
    pub layout_elements: BoundedVec<LayoutElement, ConstU32<20>>,
}

/// åª’ä½“èµ„äº§å¼•ç”¨
#[derive(Encode, Decode, Clone, PartialEq, Eq, TypeInfo)]
pub struct MediaAsset {
    pub asset_id: u64,
    pub media_type: u8, // 0=å›¾ç‰‡, 1=è§†é¢‘, 2=éŸ³é¢‘, 3=æ–‡æ¡£
    pub ipfs_cid: BoundedVec<u8, ConstU32<64>>,
    pub caption: Option<BoundedVec<u8, ConstU32<256>>>,
    pub display_order: u16,
}

/// è®¿å®¢è®¾ç½®
#[derive(Encode, Decode, Clone, PartialEq, Eq, TypeInfo)]
pub struct VisitorSettings {
    pub allow_comments: bool,
    pub allow_offerings: bool,
    pub require_approval: bool,
    pub blacklist: BoundedVec<AccountId, ConstU32<100>>,
}

// æ ¸å¿ƒæ¥å£
impl<T: Config> Pallet<T> {
    /// åˆ›å»ºè™šæ‹Ÿçºªå¿µç©ºé—´
    #[pallet::call_index(0)]
    pub fn create_memorial_space(
        origin: OriginFor<T>,
        deceased_id: u64,
        space_config: SpaceConfig,
    ) -> DispatchResult {
        let who = ensure_signed(origin)?;

        // éªŒè¯å¯¹é€è€…çš„æƒé™
        ensure!(
            pallet_deceased::Pallet::<T>::can_manage_memorial(&who, deceased_id),
            Error::<T>::NoPermission
        );

        // åˆ›å»ºçºªå¿µç©ºé—´
        let space_id = Self::next_space_id();
        let space = VirtualMemorialSpace {
            space_id,
            deceased_id,
            owner: who.clone(),
            space_type: space_config.space_type,
            layout_config: space_config.layout,
            media_assets: BoundedVec::new(),
            visitor_settings: space_config.visitor_settings,
            created_at: <frame_system::Pallet<T>>::block_number(),
            last_updated: <frame_system::Pallet<T>>::block_number(),
        };

        VirtualMemorialSpaces::<T>::insert(space_id, &space);
        SpacesByDeceased::<T>::mutate(deceased_id, |spaces| {
            let _ = spaces.try_push(space_id);
        });

        Self::deposit_event(Event::MemorialSpaceCreated {
            space_id,
            deceased_id,
            owner: who,
        });

        Ok(())
    }

    /// æ›´æ–°çºªå¿µç©ºé—´
    #[pallet::call_index(1)]
    pub fn update_memorial_space(
        origin: OriginFor<T>,
        space_id: u64,
        updates: SpaceUpdates,
    ) -> DispatchResult {
        // å®ç°æ›´æ–°é€»è¾‘
        Ok(())
    }

    /// æ·»åŠ åª’ä½“èµ„äº§
    #[pallet::call_index(2)]
    pub fn add_media_asset(
        origin: OriginFor<T>,
        space_id: u64,
        media_asset: MediaAsset,
    ) -> DispatchResult {
        // å®ç°åª’ä½“æ·»åŠ é€»è¾‘
        Ok(())
    }
}
```

**è¿ç§»çš„åŠŸèƒ½**ï¼š
- âœ… å°é¢/éŸ³é¢‘ç®¡ç†
- âœ… è½®æ’­å›¾ç®¡ç†
- âœ… åª’ä½“èµ„äº§ç»„ç»‡
- âœ… ç©ºé—´å¸ƒå±€é…ç½®

#### 3. **pallet-social (æ–°å»º)**
å¤„ç†ç¤¾äº¤ç›¸å…³åŠŸèƒ½

```rust
// pallets/social/src/lib.rs

/// ç¤¾äº¤å…³æ³¨ç³»ç»Ÿ
#[derive(Encode, Decode, Clone, PartialEq, Eq, TypeInfo)]
pub struct FollowingRecord<AccountId, BlockNumber> {
    pub follower: AccountId,
    pub target_type: u8, // 0=é€è€…, 1=çºªå¿µç©ºé—´, 2=ç”¨æˆ·
    pub target_id: u64,
    pub follow_date: BlockNumber,
    pub relationship_type: u8, // 0=å…³æ³¨, 1=å®¶äºº, 2=æœ‹å‹
}

/// äº²å±å…³ç³»è®°å½•
#[derive(Encode, Decode, Clone, PartialEq, Eq, TypeInfo)]
pub struct KinshipRecord<AccountId> {
    pub deceased_id: u64,
    pub claimant: AccountId,
    pub kinship_type: u8, // 0=é…å¶, 1=å­å¥³, 2=çˆ¶æ¯, 3=å…„å¼Ÿå§å¦¹, 4=å…¶ä»–
    pub status: u8, // 0=å¾…å®¡æ ¸, 1=å·²æ‰¹å‡†, 2=å·²æ‹’ç»
    pub evidence_cid: Option<BoundedVec<u8, ConstU32<128>>>,
    pub verified_by: Option<AccountId>,
}

impl<T: Config> Pallet<T> {
    /// å…³æ³¨çºªå¿µå¯¹è±¡
    #[pallet::call_index(0)]
    pub fn follow_memorial(
        origin: OriginFor<T>,
        target_type: u8,
        target_id: u64,
        relationship_type: u8,
    ) -> DispatchResult {
        let who = ensure_signed(origin)?;

        // éªŒè¯ç›®æ ‡å­˜åœ¨
        match target_type {
            0 => ensure!(pallet_deceased::DeceasedProfiles::<T>::contains_key(target_id), Error::<T>::TargetNotFound),
            1 => ensure!(pallet_memorial_space::VirtualMemorialSpaces::<T>::contains_key(target_id), Error::<T>::TargetNotFound),
            _ => return Err(Error::<T>::InvalidTargetType.into()),
        }

        // åˆ›å»ºå…³æ³¨è®°å½•
        let record = FollowingRecord {
            follower: who.clone(),
            target_type,
            target_id,
            follow_date: <frame_system::Pallet<T>>::block_number(),
            relationship_type,
        };

        Following::<T>::insert((&who, target_type, target_id), record);
        Followers::<T>::mutate((target_type, target_id), |followers| {
            let _ = followers.try_push(who.clone());
        });

        Self::deposit_event(Event::MemorialFollowed {
            follower: who,
            target_type,
            target_id,
        });

        Ok(())
    }

    /// å£°æ˜äº²å±å…³ç³»
    #[pallet::call_index(1)]
    pub fn declare_kinship(
        origin: OriginFor<T>,
        deceased_id: u64,
        kinship_type: u8,
        evidence_cid: Option<BoundedVec<u8, ConstU32<128>>>,
    ) -> DispatchResult {
        let who = ensure_signed(origin)?;

        // éªŒè¯é€è€…å­˜åœ¨
        ensure!(
            pallet_deceased::DeceasedProfiles::<T>::contains_key(deceased_id),
            Error::<T>::DeceasedNotFound
        );

        let kinship = KinshipRecord {
            deceased_id,
            claimant: who.clone(),
            kinship_type,
            status: 0, // å¾…å®¡æ ¸
            evidence_cid,
            verified_by: None,
        };

        KinshipClaims::<T>::insert((deceased_id, &who), kinship);
        PendingKinshipClaims::<T>::mutate(deceased_id, |claims| {
            let _ = claims.try_push(who.clone());
        });

        Self::deposit_event(Event::KinshipDeclared {
            deceased_id,
            claimant: who,
            kinship_type,
        });

        Ok(())
    }
}
```

**è¿ç§»çš„åŠŸèƒ½**ï¼š
- âœ… å…³æ³¨/å–å…³ç³»ç»Ÿ
- âœ… äº²å±å…³ç³»ç®¡ç†
- âœ… ç¤¾äº¤ç½‘ç»œæ„å»º

#### 4. **pallet-offerings (å¢å¼ºç‰ˆ)**
å¢å¼ºä¾›å¥‰ç³»ç»Ÿï¼Œæ”¯æŒå¤šç§ç›®æ ‡

```rust
// åœ¨ pallet-offerings ä¸­å¢å¼º
impl<T: Config> Pallet<T> {
    /// å¢å¼ºçš„ä¾›å¥‰æ¥å£ - æ”¯æŒå¤šç§ç›®æ ‡
    #[pallet::call_index(10)]
    pub fn offer_to_target(
        origin: OriginFor<T>,
        target_type: u8, // 0=é€è€…æ¡£æ¡ˆ, 1=çºªå¿µç©ºé—´, 2=è™šæ‹Ÿå¢“ä½
        target_id: u64,
        offering_type: u8,
        quantity: u32,
        prayer: Option<BoundedVec<u8, ConstU32<512>>>,
    ) -> DispatchResult {
        let who = ensure_signed(origin)?;

        // éªŒè¯ç›®æ ‡å­˜åœ¨å¹¶è·å–å—ç›Šäºº
        let beneficiary = match target_type {
            0 => {
                // ç›´æ¥ä¾›å¥‰é€è€…
                let profile = pallet_deceased::DeceasedProfiles::<T>::get(target_id)
                    .ok_or(Error::<T>::TargetNotFound)?;
                profile.uploader
            },
            1 => {
                // ä¾›å¥‰çºªå¿µç©ºé—´
                let space = pallet_memorial_space::VirtualMemorialSpaces::<T>::get(target_id)
                    .ok_or(Error::<T>::TargetNotFound)?;
                space.owner
            },
            2 => {
                // ä¾›å¥‰è™šæ‹Ÿå¢“ä½ (é€šè¿‡deceasedæŸ¥æ‰¾)
                let memorial = pallet_deceased::MemorialSpaces::<T>::get(target_id)
                    .ok_or(Error::<T>::TargetNotFound)?;
                memorial.owner
            },
            _ => return Err(Error::<T>::InvalidTargetType.into()),
        };

        // è®¡ç®—ä»·æ ¼
        let total_price = Self::calculate_offering_price(offering_type, quantity)?;

        // åˆ›å»ºä¾›å¥‰è®¢å•
        let order_id = Self::next_order_id();
        let order = OfferingOrderV2 {
            order_id,
            devotee: who.clone(),
            target_type,
            target_id,
            offering_type,
            quantity,
            total_price,
            prayer,
            created_at: <frame_system::Pallet<T>>::block_number(),
            status: 0, // å¾…å¤„ç†
        };

        // æ‰§è¡Œ15çº§åˆ†é”€
        pallet_memo_affiliate::Pallet::<T>::report_commission(
            &who,                    // ä»˜è´¹ç”¨æˆ·
            &beneficiary,           // å—ç›Šäºº
            total_price,            // ä½£é‡‘åŸºæ•°
            pallet_memo_affiliate::ActivityType::MemorialOffering,
        )?;

        OfferingOrdersV2::<T>::insert(order_id, &order);
        OrdersByTarget::<T>::mutate((target_type, target_id), |orders| {
            let _ = orders.try_push(order_id);
        });

        Self::deposit_event(Event::OfferingToTargetPlaced {
            order_id,
            devotee: who,
            target_type,
            target_id,
            total_price,
        });

        Ok(())
    }

    /// å…¼å®¹æ€§æ¥å£ - æ”¯æŒæ—§çš„å¢“ä½ä¾›å¥‰è°ƒç”¨
    #[pallet::call_index(11)]
    #[deprecated]
    pub fn offer_to_grave_compat(
        origin: OriginFor<T>,
        grave_id: u64,
        offering_type: u8,
        quantity: u32,
    ) -> DispatchResult {
        // æŸ¥æ‰¾å¢“ä½å¯¹åº”çš„é€è€…
        let deceased_id = pallet_deceased::Pallet::<T>::resolve_grave_to_deceased(grave_id)
            .ok_or(Error::<T>::GraveNotFound)?;

        // é‡å®šå‘åˆ°æ–°æ¥å£
        Self::offer_to_target(origin, 0, deceased_id, offering_type, quantity, None)
    }
}
```

### ğŸ”„ å…¼å®¹æ€§ç­–ç•¥

#### 1. **æ¸è¿›å¼APIè¿ç§»**
```rust
// runtime/src/lib.rs

/// å¢“ä½åŠŸèƒ½å…¼å®¹æ€§é€‚é…å™¨
pub struct GraveCompatibilityAdapter;

impl GraveCompatibilityAdapter {
    /// å¢“ä½å­˜åœ¨æ£€æŸ¥ - é‡å®šå‘åˆ°é€è€…æ£€æŸ¥
    pub fn grave_exists(grave_id: u64) -> bool {
        // å°è¯•é€šè¿‡æ˜ å°„æ‰¾åˆ°å¯¹åº”çš„é€è€…
        if let Some(deceased_id) = GraveToDeceasedMapping::get(grave_id) {
            pallet_deceased::DeceasedProfiles::<Runtime>::contains_key(deceased_id)
        } else {
            false
        }
    }

    /// å¢“ä½æƒé™æ£€æŸ¥ - é‡å®šå‘åˆ°çºªå¿µæƒé™æ£€æŸ¥
    pub fn can_attach(who: &AccountId, grave_id: u64) -> bool {
        if let Some(deceased_id) = GraveToDeceasedMapping::get(grave_id) {
            pallet_deceased::Pallet::<Runtime>::can_manage_memorial(who, deceased_id)
        } else {
            false
        }
    }

    /// è·å–å¢“ä½æ‰€æœ‰è€… - é‡å®šå‘åˆ°é€è€…ä¸Šä¼ è€…
    pub fn owner_of(grave_id: u64) -> Option<AccountId> {
        if let Some(deceased_id) = GraveToDeceasedMapping::get(grave_id) {
            pallet_deceased::DeceasedProfiles::<Runtime>::get(deceased_id)
                .map(|profile| profile.uploader)
        } else {
            None
        }
    }
}

/// ä¸ºæ—§æ¥å£å®ç°GraveInspector trait
impl GraveInspector<AccountId, u64> for GraveCompatibilityAdapter {
    fn grave_exists(grave_id: u64) -> bool {
        Self::grave_exists(grave_id)
    }

    fn can_attach(who: &AccountId, grave_id: u64) -> bool {
        Self::can_attach(who, grave_id)
    }

    fn owner_of(grave_id: u64) -> Option<AccountId> {
        Self::owner_of(grave_id)
    }

    fn record_interment(
        grave_id: u64,
        deceased_id: u64,
        slot: Option<u16>,
        note_cid: Option<BoundedVec<u8, ConstU32<128>>>,
    ) -> DispatchResult {
        // é‡å®šå‘åˆ°deceased palletçš„å®‰è‘¬è®°å½•
        pallet_deceased::Pallet::<Runtime>::record_interment_internal(
            deceased_id,
            IntermentRecord {
                interment_date: <frame_system::Pallet<Runtime>>::block_number(),
                location_note: note_cid,
                ceremony_type: 0, // é»˜è®¤ç±»å‹
                witness: None,
            }
        )
    }

    fn record_exhumation(grave_id: u64, deceased_id: u64) -> DispatchResult {
        // é‡å®šå‘åˆ°deceased palletçš„èµ·æ˜è®°å½•
        pallet_deceased::Pallet::<Runtime>::record_exhumation_internal(deceased_id)
    }

    fn check_admission_policy(who: &AccountId, grave_id: u64) -> DispatchResult {
        if let Some(deceased_id) = GraveToDeceasedMapping::get(grave_id) {
            pallet_deceased::Pallet::<Runtime>::check_memorial_access(who, deceased_id)
        } else {
            Err(DispatchError::from("Grave not found"))
        }
    }
}
```

#### 2. **å‰ç«¯å…¼å®¹æ€§å±‚**
```typescript
// stardust-dapp/src/services/graveCompatibilityService.ts

/**
 * å¢“ä½åŠŸèƒ½å…¼å®¹æ€§æœåŠ¡
 * ç¡®ä¿ç°æœ‰å‰ç«¯ä»£ç å¹³æ»‘è¿ç§»
 */
export class GraveCompatibilityService {
    private migrationCache = new Map<number, number>();

    /**
     * å¢“ä½è¯¦æƒ…æŸ¥è¯¢ - å…¼å®¹æ—§æ¥å£
     */
    async getGraveDetails(graveId: number): Promise<LegacyGraveInfo | null> {
        try {
            // æŸ¥æ‰¾æ˜ å°„çš„é€è€…ID
            const deceasedId = await this.resolveGraveToDeceased(graveId);
            if (!deceasedId) return null;

            // è·å–å¢å¼ºçš„é€è€…æ¡£æ¡ˆ
            const profile = await api.query.deceased.deceasedProfiles(deceasedId);
            if (!profile.isSome) return null;

            const profileData = profile.unwrap().toJSON();

            // æ„é€ å…¼å®¹çš„å¢“ä½ä¿¡æ¯
            return {
                grave_id: graveId,
                name: `${profileData.name}çºªå¿µæ¡£æ¡ˆ`,
                owner: profileData.uploader,
                is_public: profileData.privacy_level === 0,
                park_id: profileData.memorial_location?.park_id || null,
                primary_deceased: deceasedId,
                created_at: profileData.created_at,

                // æ–°å¢è¿ç§»æ ‡è¯†
                _migrated: true,
                _original_deceased_id: deceasedId,
                _migration_type: 'deceased_integrated',
            };
        } catch (error) {
            console.error(`Failed to get grave ${graveId}:`, error);
            return null;
        }
    }

    /**
     * ä¾›å¥‰å¢“ä½ - å…¼å®¹æ—§æ¥å£
     */
    async offerToGrave(
        graveId: number,
        offeringType: number,
        quantity: number
    ): Promise<boolean> {
        try {
            // è§£æä¸ºé€è€…ID
            const deceasedId = await this.resolveGraveToDeceased(graveId);
            if (!deceasedId) {
                throw new Error(`å¢“ä½ ${graveId} ä¸å­˜åœ¨æˆ–å·²è¿ç§»`);
            }

            // è°ƒç”¨æ–°çš„ä¾›å¥‰æ¥å£
            const result = await api.tx.offerings
                .offerToTarget(
                    0, // target_type: é€è€…æ¡£æ¡ˆ
                    deceasedId,
                    offeringType,
                    quantity,
                    null // æ— ç¥ˆæ„¿å†…å®¹
                )
                .signAndSend(currentAccount);

            // æ˜¾ç¤ºè¿ç§»æç¤º
            this.showMigrationNotice(graveId, deceasedId);

            return result.isInBlock || result.isFinalized;
        } catch (error) {
            console.error(`Failed to offer to grave ${graveId}:`, error);
            throw error;
        }
    }

    /**
     * å¢“ä½IDåˆ°é€è€…IDçš„è§£æ
     */
    private async resolveGraveToDeceased(graveId: number): Promise<number | null> {
        // æ£€æŸ¥ç¼“å­˜
        if (this.migrationCache.has(graveId)) {
            return this.migrationCache.get(graveId)!;
        }

        try {
            // æŸ¥è¯¢æ˜ å°„è¡¨
            const mapping = await api.query.deceased.graveToDeceasedMapping(graveId);
            if (mapping.isSome) {
                const deceasedId = mapping.unwrap().toNumber();
                this.migrationCache.set(graveId, deceasedId);
                return deceasedId;
            }

            return null;
        } catch (error) {
            console.warn(`Failed to resolve grave ${graveId}:`, error);
            return null;
        }
    }

    /**
     * æ˜¾ç¤ºè¿ç§»æç¤º
     */
    private showMigrationNotice(graveId: number, deceasedId: number) {
        notification.info({
            message: 'åŠŸèƒ½å‡çº§æé†’',
            description: `å¢“ä½åŠŸèƒ½å·²å‡çº§ï¼Œç°åœ¨æ‚¨å¯ä»¥äº«å—æ›´ä¸°å¯Œçš„çºªå¿µä½“éªŒã€‚`,
            duration: 0,
            btn: (
                <Button
                    size="small"
                    type="primary"
                    onClick={() => {
                        window.location.href = `/deceased/${deceasedId}`;
                        notification.destroy();
                    }}
                >
                    æŸ¥çœ‹æ–°åŠŸèƒ½
                </Button>
            ),
            key: `grave-migration-${graveId}`,
            placement: 'topRight',
        });
    }
}
```

---

## åˆ†é˜¶æ®µå®æ–½è®¡åˆ’

### ğŸ“… æ€»æ—¶é—´çº¿ï¼š28å¤© (4å‘¨)

#### **Week 1: å‡†å¤‡ä¸æ¶æ„å¼€å‘ (7å¤©)**

**Day 1-2: ç¯å¢ƒå‡†å¤‡**
```bash
# åˆ›å»ºå·¥ä½œåˆ†æ”¯
git checkout -b feature/grave-migration-v2
git checkout -b backup/grave-original

# å¤‡ä»½å…³é”®æ•°æ®
./scripts/backup/full-system-backup.sh

# åˆ›å»ºæ–°palletæ¡†æ¶
cargo generate --path templates/pallet --name memorial-space
cargo generate --path templates/pallet --name social
```

**Day 3-5: æ ¸å¿ƒPalletå¼€å‘**
- [ ] å¼€å‘ `pallet-memorial-space` (2å¤©)
- [ ] å¼€å‘ `pallet-social` (1å¤©)
- [ ] æ‰©å±• `pallet-deceased` (1å¤©)

**Day 6-7: Runtimeé›†æˆæµ‹è¯•**
```bash
# ç¼–è¯‘éªŒè¯
cargo check --workspace
cargo test --workspace --features migration-tests

# åŸºç¡€åŠŸèƒ½éªŒè¯
node scripts/test-new-pallets.js
```

#### **Week 2: æ•°æ®è¿ç§»å¼€å‘ (7å¤©)**

**Day 8-10: è¿ç§»è„šæœ¬å¼€å‘**
```rust
// runtime/src/migrations/grave_to_deceased_v1.rs

pub mod grave_to_deceased_v1 {
    use super::*;

    /// ä¸»è¿ç§»å‡½æ•°
    pub fn migrate<T: Config>() -> Weight {
        log::info!("ğŸ”„ Starting grave-to-deceased migration...");

        let mut total_weight = Weight::zero();

        // Step 1: æ„å»ºæ˜ å°„è¡¨
        total_weight = total_weight.saturating_add(build_grave_deceased_mapping::<T>());

        // Step 2: è¿ç§»æ ¸å¿ƒæ•°æ®
        total_weight = total_weight.saturating_add(migrate_grave_data::<T>());

        // Step 3: è¿ç§»å®‰è‘¬è®°å½•
        total_weight = total_weight.saturating_add(migrate_interments::<T>());

        // Step 4: è¿ç§»æƒé™æ•°æ®
        total_weight = total_weight.saturating_add(migrate_permissions::<T>());

        // Step 5: åˆ›å»ºè™šæ‹Ÿçºªå¿µç©ºé—´
        total_weight = total_weight.saturating_add(create_memorial_spaces::<T>());

        // Step 6: æ¸…ç†æ—§æ•°æ®
        total_weight = total_weight.saturating_add(cleanup_grave_storage::<T>());

        log::info!("âœ… Migration completed successfully");
        total_weight
    }

    /// æ„å»ºå¢“ä½åˆ°é€è€…çš„æ˜ å°„å…³ç³»
    fn build_grave_deceased_mapping<T: Config>() -> Weight {
        let mut migrated = 0u64;
        let mut failed = 0u64;

        // éå†æ‰€æœ‰å¢“ä½ï¼Œå»ºç«‹ä¸ä¸»é€è€…çš„æ˜ å°„
        for (grave_id, grave) in pallet_stardust_grave::Graves::<T>::iter() {
            if let Some(primary_deceased) = pallet_stardust_grave::PrimaryDeceasedOf::<T>::get(grave_id) {
                // åˆ›å»ºæ˜ å°„è®°å½•
                pallet_deceased::GraveToDeceasedMapping::<T>::insert(grave_id, primary_deceased);

                // å°†å¢“ä½ä¿¡æ¯è¿ç§»åˆ°é€è€…æ¡£æ¡ˆ
                if let Some(mut profile) = pallet_deceased::DeceasedProfiles::<T>::get(primary_deceased) {
                    profile.memorial_location = Some(MemorialLocation {
                        location_type: 0, // ç‰©ç†å¢“ä½
                        park_id: grave.park_id,
                        coordinates: grave.coordinates,
                        address: grave.address.clone(),
                    });

                    profile.memorial_permissions = MemorialPermissions {
                        admins: pallet_stardust_grave::GraveAdmins::<T>::get(grave_id).into(),
                        admission_policy: match pallet_stardust_grave::AdmissionPolicyOf::<T>::get(grave_id) {
                            Some(policy) => match policy {
                                pallet_stardust_grave::GraveAdmissionPolicy::OwnerOnly => 0,
                                pallet_stardust_grave::GraveAdmissionPolicy::Public => 2,
                                pallet_stardust_grave::GraveAdmissionPolicy::Whitelist => 1,
                            },
                            None => 0,
                        },
                        allow_offerings: true,
                    };

                    pallet_deceased::DeceasedProfiles::<T>::insert(primary_deceased, profile);
                    migrated += 1;
                } else {
                    log::warn!("âš ï¸ Grave {} has primary deceased {} but profile not found", grave_id, primary_deceased);
                    failed += 1;
                }
            } else {
                log::warn!("âš ï¸ Grave {} has no primary deceased", grave_id);
                failed += 1;
            }
        }

        log::info!("ğŸ“Š Mapping migration: {} succeeded, {} failed", migrated, failed);
        T::DbWeight::get().reads_writes(migrated + failed, migrated)
    }

    /// è¿ç§»å®‰è‘¬è®°å½•
    fn migrate_interments<T: Config>() -> Weight {
        let mut migrated = 0u64;

        for (grave_id, interment_records) in pallet_stardust_grave::Interments::<T>::iter() {
            if let Some(deceased_id) = pallet_deceased::GraveToDeceasedMapping::<T>::get(grave_id) {
                // è½¬æ¢å®‰è‘¬è®°å½•æ ¼å¼
                let new_records: BoundedVec<IntermentRecord<_>, _> = interment_records
                    .into_iter()
                    .map(|old_record| IntermentRecord {
                        interment_date: old_record.interment_date,
                        location_note: old_record.note,
                        ceremony_type: 0, // é»˜è®¤ç±»å‹
                        witness: old_record.witness,
                    })
                    .collect::<Vec<_>>()
                    .try_into()
                    .unwrap_or_default();

                // æ›´æ–°é€è€…æ¡£æ¡ˆä¸­çš„å®‰è‘¬è®°å½•
                pallet_deceased::DeceasedProfiles::<T>::mutate(deceased_id, |profile_opt| {
                    if let Some(ref mut profile) = profile_opt {
                        profile.interment_records = new_records;
                    }
                });

                migrated += 1;
            }
        }

        log::info!("ğŸ“Š Interment migration: {} records migrated", migrated);
        T::DbWeight::get().reads_writes(migrated, migrated)
    }

    /// åˆ›å»ºè™šæ‹Ÿçºªå¿µç©ºé—´
    fn create_memorial_spaces<T: Config>() -> Weight {
        let mut created = 0u64;

        for (grave_id, grave) in pallet_stardust_grave::Graves::<T>::iter() {
            if let Some(primary_deceased) = pallet_deceased::GraveToDeceasedMapping::<T>::get(grave_id) {
                // ä¸ºæ¯ä¸ªå¢“ä½åˆ›å»ºå¯¹åº”çš„è™šæ‹Ÿçºªå¿µç©ºé—´
                let space_id = pallet_memorial_space::NextSpaceId::<T>::mutate(|id| {
                    let current = *id;
                    *id = id.saturating_add(1);
                    current
                });

                let space = VirtualMemorialSpace {
                    space_id,
                    deceased_id: primary_deceased,
                    owner: grave.owner.clone(),
                    space_type: if grave.is_public { 3 } else { 0 }, // å…¬å…± vs ä¸ªäºº
                    layout_config: SpaceLayout {
                        theme: 0, // ç»å…¸ä¸»é¢˜
                        background: MediaReference::from_cid(
                            pallet_stardust_grave::CoverOf::<T>::get(grave_id)
                                .unwrap_or_default()
                        ),
                        music: pallet_stardust_grave::AudioOf::<T>::get(grave_id)
                            .map(MediaReference::from_cid),
                        layout_elements: BoundedVec::new(),
                    },
                    media_assets: BoundedVec::new(), // å°†åœ¨åç»­æ­¥éª¤ä¸­è¿ç§»
                    visitor_settings: VisitorSettings {
                        allow_comments: true,
                        allow_offerings: true,
                        require_approval: !grave.is_public,
                        blacklist: BoundedVec::new(),
                    },
                    created_at: grave.created_at,
                    last_updated: <frame_system::Pallet<T>>::block_number(),
                };

                pallet_memorial_space::VirtualMemorialSpaces::<T>::insert(space_id, space);
                pallet_memorial_space::SpacesByDeceased::<T>::mutate(primary_deceased, |spaces| {
                    let _ = spaces.try_push(space_id);
                });

                created += 1;
            }
        }

        log::info!("ğŸ“Š Memorial space creation: {} spaces created", created);
        T::DbWeight::get().reads_writes(created * 3, created * 3)
    }

    /// æ¸…ç†å¢“ä½å­˜å‚¨
    fn cleanup_grave_storage<T: Config>() -> Weight {
        let mut cleaned_items = 0u64;

        // æ¸…ç†ä¸»å­˜å‚¨é¡¹
        let graves_removed = pallet_stardust_grave::Graves::<T>::clear_prefix(1000, None).unique;
        cleaned_items += graves_removed as u64;

        let interments_removed = pallet_stardust_grave::Interments::<T>::clear_prefix(1000, None).unique;
        cleaned_items += interments_removed as u64;

        let admins_removed = pallet_stardust_grave::GraveAdmins::<T>::clear_prefix(1000, None).unique;
        cleaned_items += admins_removed as u64;

        // ... æ¸…ç†å…¶ä»–å­˜å‚¨é¡¹

        log::info!("ğŸ§¹ Storage cleanup: {} items removed", cleaned_items);
        T::DbWeight::get().writes(cleaned_items)
    }
}
```

**Day 11-14: å‰ç«¯è¿ç§»å¼€å‘**
- [ ] å¼€å‘å…¼å®¹æ€§é€‚é…å™¨ (2å¤©)
- [ ] é‡æ„æ ¸å¿ƒç»„ä»¶ (2å¤©)
- [ ] æ›´æ–°è·¯ç”±å’Œå¯¼èˆª (1å¤©)

#### **Week 3: é›†æˆæµ‹è¯• (7å¤©)**

**Day 15-17: åŠŸèƒ½æµ‹è¯•**
```bash
# å•å…ƒæµ‹è¯•
cargo test -p pallet-deceased --features migration-tests
cargo test -p pallet-memorial-space
cargo test -p pallet-social

# é›†æˆæµ‹è¯•
cargo test --workspace --features integration-tests
```

**Day 18-19: æ•°æ®è¿ç§»æµ‹è¯•**
```bash
# åˆ›å»ºæµ‹è¯•æ•°æ®
node scripts/migration-test/create-test-graves.js

# æ‰§è¡Œè¿ç§»
cargo run --features runtime-benchmarks -- benchmark-migration

# éªŒè¯è¿ç§»ç»“æœ
node scripts/migration-test/verify-migration.js
```

**Day 20-21: å‰ç«¯é›†æˆæµ‹è¯•**
```bash
cd stardust-dapp

# E2Eæµ‹è¯•
npm run test:e2e:migration
npm run test:compatibility

# æ€§èƒ½æµ‹è¯•
npm run lighthouse:migration
```

#### **Week 4: éƒ¨ç½²ä¸ä¼˜åŒ– (7å¤©)**

**Day 22-24: é¢„ç”Ÿäº§éƒ¨ç½²**
```bash
# æ„å»ºç”Ÿäº§ç‰ˆæœ¬
cargo build --release --features migration

# éƒ¨ç½²åˆ°stagingç¯å¢ƒ
./deploy.sh --env staging --with-migration

# ç”¨æˆ·éªŒæ”¶æµ‹è¯•
./scripts/uat/run-migration-uat.sh
```

**Day 25-27: ç”Ÿäº§éƒ¨ç½²**
```bash
# ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²å‰æ£€æŸ¥
./scripts/pre-deployment-check.sh

# æ‰§è¡Œè¿ç§»éƒ¨ç½²
./deploy.sh --env production --with-migration --backup-first

# ç›‘æ§ç³»ç»ŸçŠ¶æ€
./scripts/monitor-migration-deployment.sh
```

**Day 28: æ¸…ç†ä¸æ€»ç»“**
```bash
# æ¸…ç†ä¸´æ—¶æ–‡ä»¶
./scripts/cleanup-migration-artifacts.sh

# æ€§èƒ½åŸºå‡†æµ‹è¯•
cargo bench --package pallet-deceased
cargo bench --package pallet-memorial-space

# ç”ŸæˆæŠ¥å‘Š
./scripts/generate-migration-report.sh
```

---

## ä¸šåŠ¡é€»è¾‘é‡æ„

### ğŸ”„ 15çº§åˆ†é”€ä½“ç³»é€‚é…

```typescript
// stardust-dapp/src/services/affiliateService.ts

export class AffiliateServiceV2 {
    /**
     * é€‚é…ä¾›å¥‰åˆ†é”€è®¡ç®—
     * æ”¯æŒå¤šç§ç›®æ ‡ç±»å‹çš„åˆ†é”€
     */
    async calculateCommission(
        offeringData: {
            targetType: number; // 0=é€è€…, 1=çºªå¿µç©ºé—´, 2=è™šæ‹Ÿå¢“ä½
            targetId: number;
            totalAmount: number;
        }
    ): Promise<CommissionCalculation> {
        // æ ¹æ®ç›®æ ‡ç±»å‹æ‰¾åˆ°å—ç›Šäºº
        const beneficiary = await this.resolveBeneficiary(offeringData.targetType, offeringData.targetId);

        // æ‰§è¡Œ15çº§åˆ†é”€è®¡ç®—
        const commissionChain = await this.buildCommissionChain(beneficiary);

        // æŒ‰æ–°çš„åˆ†é…è§„åˆ™è®¡ç®—
        return this.calculateCommissionDistribution(offeringData.totalAmount, commissionChain);
    }

    /**
     * è§£æå—ç›Šäººè´¦æˆ·
     */
    private async resolveBeneficiary(targetType: number, targetId: number): Promise<string> {
        switch (targetType) {
            case 0: // é€è€…æ¡£æ¡ˆ
                const deceased = await api.query.deceased.deceasedProfiles(targetId);
                if (deceased.isSome) {
                    return deceased.unwrap().uploader.toString();
                }
                break;

            case 1: // çºªå¿µç©ºé—´
                const space = await api.query.memorialSpace.virtualMemorialSpaces(targetId);
                if (space.isSome) {
                    return space.unwrap().owner.toString();
                }
                break;

            case 2: // è™šæ‹Ÿå¢“ä½
                const memorial = await api.query.deceased.memorialSpaces(targetId);
                if (memorial.isSome) {
                    return memorial.unwrap().owner.toString();
                }
                break;

            default:
                throw new Error(`ä¸æ”¯æŒçš„ç›®æ ‡ç±»å‹: ${targetType}`);
        }

        throw new Error(`æ‰¾ä¸åˆ°ç›®æ ‡ ${targetType}:${targetId} çš„å—ç›Šäºº`);
    }

    /**
     * æ„å»ºä½£é‡‘é“¾æ¡
     */
    private async buildCommissionChain(beneficiary: string): Promise<CommissionNode[]> {
        const chain: CommissionNode[] = [];
        let currentUser = beneficiary;

        // å‘ä¸ŠæŸ¥æ‰¾15çº§æ¨èå…³ç³»
        for (let level = 1; level <= 15; level++) {
            const sponsor = await api.query.affiliate.sponsorOf(currentUser);
            if (!sponsor.isSome) break;

            const sponsorAccount = sponsor.unwrap().toString();

            // éªŒè¯èµ„æ ¼ï¼ˆéœ€è¦æœ‰è¶³å¤Ÿçš„ç›´æ¨æ•°é‡ï¼‰
            const qualifies = await this.checkLevelQualification(sponsorAccount, level);

            if (qualifies) {
                chain.push({
                    account: sponsorAccount,
                    level,
                    commissionRate: 0.05, // æ¯çº§5%
                });
            }

            currentUser = sponsorAccount;
        }

        return chain;
    }

    /**
     * è®¡ç®—ä½£é‡‘åˆ†é…
     */
    private calculateCommissionDistribution(
        totalAmount: number,
        commissionChain: CommissionNode[]
    ): CommissionCalculation {
        const distribution: CommissionAllocation[] = [];
        let totalCommission = 0;

        // åˆ†é…ç»™æ¨èäºº
        for (const node of commissionChain) {
            const commission = totalAmount * node.commissionRate;
            distribution.push({
                recipient: node.account,
                level: node.level,
                amount: commission,
                type: 'affiliate',
            });
            totalCommission += commission;
        }

        // å‰©ä½™éƒ¨åˆ†æŒ‰è§„åˆ™åˆ†é…
        const remaining = totalAmount - totalCommission;
        const burned = remaining * 0.1; // 10%é”€æ¯
        const treasury = remaining * 0.15; // 15%è¿›å…¥å›½åº“
        const settlement = remaining - burned - treasury; // å…¶ä½™è¿›å…¥ç»“ç®—æ± 

        distribution.push(
            { recipient: 'burn', amount: burned, type: 'burn' },
            { recipient: 'treasury', amount: treasury, type: 'treasury' },
            { recipient: 'settlement', amount: settlement, type: 'settlement' }
        );

        return {
            totalAmount,
            totalCommission,
            distribution,
            levels: commissionChain.length,
        };
    }
}
```

### ğŸ¯ ç”¨æˆ·ä½“éªŒä¼˜åŒ–

```typescript
// stardust-dapp/src/features/migration/MigrationGuide.tsx

const MigrationGuideModal: React.FC = () => {
    const [currentStep, setCurrentStep] = useState(0);
    const [userGraves, setUserGraves] = useState<LegacyGrave[]>([]);

    useEffect(() => {
        loadUserGraves();
    }, []);

    const loadUserGraves = async () => {
        try {
            // æŸ¥æ‰¾ç”¨æˆ·çš„æ—§å¢“ä½
            const graves = await compatService.getUserGraves(currentAccount?.address);
            setUserGraves(graves);
        } catch (error) {
            console.error('Failed to load user graves:', error);
        }
    };

    const migrationSteps = [
        {
            title: "æ¬¢è¿ä½¿ç”¨ Stardust 2.0",
            content: (
                <div className="migration-welcome">
                    <div className="upgrade-icon">ğŸŒŸ</div>
                    <h2>ç³»ç»ŸåŠŸèƒ½é‡å¤§å‡çº§</h2>
                    <p>æˆ‘ä»¬å°†å¢“ä½åŠŸèƒ½å‡çº§ä¸ºæ›´ä¸°å¯Œçš„çºªå¿µæ¡£æ¡ˆç³»ç»Ÿï¼Œä¸ºæ‚¨æä¾›ï¼š</p>
                    <ul>
                        <li>ğŸ›ï¸ æ›´ä¸°å¯Œçš„çºªå¿µç©ºé—´å±•ç¤º</li>
                        <li>ğŸ’« å¤šæ ·åŒ–çš„äº’åŠ¨ä½“éªŒ</li>
                        <li>ğŸ“± æ›´æµç•…çš„ç§»åŠ¨ç«¯æ“ä½œ</li>
                        <li>ğŸ”— æ›´å¼ºå¤§çš„ç¤¾äº¤åŠŸèƒ½</li>
                    </ul>
                </div>
            )
        },
        {
            title: "æ‚¨çš„æ•°æ®å®Œå…¨å®‰å…¨",
            content: (
                <div className="data-safety">
                    <div className="safety-icon">ğŸ›¡ï¸</div>
                    <h2>æ•°æ®è¿ç§»å®Œæˆ</h2>
                    {userGraves.length > 0 ? (
                        <div>
                            <p>æ‚¨çš„ {userGraves.length} ä¸ªå¢“ä½å·²æˆåŠŸè¿ç§»ä¸ºçºªå¿µæ¡£æ¡ˆï¼š</p>
                            <div className="graves-list">
                                {userGraves.map(grave => (
                                    <div key={grave.grave_id} className="grave-item">
                                        <span className="grave-name">{grave.name}</span>
                                        <Button
                                            type="link"
                                            size="small"
                                            onClick={() => window.open(`/deceased/${grave._original_deceased_id}`)}
                                        >
                                            æŸ¥çœ‹çºªå¿µæ¡£æ¡ˆ â†’
                                        </Button>
                                    </div>
                                ))}
                            </div>
                        </div>
                    ) : (
                        <p>ç³»ç»Ÿå·²ä¸ºæ‚¨ä¿ç•™æ‰€æœ‰å†å²æ•°æ®å’Œå…³è”å…³ç³»ã€‚</p>
                    )}
                </div>
            )
        },
        {
            title: "å…¨æ–°åŠŸèƒ½ä½“éªŒ",
            content: (
                <div className="new-features">
                    <h2>æ¢ç´¢æ–°åŠŸèƒ½</h2>
                    <div className="feature-grid">
                        <div className="feature-card">
                            <div className="feature-icon">ğŸ›ï¸</div>
                            <h3>çºªå¿µç©ºé—´</h3>
                            <p>åˆ›å»ºä¸ªæ€§åŒ–çš„è™šæ‹Ÿçºªå¿µç©ºé—´ï¼Œæ”¯æŒè‡ªå®šä¹‰å¸ƒå±€å’Œä¸»é¢˜</p>
                        </div>
                        <div className="feature-card">
                            <div className="feature-icon">ğŸ“¸</div>
                            <h3>åª’ä½“ç®¡ç†</h3>
                            <p>è½»æ¾ç®¡ç†ç…§ç‰‡ã€è§†é¢‘ã€éŸ³é¢‘ç­‰çºªå¿µå†…å®¹</p>
                        </div>
                        <div className="feature-card">
                            <div className="feature-icon">ğŸ‘¥</div>
                            <h3>ç¤¾äº¤äº’åŠ¨</h3>
                            <p>ä¸å®¶äººæœ‹å‹åˆ†äº«çºªå¿µå†…å®¹ï¼Œå»ºç«‹çºªå¿µç¤¾åŒº</p>
                        </div>
                        <div className="feature-card">
                            <div className="feature-icon">ğŸ’</div>
                            <h3>ä¾›å¥‰ä½“éªŒ</h3>
                            <p>æ›´çµæ´»çš„ä¾›å¥‰æ–¹å¼ï¼Œæ”¯æŒå¤šç§è¡¨è¾¾å½¢å¼</p>
                        </div>
                    </div>
                </div>
            )
        }
    ];

    return (
        <Modal
            title={null}
            open={true}
            footer={null}
            closable={false}
            className="migration-guide-modal"
            width={600}
        >
            <div className="migration-content">
                <div className="progress-bar">
                    <div
                        className="progress-fill"
                        style={{ width: `${((currentStep + 1) / migrationSteps.length) * 100}%` }}
                    />
                </div>

                <div className="step-content">
                    {migrationSteps[currentStep].content}
                </div>

                <div className="migration-actions">
                    {currentStep > 0 && (
                        <Button
                            type="default"
                            onClick={() => setCurrentStep(currentStep - 1)}
                        >
                            ä¸Šä¸€æ­¥
                        </Button>
                    )}

                    {currentStep < migrationSteps.length - 1 ? (
                        <Button
                            type="primary"
                            onClick={() => setCurrentStep(currentStep + 1)}
                        >
                            ä¸‹ä¸€æ­¥
                        </Button>
                    ) : (
                        <Button
                            type="primary"
                            onClick={() => {
                                localStorage.setItem('migration-guide-completed', 'true');
                                // å…³é—­å¼•å¯¼ï¼Œå¼€å§‹ä½¿ç”¨
                            }}
                        >
                            å¼€å§‹ä½¿ç”¨ ğŸš€
                        </Button>
                    )}
                </div>

                <div className="step-indicator">
                    {migrationSteps.map((_, index) => (
                        <div
                            key={index}
                            className={`step-dot ${index === currentStep ? 'active' : ''} ${index < currentStep ? 'completed' : ''}`}
                        />
                    ))}
                </div>
            </div>
        </Modal>
    );
};
```

---

## æ•°æ®è¿ç§»ç­–ç•¥

### ğŸ“Š æ•°æ®å®‰å…¨ä¿æŠ¤

```bash
#!/bin/bash
# scripts/migration/comprehensive-backup.sh

echo "ğŸ”„ Starting comprehensive system backup..."

# 1. æ•°æ®åº“å…¨é‡å¤‡ä»½
echo "ğŸ“¦ Database backup..."
pg_dump stardust_production > backups/pre-grave-migration-$(date +%Y%m%d_%H%M%S).sql

# 2. é“¾çŠ¶æ€å¤‡ä»½
echo "ğŸ’¾ Chain state backup..."
mkdir -p backups/chain-state
./target/release/stardust-node export-state --output backups/chain-state/state-$(date +%Y%m%d).json

# 3. å…³é”®ä¸šåŠ¡æ•°æ®å¯¼å‡º
echo "ğŸ“‹ Business data export..."
node scripts/migration/export-business-data.js

# 4. ç”¨æˆ·å…³ç³»æ•°æ®å¤‡ä»½
echo "ğŸ‘¥ User relationships backup..."
node scripts/migration/export-user-relationships.js

# 5. åˆ†é”€å…³ç³»å¤‡ä»½
echo "ğŸ’° Affiliate relationships backup..."
node scripts/migration/export-affiliate-chains.js

echo "âœ… Backup completed successfully"
```

### ğŸ” æ•°æ®ä¸€è‡´æ€§éªŒè¯

```javascript
// scripts/migration/validate-migration.js

const MigrationValidator = {
    /**
     * éªŒè¯æ•°æ®è¿ç§»å®Œæ•´æ€§
     */
    async validateMigration() {
        console.log('ğŸ” Starting migration validation...');

        const results = {
            graves: await this.validateGraveMigration(),
            offerings: await this.validateOfferingMigration(),
            affiliates: await this.validateAffiliateMigration(),
            social: await this.validateSocialMigration(),
        };

        // ç”ŸæˆéªŒè¯æŠ¥å‘Š
        this.generateValidationReport(results);

        return results;
    },

    /**
     * éªŒè¯å¢“ä½è¿ç§»
     */
    async validateGraveMigration() {
        const graveCount = await this.getBackupGraveCount();
        const deceasedCount = await api.query.deceased.deceasedProfiles.entries();
        const mappingCount = await api.query.deceased.graveToDeceasedMapping.entries();

        const results = {
            original_graves: graveCount,
            migrated_profiles: deceasedCount.length,
            mapping_records: mappingCount.length,
            success_rate: (mappingCount.length / graveCount * 100).toFixed(2),
        };

        // éªŒè¯å…³é”®æ•°æ®å®Œæ•´æ€§
        for (const [key, mapping] of mappingCount) {
            const graveId = key.args[0].toNumber();
            const deceasedId = mapping.unwrap().toNumber();

            const profile = await api.query.deceased.deceasedProfiles(deceasedId);
            if (profile.isNone) {
                console.error(`âŒ Missing profile for deceased ${deceasedId} (grave ${graveId})`);
                results.errors = (results.errors || 0) + 1;
            }
        }

        return results;
    },

    /**
     * éªŒè¯ä¾›å¥‰è¿ç§»
     */
    async validateOfferingMigration() {
        const oldOrders = await this.getBackupOfferingOrders();
        const newOrders = await api.query.offerings.offeringOrdersV2.entries();

        const migratedOrders = newOrders.filter(([_, order]) => order.target_type.toNumber() === 0);

        return {
            original_orders: oldOrders.length,
            new_orders: newOrders.length,
            migrated_orders: migratedOrders.length,
            migration_rate: (migratedOrders.length / oldOrders.length * 100).toFixed(2),
        };
    },

    /**
     * éªŒè¯15çº§åˆ†é”€å®Œæ•´æ€§
     */
    async validateAffiliateMigration() {
        const results = {
            chain_integrity: true,
            commission_accuracy: true,
            settlement_consistency: true,
        };

        // éšæœºéªŒè¯100ä¸ªåˆ†é”€é“¾æ¡
        const testAccounts = await this.getRandomAccounts(100);

        for (const account of testAccounts) {
            try {
                // éªŒè¯åˆ†é”€é“¾æ¡å®Œæ•´æ€§
                const chainBefore = await this.getBackupAffiliateChain(account);
                const chainAfter = await this.getCurrentAffiliateChain(account);

                if (chainBefore.length !== chainAfter.length) {
                    console.warn(`âš ï¸ Chain length mismatch for ${account}`);
                    results.chain_integrity = false;
                }

                // éªŒè¯ä½£é‡‘è®¡ç®—å‡†ç¡®æ€§
                const commissionTest = await this.testCommissionCalculation(account);
                if (!commissionTest.passed) {
                    console.error(`âŒ Commission calculation error for ${account}`);
                    results.commission_accuracy = false;
                }

            } catch (error) {
                console.error(`âŒ Validation error for ${account}:`, error);
            }
        }

        return results;
    },

    /**
     * ç”ŸæˆéªŒè¯æŠ¥å‘Š
     */
    generateValidationReport(results) {
        const report = {
            timestamp: new Date().toISOString(),
            migration_status: 'completed',
            overall_success: this.calculateOverallSuccess(results),
            detailed_results: results,
            recommendations: this.generateRecommendations(results),
        };

        fs.writeFileSync(
            `reports/migration-validation-${Date.now()}.json`,
            JSON.stringify(report, null, 2)
        );

        console.log('ğŸ“Š Validation report generated');
        console.log(`Overall success rate: ${report.overall_success}%`);
    },
};
```

---

## é£é™©æ§åˆ¶ä½“ç³»

### âš¡ å¿«é€Ÿå“åº”æœºåˆ¶

```bash
#!/bin/bash
# scripts/emergency/rapid-response.sh

# ç´§æ€¥å“åº”å†³ç­–æ ‘
check_system_status() {
    echo "ğŸš¨ Emergency Response System Activated"
    echo "Time: $(date)"

    # Level 1: åŸºç¡€å¯ç”¨æ€§æ£€æŸ¥
    if ! curl -f http://localhost:3000/health; then
        echo "ğŸ”´ CRITICAL: System completely down"
        execute_emergency_rollback
        return 1
    fi

    # Level 2: æ ¸å¿ƒåŠŸèƒ½æ£€æŸ¥
    if ! node scripts/health/check-core-functions.js; then
        echo "ğŸŸ  WARNING: Core functions compromised"
        execute_partial_rollback
        return 2
    fi

    # Level 3: æ€§èƒ½å’Œé”™è¯¯ç‡æ£€æŸ¥
    local error_rate=$(node scripts/health/check-error-rate.js)
    if (( $(echo "$error_rate > 0.05" | bc -l) )); then
        echo "ğŸŸ¡ CAUTION: High error rate detected ($error_rate)"
        execute_performance_optimization
        return 3
    fi

    echo "âœ… System status: Healthy"
    return 0
}

execute_emergency_rollback() {
    echo "ğŸš¨ EXECUTING EMERGENCY ROLLBACK"

    # 1. ç«‹å³åœæ­¢æœåŠ¡
    systemctl stop stardust-node
    systemctl stop nginx

    # 2. æ¢å¤å¤‡ä»½
    ./scripts/backup/restore-latest-backup.sh

    # 3. é‡å¯æœåŠ¡
    systemctl start stardust-node
    systemctl start nginx

    # 4. é€šçŸ¥å›¢é˜Ÿ
    ./scripts/notification/emergency-alert.sh "EMERGENCY_ROLLBACK_EXECUTED"

    echo "âœ… Emergency rollback completed"
}

execute_partial_rollback() {
    echo "ğŸ”„ EXECUTING PARTIAL ROLLBACK"

    # æ¢å¤å…³é”®åŠŸèƒ½çš„å…¼å®¹æ€§
    ./scripts/migration/restore-compatibility-layer.sh

    # ä¸´æ—¶ç¦ç”¨æœ‰é—®é¢˜çš„æ–°åŠŸèƒ½
    ./scripts/migration/disable-problematic-features.sh

    # é€šçŸ¥ç”¨æˆ·
    ./scripts/notification/user-notification.sh "PARTIAL_SYSTEM_RESTORATION"

    echo "âœ… Partial rollback completed"
}

# æ‰§è¡Œæ£€æŸ¥
check_system_status
exit_code=$?

case $exit_code in
    0) echo "System operating normally" ;;
    1) echo "Emergency rollback executed" ;;
    2) echo "Partial rollback executed" ;;
    3) echo "Performance optimization applied" ;;
esac
```

### ğŸ›¡ï¸ æ•°æ®ä¿æŠ¤æœºåˆ¶

```rust
// runtime/src/migrations/safety_checks.rs

/// è¿ç§»å®‰å…¨æ£€æŸ¥ç³»ç»Ÿ
pub mod migration_safety {
    use super::*;

    /// æ‰§è¡Œå®‰å…¨è¿ç§»çš„åŒ…è£…å™¨
    pub fn safe_migration_wrapper<T: Config, F>(
        migration_name: &str,
        migration_fn: F,
    ) -> Weight
    where
        F: FnOnce() -> Result<Weight, &'static str>,
    {
        log::info!("ğŸ›¡ï¸ Starting safe migration: {}", migration_name);

        // åˆ›å»ºæ£€æŸ¥ç‚¹
        let checkpoint = create_migration_checkpoint::<T>(migration_name);

        match migration_fn() {
            Ok(weight) => {
                // éªŒè¯è¿ç§»ç»“æœ
                if verify_migration_integrity::<T>(&checkpoint) {
                    log::info!("âœ… Migration {} completed successfully", migration_name);
                    weight
                } else {
                    log::error!("âŒ Migration {} integrity check failed, rolling back", migration_name);
                    rollback_to_checkpoint::<T>(&checkpoint);
                    Weight::zero()
                }
            }
            Err(error) => {
                log::error!("âŒ Migration {} failed: {}, rolling back", migration_name, error);
                rollback_to_checkpoint::<T>(&checkpoint);
                Weight::zero()
            }
        }
    }

    /// åˆ›å»ºè¿ç§»æ£€æŸ¥ç‚¹
    fn create_migration_checkpoint<T: Config>(name: &str) -> MigrationCheckpoint {
        let current_block = <frame_system::Pallet<T>>::block_number();
        let storage_root = <frame_system::Pallet<T>>::block_hash(current_block);

        MigrationCheckpoint {
            name: name.to_string(),
            block_number: current_block,
            storage_root,
            timestamp: T::UnixTime::now(),
            critical_counts: gather_critical_counts::<T>(),
        }
    }

    /// æ”¶é›†å…³é”®æ•°æ®è®¡æ•°
    fn gather_critical_counts<T: Config>() -> CriticalDataCounts {
        CriticalDataCounts {
            deceased_profiles: pallet_deceased::DeceasedProfiles::<T>::iter().count() as u32,
            offering_orders: pallet_offerings::OfferingOrdersV2::<T>::iter().count() as u32,
            affiliate_relationships: pallet_memo_affiliate::SponsorOf::<T>::iter().count() as u32,
            memorial_spaces: pallet_memorial_space::VirtualMemorialSpaces::<T>::iter().count() as u32,
        }
    }

    /// éªŒè¯è¿ç§»å®Œæ•´æ€§
    fn verify_migration_integrity<T: Config>(checkpoint: &MigrationCheckpoint) -> bool {
        log::info!("ğŸ” Verifying migration integrity...");

        let current_counts = gather_critical_counts::<T>();
        let integrity_checks = [
            // æ•°æ®ä¸åº”è¯¥ä¸¢å¤±ï¼ˆåªèƒ½å¢åŠ æˆ–ä¿æŒä¸å˜ï¼‰
            current_counts.deceased_profiles >= checkpoint.critical_counts.deceased_profiles,
            current_counts.affiliate_relationships >= checkpoint.critical_counts.affiliate_relationships,

            // æ–°æ•°æ®åº”è¯¥è¢«åˆ›å»º
            current_counts.memorial_spaces > 0,

            // æ˜ å°„å…³ç³»åº”è¯¥å­˜åœ¨
            verify_mapping_consistency::<T>(),

            // åˆ†é”€é“¾æ¡åº”è¯¥å®Œæ•´
            verify_affiliate_chains::<T>(),
        ];

        let all_passed = integrity_checks.iter().all(|&check| check);

        if all_passed {
            log::info!("âœ… All integrity checks passed");
        } else {
            log::error!("âŒ Integrity check failures detected");
            log_integrity_details(&current_counts, &checkpoint.critical_counts);
        }

        all_passed
    }

    /// éªŒè¯æ˜ å°„ä¸€è‡´æ€§
    fn verify_mapping_consistency<T: Config>() -> bool {
        let mapping_count = pallet_deceased::GraveToDeceasedMapping::<T>::iter().count();
        let memorial_count = pallet_memorial_space::VirtualMemorialSpaces::<T>::iter().count();

        // æ¯ä¸ªæ˜ å°„éƒ½åº”è¯¥æœ‰å¯¹åº”çš„çºªå¿µç©ºé—´
        mapping_count > 0 && memorial_count > 0 && mapping_count <= memorial_count
    }

    /// éªŒè¯åˆ†é”€é“¾æ¡
    fn verify_affiliate_chains<T: Config>() -> bool {
        // éšæœºæ£€æŸ¥10ä¸ªåˆ†é”€é“¾æ¡
        let accounts: Vec<_> = pallet_memo_affiliate::SponsorOf::<T>::iter()
            .take(10)
            .collect();

        for (account, sponsor) in accounts {
            // éªŒè¯é“¾æ¡å®Œæ•´æ€§
            if !verify_single_affiliate_chain::<T>(&account) {
                log::warn!("âš ï¸ Affiliate chain broken for account: {:?}", account);
                return false;
            }
        }

        true
    }

    fn verify_single_affiliate_chain<T: Config>(account: &T::AccountId) -> bool {
        let mut current = account.clone();
        let mut chain_length = 0;

        // å‘ä¸Šéå†åˆ†é”€é“¾æ¡
        while let Some(sponsor) = pallet_memo_affiliate::SponsorOf::<T>::get(&current) {
            current = sponsor;
            chain_length += 1;

            if chain_length > 15 {
                break; // é˜²æ­¢æ— é™å¾ªç¯
            }
        }

        // åŸºæœ¬æ£€æŸ¥ï¼šé“¾æ¡é•¿åº¦åˆç†
        chain_length <= 15
    }

    /// å›æ»šåˆ°æ£€æŸ¥ç‚¹
    fn rollback_to_checkpoint<T: Config>(checkpoint: &MigrationCheckpoint) {
        log::warn!("ğŸ”„ Rolling back to checkpoint: {}", checkpoint.name);

        // è¿™é‡Œå®ç°å›æ»šé€»è¾‘
        // æ³¨æ„ï¼šåœ¨ç”Ÿäº§ç¯å¢ƒä¸­è¿™éœ€è¦æ›´å¤æ‚çš„å®ç°
        // åŒ…æ‹¬æ¢å¤å­˜å‚¨çŠ¶æ€ã€é‡ç½®è®¡æ•°å™¨ç­‰

        log::info!("âœ… Rollback to checkpoint completed");
    }
}
```

---

## è´¨é‡ä¿è¯

### ğŸ§ª å…¨é¢æµ‹è¯•ç­–ç•¥

```rust
// tests/integration/grave_migration_test.rs

#[cfg(test)]
mod grave_migration_tests {
    use super::*;
    use frame_support::assert_ok;

    #[test]
    fn test_complete_migration_flow() {
        ExtBuilder::default().build_and_execute(|| {
            // 1. è®¾ç½®åˆå§‹çŠ¶æ€
            setup_migration_test_data();

            // 2. æ‰§è¡Œè¿ç§»
            let migration_result = execute_test_migration();
            assert!(migration_result.is_ok());

            // 3. éªŒè¯è¿ç§»ç»“æœ
            verify_migration_completeness();
            verify_data_integrity();
            verify_business_logic();
        });
    }

    #[test]
    fn test_offering_system_compatibility() {
        ExtBuilder::default().build_and_execute(|| {
            // åˆ›å»ºæµ‹è¯•æ•°æ®
            let deceased_id = create_test_deceased();
            let space_id = create_test_memorial_space(deceased_id);

            // æµ‹è¯•æ–°çš„ä¾›å¥‰æ¥å£
            assert_ok!(Offerings::offer_to_target(
                Origin::signed(ALICE),
                0, // target_type: deceased
                deceased_id,
                1, // offering_type
                10, // quantity
                None, // prayer
            ));

            // éªŒè¯åˆ†é”€è§¦å‘
            verify_affiliate_commission_triggered(ALICE, deceased_id);
        });
    }

    #[test]
    fn test_compatibility_layer() {
        ExtBuilder::default().build_and_execute(|| {
            let grave_id = 1;
            let deceased_id = create_test_deceased();

            // åˆ›å»ºæ˜ å°„å…³ç³»
            pallet_deceased::GraveToDeceasedMapping::<Test>::insert(grave_id, deceased_id);

            // æµ‹è¯•å…¼å®¹æ€§æ¥å£
            assert_ok!(Offerings::offer_to_grave_compat(
                Origin::signed(ALICE),
                grave_id,
                1, // offering_type
                5, // quantity
            ));

            // éªŒè¯é‡å®šå‘æ­£ç¡®å·¥ä½œ
            let orders = get_offering_orders_by_target(0, deceased_id);
            assert_eq!(orders.len(), 1);
        });
    }

    #[test]
    fn test_migration_rollback() {
        ExtBuilder::default().build_and_execute(|| {
            // åˆ›å»ºæ£€æŸ¥ç‚¹
            let checkpoint = create_test_checkpoint();

            // æ‰§è¡Œéƒ¨åˆ†è¿ç§»
            execute_partial_migration();

            // æ¨¡æ‹Ÿè¿ç§»å¤±è´¥
            inject_migration_failure();

            // æ‰§è¡Œå›æ»š
            rollback_to_checkpoint(&checkpoint);

            // éªŒè¯å›æ»šæˆåŠŸ
            verify_rollback_success(&checkpoint);
        });
    }

    fn setup_migration_test_data() {
        // åˆ›å»ºæµ‹è¯•å¢“ä½
        assert_ok!(Grave::create_grave(Origin::signed(ALICE), Some(1), b"Test Grave".to_vec()));

        // åˆ›å»ºæµ‹è¯•é€è€…
        let deceased_id = create_test_deceased();

        // å»ºç«‹å®‰è‘¬å…³ç³»
        assert_ok!(Grave::inter(Origin::signed(ALICE), 1, deceased_id, 0, None));

        // åˆ›å»ºä¾›å¥‰è®¢å•
        assert_ok!(Offerings::offer_to_grave(Origin::signed(BOB), 1, 1, 10));

        // å»ºç«‹åˆ†é”€å…³ç³»
        setup_affiliate_relationships();
    }

    fn verify_migration_completeness() {
        // éªŒè¯æ˜ å°„åˆ›å»º
        assert!(pallet_deceased::GraveToDeceasedMapping::<Test>::iter().count() > 0);

        // éªŒè¯çºªå¿µç©ºé—´åˆ›å»º
        assert!(pallet_memorial_space::VirtualMemorialSpaces::<Test>::iter().count() > 0);

        // éªŒè¯æ—§å­˜å‚¨æ¸…ç†
        assert_eq!(pallet_stardust_grave::Graves::<Test>::iter().count(), 0);
    }

    fn verify_business_logic() {
        // éªŒè¯15çº§åˆ†é”€ä»ç„¶æœ‰æ•ˆ
        verify_affiliate_commission_calculation();

        // éªŒè¯ä¾›å¥‰æµç¨‹
        verify_offering_workflow();

        // éªŒè¯æƒé™ç³»ç»Ÿ
        verify_permission_system();
    }
}
```

### ğŸ“Š æ€§èƒ½ç›‘æ§

```typescript
// stardust-dapp/src/utils/performanceMonitor.ts

export class MigrationPerformanceMonitor {
    private metrics: Map<string, PerformanceMetric[]> = new Map();
    private baseline: PerformanceBaseline;

    constructor() {
        this.loadBaseline();
    }

    /**
     * æµ‹é‡æ“ä½œæ€§èƒ½
     */
    async measureOperation<T>(
        operationName: string,
        operation: () => Promise<T>
    ): Promise<T> {
        const startTime = performance.now();
        const startMemory = this.getMemoryUsage();

        try {
            const result = await operation();

            const duration = performance.now() - startTime;
            const memoryDelta = this.getMemoryUsage() - startMemory;

            this.recordMetric(operationName, {
                duration,
                memoryDelta,
                timestamp: Date.now(),
                success: true,
            });

            this.checkPerformanceThresholds(operationName, duration);

            return result;
        } catch (error) {
            const duration = performance.now() - startTime;

            this.recordMetric(operationName, {
                duration,
                memoryDelta: 0,
                timestamp: Date.now(),
                success: false,
                error: error.message,
            });

            throw error;
        }
    }

    /**
     * æ£€æŸ¥æ€§èƒ½é˜ˆå€¼
     */
    private checkPerformanceThresholds(operation: string, duration: number) {
        const threshold = this.getPerformanceThreshold(operation);

        if (duration > threshold * 1.5) {
            console.warn(`âš ï¸ Performance degradation in ${operation}: ${duration.toFixed(2)}ms (baseline: ${threshold}ms)`);

            // å‘é€æ€§èƒ½è­¦å‘Š
            this.sendPerformanceAlert(operation, duration, threshold);
        }

        if (duration < threshold * 0.5) {
            console.log(`ğŸš€ Performance improvement in ${operation}: ${duration.toFixed(2)}ms (baseline: ${threshold}ms)`);
        }
    }

    /**
     * ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
     */
    generatePerformanceReport(): PerformanceReport {
        const report: PerformanceReport = {
            timestamp: new Date().toISOString(),
            operations: {},
            summary: {
                totalOperations: 0,
                averagePerformance: 0,
                performanceScore: 0,
            },
        };

        for (const [operation, metrics] of this.metrics.entries()) {
            const successfulMetrics = metrics.filter(m => m.success);

            if (successfulMetrics.length === 0) continue;

            const averageDuration = successfulMetrics.reduce((sum, m) => sum + m.duration, 0) / successfulMetrics.length;
            const baseline = this.getPerformanceThreshold(operation);
            const performanceRatio = baseline / averageDuration;

            report.operations[operation] = {
                averageDuration,
                baseline,
                performanceRatio,
                improvementPercentage: ((performanceRatio - 1) * 100).toFixed(1),
                totalMeasurements: metrics.length,
                successRate: (successfulMetrics.length / metrics.length * 100).toFixed(1),
            };

            report.summary.totalOperations += metrics.length;
        }

        // è®¡ç®—æ€»ä½“æ€§èƒ½è¯„åˆ†
        const operationScores = Object.values(report.operations).map(op => op.performanceRatio);
        report.summary.averagePerformance = operationScores.reduce((sum, score) => sum + score, 0) / operationScores.length;
        report.summary.performanceScore = Math.min(100, report.summary.averagePerformance * 100);

        return report;
    }

    /**
     * å¯¹æ¯”è¿ç§»å‰åæ€§èƒ½
     */
    compareWithBaseline(): PerformanceComparison {
        const current = this.generatePerformanceReport();

        return {
            timestamp: new Date().toISOString(),
            comparison: {
                overall_performance: {
                    before: this.baseline.overallScore,
                    after: current.summary.performanceScore,
                    change: current.summary.performanceScore - this.baseline.overallScore,
                },
                operation_details: Object.entries(current.operations).map(([operation, metrics]) => ({
                    operation,
                    before: this.baseline.operations[operation]?.averageDuration || 0,
                    after: metrics.averageDuration,
                    improvement: metrics.improvementPercentage,
                })),
            },
            recommendations: this.generatePerformanceRecommendations(current),
        };
    }
}
```

---

## æˆæœ¬æ•ˆç›Šåˆ†æ

### ğŸ’° æŠ•èµ„ä¸æ”¶ç›Šè¯„ä¼°

| æˆæœ¬é¡¹ç›® | é¢„ä¼°æˆæœ¬ | å®é™…æ•ˆç›Š | ROIæœŸæœ› |
|---------|---------|---------|---------|
| **å¼€å‘æˆæœ¬** | 4å‘¨Ã—3äºº = 12äººå‘¨ | ç³»ç»Ÿç®€åŒ–ï¼Œé™ä½ç»´æŠ¤æˆæœ¬ | 6ä¸ªæœˆå›æ”¶ |
| **æµ‹è¯•æˆæœ¬** | 1å‘¨Ã—2äºº = 2äººå‘¨ | è´¨é‡æå‡ï¼Œå‡å°‘bugä¿®å¤ | 3ä¸ªæœˆå›æ”¶ |
| **éƒ¨ç½²æˆæœ¬** | 3å¤©Ã—1äºº = 0.6äººå‘¨ | å¹³æ»‘è¿ç§»ï¼Œç”¨æˆ·ä½“éªŒæå‡ | 1ä¸ªæœˆå›æ”¶ |
| **åŸ¹è®­æˆæœ¬** | 1å‘¨Ã—2äºº = 2äººå‘¨ | å›¢é˜ŸæŠ€èƒ½æå‡ | æŒç»­å—ç›Š |
| **é£é™©ç¼“è§£** | 1å‘¨Ã—1äºº = 1äººå‘¨ | ç³»ç»Ÿç¨³å®šæ€§æå‡ | æŒç»­å—ç›Š |
| **æ€»è®¡** | **17.6äººå‘¨** | **æ¶æ„ä¼˜åŒ– + ç”¨æˆ·ä½“éªŒæå‡** | **4-6ä¸ªæœˆ** |

### ğŸ“ˆ é•¿æœŸä»·å€¼

1. **æ¶æ„æ¸…æ™°åŒ–**ï¼šå‡å°‘palletæ•°é‡ï¼Œé™ä½ç³»ç»Ÿå¤æ‚åº¦
2. **ç»´æŠ¤ç®€åŒ–**ï¼šåŠŸèƒ½é›†ä¸­ï¼Œå‡å°‘è·¨æ¨¡å—ä¾èµ–
3. **æ‰©å±•æ€§æå‡**ï¼šåŸºäºé€è€…æ¡£æ¡ˆçš„æ¶æ„æ›´é€‚åˆæœªæ¥å‘å±•
4. **ç”¨æˆ·ä½“éªŒ**ï¼šæ›´ç›´è§‚çš„çºªå¿µç®¡ç†æ–¹å¼
5. **å›¢é˜Ÿæ•ˆç‡**ï¼šå‡å°‘é‡å¤å¼€å‘ï¼Œä¸“æ³¨æ ¸å¿ƒåŠŸèƒ½

---

## ğŸ“„ æ€»ç»“ä¸å»ºè®®

### âœ… æ¨èæ‰§è¡Œç†ç”±

1. **æŠ€æœ¯å¯è¡Œæ€§é«˜**ï¼šåŸºäºç°æœ‰æ¶æ„è¿›è¡ŒåŠŸèƒ½é‡ç»„ï¼Œé£é™©å¯æ§
2. **ä¸šåŠ¡è¿ç»­æ€§å¼º**ï¼š15çº§åˆ†é”€ä½“ç³»å®Œå…¨ä¿ç•™ï¼Œç”¨æˆ·æ„ŸçŸ¥æœ€å°
3. **ç”¨æˆ·ä½“éªŒä¼˜åŒ–**ï¼šä»"ç®¡ç†å¢“ä½"å‡çº§ä¸º"çºªå¿µæ¡£æ¡ˆç®¡ç†"
4. **ç³»ç»Ÿæ¶æ„ç®€åŒ–**ï¼šå‡å°‘palletæ•°é‡ï¼Œæå‡ç»´æŠ¤æ•ˆç‡
5. **æŠ•èµ„å›æŠ¥æ˜ç¡®**ï¼š4-6ä¸ªæœˆå›æ”¶æŠ•èµ„ï¼Œé•¿æœŸæŒç»­å—ç›Š

### ğŸ¯ æˆåŠŸå…³é”®è¦ç´ 

1. **å›¢é˜ŸååŒ**ï¼šå‰åç«¯ã€æµ‹è¯•ã€è¿ç»´ç´§å¯†é…åˆ
2. **ç”¨æˆ·æ²Ÿé€š**ï¼šå……åˆ†å‘ŠçŸ¥è¿ç§»è®¡åˆ’ï¼Œè·å¾—ç†è§£æ”¯æŒ
3. **è´¨é‡æ§åˆ¶**ï¼šä¸¥æ ¼æ‰§è¡Œæµ‹è¯•è®¡åˆ’ï¼Œç¡®ä¿ç³»ç»Ÿç¨³å®š
4. **ç›‘æ§é¢„è­¦**ï¼šå®æ—¶ç›‘æ§ç³»ç»ŸçŠ¶æ€ï¼Œå¿«é€Ÿå“åº”é—®é¢˜
5. **æ¸è¿›å®æ–½**ï¼šåˆ†é˜¶æ®µæ‰§è¡Œï¼Œé™ä½å•æ¬¡å˜æ›´é£é™©

### ğŸš€ ä¸‹ä¸€æ­¥è¡ŒåŠ¨

1. **è·å¾—æ‰¹å‡†**ï¼šå‘é¡¹ç›®å›¢é˜Ÿå±•ç¤ºæ–¹æ¡ˆï¼Œè·å¾—æ‰§è¡Œæ‰¹å‡†
2. **å›¢é˜Ÿç»„å»º**ï¼šç¡®è®¤å‚ä¸äººå‘˜ï¼Œæ˜ç¡®åˆ†å·¥èŒè´£
3. **ç¯å¢ƒå‡†å¤‡**ï¼šå»ºç«‹å¼€å‘ã€æµ‹è¯•ã€éƒ¨ç½²ç¯å¢ƒ
4. **å¯åŠ¨æ‰§è¡Œ**ï¼šæŒ‰ç…§4å‘¨è®¡åˆ’å¼€å§‹å®æ–½
5. **æŒç»­ä¼˜åŒ–**ï¼šæ ¹æ®æ‰§è¡Œæƒ…å†µè°ƒæ•´è®¡åˆ’ï¼Œç¡®ä¿æˆåŠŸ

**æœ¬æ–¹æ¡ˆå·²ç»è¿‡æ·±åº¦åˆ†æå’Œé£é™©è¯„ä¼°ï¼Œå…·å¤‡å®Œæ•´çš„æŠ€æœ¯å®æ–½è·¯å¾„å’Œé£é™©æ§åˆ¶æœºåˆ¶ï¼Œæ¨èç«‹å³å¯åŠ¨æ‰§è¡Œã€‚**

---

**æ–¹æ¡ˆçŠ¶æ€**: ğŸ¯ æ¨èæ‰§è¡Œ
**æœ€åæ›´æ–°**: 2025-11-16
**ä½œè€…**: Stardust Dev Team
**å®¡æ ¸çŠ¶æ€**: å¾…æœ€ç»ˆæ‰¹å‡†