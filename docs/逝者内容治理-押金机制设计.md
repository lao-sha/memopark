# é€è€…å†…å®¹æ²»ç† - æŠ¼é‡‘æœºåˆ¶è®¾è®¡

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†é˜è¿° Stardust é€è€…å†…å®¹æ²»ç†ç³»ç»Ÿä¸­çš„æŠ¼é‡‘æœºåˆ¶è®¾è®¡ï¼Œæ—¨åœ¨é€šè¿‡ç»æµæ¿€åŠ±å’Œæƒ©ç½šæ‰‹æ®µï¼Œæœ‰æ•ˆé˜²æ­¢æ¶æ„æŠ•è¯‰ã€æå‡æ²»ç†è´¨é‡ï¼ŒåŒæ—¶ä¿æŠ¤åˆæ³•ä¸¾æŠ¥è€…çš„æƒç›Šã€‚

### è®¾è®¡ç›®æ ‡

- **é˜²æ­¢æ¶æ„æŠ•è¯‰**ï¼šé€šè¿‡æŠ¼é‡‘é—¨æ§›è¿‡æ»¤æ¶æ„ä¸¾æŠ¥
- **æ¿€åŠ±ä¼˜è´¨ä¸¾æŠ¥**ï¼šå¥–åŠ±æä¾›çœŸå®æœ‰æ•ˆè¯æ®çš„ä¸¾æŠ¥è€…
- **å…¬å¹³åˆç†**ï¼šæŠ¼é‡‘æ ‡å‡†ä¸ä¸¾æŠ¥å†…å®¹ä¸¥é‡æ€§ç›¸åŒ¹é…
- **é€æ˜å¯è¿½æº¯**ï¼šæ‰€æœ‰æŠ¼é‡‘æ“ä½œé“¾ä¸Šè®°å½•ï¼Œå®Œå…¨é€æ˜
- **èµ„é‡‘å®‰å…¨**ï¼šä½¿ç”¨ Substrate Holds API ç¡®ä¿èµ„é‡‘å®‰å…¨

### æ ¸å¿ƒåŸåˆ™

```mermaid
graph TB
    A[æŠ¼é‡‘æœºåˆ¶] --> B[é—¨æ§›è®¾ç½®]
    A --> C[åŠ¨æ€è°ƒæ•´]
    A --> D[åˆ†çº§ç®¡ç†]
    A --> E[å…¬å¹³å¥–æƒ©]

    B --> B1[é˜²æ­¢æ¶æ„]
    B --> B2[ä¸é˜»ç¢åˆæ³•]

    C --> C1[ä¿¡èª‰åŠ æƒ]
    C --> C2[å†å²è¡Œä¸º]
    C --> C3[å†…å®¹ä¸¥é‡æ€§]

    D --> D1[è½»å¾®è¿è§„-ä½æŠ¼é‡‘]
    D --> D2[ä¸¥é‡è¿è§„-é«˜æŠ¼é‡‘]
    D --> D3[ç´§æ€¥æƒ…å†µ-ç‰¹æ®Šå¤„ç†]

    E --> E1[ä¸¾æŠ¥æˆåŠŸ-é€€è¿˜+å¥–åŠ±]
    E --> E2[ä¸¾æŠ¥å¤±è´¥-éƒ¨åˆ†ç½šæ²¡]
    E --> E3[æ¶æ„ä¸¾æŠ¥-å…¨é¢ç½šæ²¡]

    style A fill:#e1f5fe
    style B fill:#fff3e0
    style C fill:#f3e5f5
    style D fill:#e8f5e9
    style E fill:#fce4ec
```

---

## ğŸ’° æŠ¼é‡‘æ ‡å‡†è®¾è®¡

### åŸºç¡€æŠ¼é‡‘ä½“ç³»

#### 1. å›ºå®šåŸºç¡€æŠ¼é‡‘
æ ¹æ®ä¸¾æŠ¥å†…å®¹ç±»å‹è®¾å®šåŸºç¡€æŠ¼é‡‘é¢åº¦ï¼š

```rust
pub struct BaseDepositSchedule {
    // æŒ‰Domainåˆ†ç±»çš„åŸºç¡€æŠ¼é‡‘
    pub deposits_by_domain: BTreeMap<u8, Balance>,

    // æŒ‰è¿è§„ç±»å‹åˆ†ç±»çš„åŸºç¡€æŠ¼é‡‘
    pub deposits_by_violation: BTreeMap<ViolationType, Balance>,

    // æŒ‰ä¸¥é‡ç¨‹åº¦åˆ†ç±»çš„åŸºç¡€æŠ¼é‡‘
    pub deposits_by_severity: BTreeMap<SeverityLevel, Balance>,
}

// å®ç°ç¤ºä¾‹
impl Default for BaseDepositSchedule {
    fn default() -> Self {
        let mut deposits_by_domain = BTreeMap::new();
        deposits_by_domain.insert(1, 30 * DUST);  // å¢“åœ°ä¿¡æ¯ï¼š30 DUST
        deposits_by_domain.insert(2, 50 * DUST);  // é€è€…æ¡£æ¡ˆï¼š50 DUST
        deposits_by_domain.insert(3, 40 * DUST);  // é€è€…æ–‡ç« ï¼š40 DUST
        deposits_by_domain.insert(4, 60 * DUST);  // é€è€…ç›¸å†Œï¼š60 DUSTï¼ˆæ¶‰åŠéšç§ï¼‰
        deposits_by_domain.insert(5, 35 * DUST);  // çºªå¿µä¾›å¥‰ï¼š35 DUST

        let mut deposits_by_violation = BTreeMap::new();
        deposits_by_violation.insert(ViolationType::FalseInformation, 40 * DUST);
        deposits_by_violation.insert(ViolationType::InappropriateContent, 50 * DUST);
        deposits_by_violation.insert(ViolationType::PrivacyViolation, 70 * DUST);
        deposits_by_violation.insert(ViolationType::HateSpeech, 80 * DUST);
        deposits_by_violation.insert(ViolationType::IllegalContent, 100 * DUST);
        deposits_by_violation.insert(ViolationType::CommercialAbuse, 45 * DUST);

        let mut deposits_by_severity = BTreeMap::new();
        deposits_by_severity.insert(SeverityLevel::Minor, 20 * DUST);
        deposits_by_severity.insert(SeverityLevel::Moderate, 50 * DUST);
        deposits_by_severity.insert(SeverityLevel::Serious, 80 * DUST);
        deposits_by_severity.insert(SeverityLevel::Critical, 120 * DUST);

        Self {
            deposits_by_domain,
            deposits_by_violation,
            deposits_by_severity,
        }
    }
}

// è¿è§„ç±»å‹å®šä¹‰
pub enum ViolationType {
    FalseInformation,      // è™šå‡ä¿¡æ¯
    InappropriateContent,  // ä¸å½“å†…å®¹
    PrivacyViolation,      // éšç§ä¾µçŠ¯
    HateSpeech,           // ä»‡æ¨è¨€è®º
    IllegalContent,       // è¿æ³•å†…å®¹
    CommercialAbuse,      // å•†ä¸šæ»¥ç”¨
}

// ä¸¥é‡ç¨‹åº¦å®šä¹‰
pub enum SeverityLevel {
    Minor,      // è½»å¾®ï¼ˆå¦‚å°é”™è¯¯ã€æ ¼å¼é—®é¢˜ï¼‰
    Moderate,   // ä¸­ç­‰ï¼ˆå¦‚éƒ¨åˆ†ä¸å®ã€è½»å¾®ä¸å½“ï¼‰
    Serious,    // ä¸¥é‡ï¼ˆå¦‚æ˜æ˜¾è™šå‡ã€éšç§æ³„éœ²ï¼‰
    Critical,   // æä¸¥é‡ï¼ˆå¦‚è¿æ³•çŠ¯ç½ªã€é‡å¤§ä¼¤å®³ï¼‰
}
```

#### 2. æŠ¼é‡‘è®¡ç®—å…¬å¼
ç»¼åˆè€ƒè™‘å¤šä¸ªå› ç´ è®¡ç®—æœ€ç»ˆæŠ¼é‡‘ï¼š

```rust
/// è®¡ç®—ä¸¾æŠ¥æŠ¼é‡‘
pub fn calculate_complaint_deposit(
    who: &T::AccountId,
    domain: u8,
    target_id: u64,
    violation_type: ViolationType,
    severity: SeverityLevel,
) -> Balance {
    // æ­¥éª¤1: è·å–åŸºç¡€æŠ¼é‡‘
    let base_deposit = get_base_deposit(domain, violation_type, severity);

    // æ­¥éª¤2: ä¿¡èª‰ç³»æ•°ï¼ˆ0.5 - 2.0ï¼‰
    let reputation_multiplier = calculate_reputation_multiplier(who);

    // æ­¥éª¤3: å†å²è¡Œä¸ºç³»æ•°ï¼ˆ0.8 - 1.5ï¼‰
    let history_multiplier = calculate_history_multiplier(who);

    // æ­¥éª¤4: å†…å®¹ä»·å€¼ç³»æ•°ï¼ˆ0.9 - 1.3ï¼‰
    let content_value_multiplier = calculate_content_value_multiplier(domain, target_id);

    // æ­¥éª¤5: æ—¶é—´åŠ æƒç³»æ•°ï¼ˆ0.9 - 1.2ï¼‰
    let time_multiplier = calculate_time_multiplier();

    // æœ€ç»ˆæŠ¼é‡‘è®¡ç®—
    let calculated_deposit = base_deposit
        .saturating_mul(reputation_multiplier)
        .saturating_mul(history_multiplier)
        .saturating_mul(content_value_multiplier)
        .saturating_mul(time_multiplier);

    // è®¾ç½®æŠ¼é‡‘ä¸Šä¸‹é™
    let min_deposit = T::MinComplaintDeposit::get();
    let max_deposit = T::MaxComplaintDeposit::get();

    calculated_deposit.clamp(min_deposit, max_deposit)
}

/// è·å–åŸºç¡€æŠ¼é‡‘ï¼ˆå–æœ€é«˜å€¼ï¼‰
fn get_base_deposit(
    domain: u8,
    violation_type: ViolationType,
    severity: SeverityLevel,
) -> Balance {
    let schedule = BaseDepositSchedule::default();

    let by_domain = schedule.deposits_by_domain.get(&domain).copied().unwrap_or(50 * DUST);
    let by_violation = schedule.deposits_by_violation.get(&violation_type).copied().unwrap_or(50 * DUST);
    let by_severity = schedule.deposits_by_severity.get(&severity).copied().unwrap_or(50 * DUST);

    // å–ä¸‰è€…æœ€é«˜å€¼ä½œä¸ºåŸºç¡€æŠ¼é‡‘
    by_domain.max(by_violation).max(by_severity)
}
```

---

## ğŸ“Š åŠ¨æ€è°ƒæ•´æœºåˆ¶

### 1. ä¿¡èª‰ç³»æ•°è®¡ç®—

```rust
/// ä¿¡èª‰ç³»æ•°è®¡ç®—ï¼ˆ0.5 - 2.0ï¼‰
pub fn calculate_reputation_multiplier(who: &T::AccountId) -> PerU16 {
    let reputation_score = T::ReputationProvider::get_reputation(who);

    // ä¿¡èª‰åˆ†æ˜ å°„åˆ°ç³»æ•°
    // 0-200åˆ†: 2.0å€ï¼ˆä½ä¿¡èª‰ï¼Œé«˜æŠ¼é‡‘ï¼‰
    // 200-500åˆ†: 1.5-2.0å€
    // 500-1000åˆ†: 1.0-1.5å€ï¼ˆæ ‡å‡†ï¼‰
    // 1000-2000åˆ†: 0.7-1.0å€
    // 2000+åˆ†: 0.5-0.7å€ï¼ˆé«˜ä¿¡èª‰ï¼Œä½æŠ¼é‡‘ï¼‰

    let multiplier_bps = if reputation_score < 200 {
        20_000u16  // 2.0å€
    } else if reputation_score < 500 {
        // çº¿æ€§æ’å€¼ï¼š15000 + (reputation - 200) * (20000 - 15000) / 300
        15_000 + ((reputation_score - 200) * 5_000 / 300) as u16
    } else if reputation_score < 1000 {
        // çº¿æ€§æ’å€¼ï¼š10000 + (reputation - 500) * (15000 - 10000) / 500
        10_000 + ((reputation_score - 500) * 5_000 / 500) as u16
    } else if reputation_score < 2000 {
        // çº¿æ€§æ’å€¼ï¼š7000 + (reputation - 1000) * (10000 - 7000) / 1000
        7_000 + ((reputation_score - 1000) * 3_000 / 1000) as u16
    } else {
        // çº¿æ€§æ’å€¼ï¼š5000 + min((reputation - 2000) * (7000 - 5000) / 1000, 2000)
        let bonus = ((reputation_score - 2000) * 2_000 / 1000).min(2_000) as u16;
        5_000 + bonus
    };

    PerU16::from_parts(multiplier_bps)
}

/// ä¿¡èª‰åˆ†æ¥æº
pub trait ReputationProvider<AccountId> {
    fn get_reputation(who: &AccountId) -> u32;
}

// ä¿¡èª‰åˆ†æ„æˆ
pub struct ReputationScore {
    pub correct_reports: u32,        // æ­£ç¡®ä¸¾æŠ¥ï¼š+20åˆ†/æ¬¡
    pub wrong_reports: i32,          // é”™è¯¯ä¸¾æŠ¥ï¼š-10åˆ†/æ¬¡
    pub malicious_reports: i32,      // æ¶æ„ä¸¾æŠ¥ï¼š-50åˆ†/æ¬¡
    pub quality_evidence: u32,       // ä¼˜è´¨è¯æ®ï¼š+15åˆ†/æ¬¡
    pub voting_accuracy: u32,        // æŠ•ç¥¨å‡†ç¡®ï¼š+5åˆ†/æ¬¡
    pub community_contribution: u32, // ç¤¾åŒºè´¡çŒ®ï¼š+1-100åˆ†
    pub time_decay_factor: f64,      // æ—¶é—´è¡°å‡å› å­
}
```

### 2. å†å²è¡Œä¸ºç³»æ•°

```rust
/// å†å²è¡Œä¸ºç³»æ•°è®¡ç®—ï¼ˆ0.8 - 1.5ï¼‰
pub fn calculate_history_multiplier(who: &T::AccountId) -> PerU16 {
    let history = T::ComplaintHistory::get_user_history(who);

    // è¿‘æœŸä¸¾æŠ¥ç»Ÿè®¡ï¼ˆæœ€è¿‘30å¤©ï¼‰
    let recent_complaints = history.complaints_last_30_days;
    let successful_complaints = history.successful_last_30_days;
    let failed_complaints = history.failed_last_30_days;

    // æˆåŠŸç‡
    let success_rate = if recent_complaints > 0 {
        (successful_complaints * 100) / recent_complaints
    } else {
        50  // æ–°ç”¨æˆ·é»˜è®¤50%
    };

    // ä¸¾æŠ¥é¢‘ç‡ï¼ˆæ˜¯å¦é¢‘ç¹ä¸¾æŠ¥ï¼‰
    let frequency_factor = if recent_complaints > 20 {
        11_000u16  // é¢‘ç¹ä¸¾æŠ¥ï¼Œæé«˜æŠ¼é‡‘10%
    } else if recent_complaints > 10 {
        10_500u16
    } else {
        10_000u16  // æ ‡å‡†
    };

    // æˆåŠŸç‡å› å­
    let success_factor = if success_rate >= 80 {
        8_000u16   // é«˜æˆåŠŸç‡ï¼Œé™ä½æŠ¼é‡‘20%
    } else if success_rate >= 60 {
        9_000u16
    } else if success_rate >= 40 {
        10_000u16  // æ ‡å‡†
    } else if success_rate >= 20 {
        12_000u16
    } else {
        15_000u16  // ä½æˆåŠŸç‡ï¼Œæé«˜æŠ¼é‡‘50%
    };

    // ç»¼åˆè®¡ç®—
    let combined_bps = (frequency_factor + success_factor) / 2;
    PerU16::from_parts(combined_bps)
}

pub struct ComplaintHistory {
    pub total_complaints: u32,
    pub complaints_last_30_days: u32,
    pub successful_last_30_days: u32,
    pub failed_last_30_days: u32,
    pub malicious_count: u32,
    pub last_complaint_block: BlockNumber,
}
```

### 3. å†…å®¹ä»·å€¼ç³»æ•°

```rust
/// å†…å®¹ä»·å€¼ç³»æ•°è®¡ç®—ï¼ˆ0.9 - 1.3ï¼‰
pub fn calculate_content_value_multiplier(
    domain: u8,
    target_id: u64,
) -> PerU16 {
    // è·å–å†…å®¹å…ƒæ•°æ®
    let content_meta = match domain {
        1 => T::GraveProvider::get_grave_metadata(target_id),
        2 => T::DeceasedProvider::get_deceased_metadata(target_id),
        3 => T::TextProvider::get_text_metadata(target_id),
        4 => T::MediaProvider::get_media_metadata(target_id),
        5 => T::OfferingProvider::get_offering_metadata(target_id),
        _ => None,
    };

    if let Some(meta) = content_meta {
        // å› ç´ 1: å†…å®¹å¹´é¾„ï¼ˆè¶Šè€è¶Šé‡è¦ï¼‰
        let age_factor = calculate_age_factor(meta.created_at);

        // å› ç´ 2: è®¿é—®é‡ï¼ˆè¶Šå¤šè¶Šé‡è¦ï¼‰
        let popularity_factor = calculate_popularity_factor(meta.view_count);

        // å› ç´ 3: ç¤¾äº¤äº’åŠ¨ï¼ˆè¯„è®ºã€çºªå¿µç­‰ï¼‰
        let interaction_factor = calculate_interaction_factor(meta.interaction_count);

        // å› ç´ 4: ä¸“ä¸šè®¤è¯ï¼ˆæ˜¯å¦æœ‰å®˜æ–¹è®¤è¯ï¼‰
        let certification_factor = if meta.is_certified { 12_000u16 } else { 10_000u16 };

        // åŠ æƒå¹³å‡
        let weighted_bps = (
            age_factor * 25 +
            popularity_factor * 25 +
            interaction_factor * 25 +
            certification_factor * 25
        ) / 100;

        PerU16::from_parts(weighted_bps.clamp(9_000, 13_000))
    } else {
        PerU16::from_percent(100)  // é»˜è®¤1.0å€
    }
}

fn calculate_age_factor(created_at: BlockNumber) -> u16 {
    let current_block = <frame_system::Pallet<T>>::block_number();
    let age_blocks = current_block.saturating_sub(created_at);
    let age_days = age_blocks / (24 * 60 * 10);  // å‡è®¾6ç§’ä¸€ä¸ªå—

    // å¹´é¾„æ˜ å°„ï¼š
    // 0-30å¤©: 9000 (0.9å€)
    // 30-180å¤©: 9000-10000
    // 180å¤©-1å¹´: 10000-11000
    // 1å¹´ä»¥ä¸Š: 11000-13000

    if age_days < 30 {
        9_000u16
    } else if age_days < 180 {
        9_000 + ((age_days - 30) * 1_000 / 150) as u16
    } else if age_days < 365 {
        10_000 + ((age_days - 180) * 1_000 / 185) as u16
    } else {
        11_000 + (((age_days - 365) * 2_000 / 365).min(2_000)) as u16
    }
}

fn calculate_popularity_factor(view_count: u32) -> u16 {
    // è®¿é—®é‡æ˜ å°„ï¼š
    // 0-100: 9000
    // 100-1000: 9000-10000
    // 1000-10000: 10000-12000
    // 10000+: 12000-13000

    if view_count < 100 {
        9_000u16
    } else if view_count < 1_000 {
        9_000 + ((view_count - 100) * 1_000 / 900) as u16
    } else if view_count < 10_000 {
        10_000 + ((view_count - 1_000) * 2_000 / 9_000) as u16
    } else {
        12_000 + (((view_count - 10_000) * 1_000 / 10_000).min(1_000)) as u16
    }
}
```

### 4. æ—¶é—´åŠ æƒç³»æ•°

```rust
/// æ—¶é—´åŠ æƒç³»æ•°ï¼ˆ0.9 - 1.2ï¼‰
pub fn calculate_time_multiplier() -> PerU16 {
    let current_hour = get_current_hour_of_day();
    let current_day = get_current_day_of_week();

    // å·¥ä½œæ—¥ç™½å¤©ï¼ˆå‘¨ä¸€åˆ°å‘¨äº”ï¼Œ8:00-18:00ï¼‰ï¼šæ ‡å‡†
    // å·¥ä½œæ—¥å¤œé—´ï¼šé™ä½10%ï¼ˆé¼“åŠ±ç™½å¤©å¤„ç†ï¼‰
    // å‘¨æœ«ï¼šé™ä½5%
    // èŠ‚å‡æ—¥ï¼šé™ä½10%

    let is_workday = current_day >= 1 && current_day <= 5;
    let is_working_hours = current_hour >= 8 && current_hour < 18;
    let is_holiday = T::HolidayChecker::is_holiday();

    let multiplier_bps = if is_holiday {
        9_000u16  // èŠ‚å‡æ—¥é™ä½10%
    } else if is_workday && is_working_hours {
        10_000u16  // å·¥ä½œæ—¥ç™½å¤©æ ‡å‡†
    } else if is_workday {
        9_000u16  // å·¥ä½œæ—¥å¤œé—´é™ä½10%
    } else {
        9_500u16  // å‘¨æœ«é™ä½5%
    };

    PerU16::from_parts(multiplier_bps)
}
```

---

## ğŸ”’ æŠ¼é‡‘é”å®šä¸ç®¡ç†

### æŠ¼é‡‘é”å®šæœºåˆ¶

ä½¿ç”¨ Substrate Holds API ç¡®ä¿æŠ¼é‡‘å®‰å…¨ï¼š

```rust
use frame_support::traits::fungible::{Inspect, InspectHold, Mutate, MutateHold};

/// æŠ¼é‡‘é”å®šåŸå› ï¼ˆHoldReasonï¼‰
#[pallet::composite_enum]
pub enum HoldReason {
    /// æŠ•è¯‰ä¸¾æŠ¥æŠ¼é‡‘
    ComplaintDeposit,

    /// ç”³è¯‰æŠ¼é‡‘
    AppealDeposit,

    /// æŠ•ç¥¨æŠ¼é‡‘
    VotingDeposit,

    /// è¯æ®æäº¤æŠ¼é‡‘
    EvidenceDeposit,
}

/// é”å®šæŠ¼é‡‘
pub fn lock_complaint_deposit(
    who: &T::AccountId,
    amount: BalanceOf<T>,
    complaint_id: u64,
) -> DispatchResult {
    // æ£€æŸ¥è´¦æˆ·ä½™é¢
    let free_balance = T::Fungible::reducible_balance(
        who,
        Preservation::Preserve,
        Fortitude::Polite,
    );
    ensure!(free_balance >= amount, Error::<T>::InsufficientBalance);

    // é”å®šæŠ¼é‡‘ï¼ˆä½¿ç”¨ Holds APIï¼‰
    T::Fungible::hold(
        &HoldReason::ComplaintDeposit.into(),
        who,
        amount,
    )?;

    // è®°å½•æŠ¼é‡‘ä¿¡æ¯
    ComplaintDeposits::<T>::insert(complaint_id, DepositInfo {
        depositor: who.clone(),
        amount,
        locked_at: <frame_system::Pallet<T>>::block_number(),
        status: DepositStatus::Locked,
    });

    // è§¦å‘äº‹ä»¶
    Self::deposit_event(Event::DepositLocked {
        who: who.clone(),
        complaint_id,
        amount,
    });

    Ok(())
}

/// æŠ¼é‡‘ä¿¡æ¯
#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug, TypeInfo, MaxEncodedLen)]
pub struct DepositInfo<AccountId, Balance, BlockNumber> {
    /// æŠ¼é‡‘ç¼´çº³äºº
    pub depositor: AccountId,

    /// æŠ¼é‡‘é‡‘é¢
    pub amount: Balance,

    /// é”å®šæ—¶é—´
    pub locked_at: BlockNumber,

    /// æŠ¼é‡‘çŠ¶æ€
    pub status: DepositStatus,
}

/// æŠ¼é‡‘çŠ¶æ€
#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug, TypeInfo, MaxEncodedLen)]
pub enum DepositStatus {
    /// å·²é”å®š
    Locked,

    /// å·²é‡Šæ”¾ï¼ˆå…¨é¢é€€è¿˜ï¼‰
    Released,

    /// å·²é€€è¿˜ï¼ˆéƒ¨åˆ†ç½šæ²¡ï¼‰
    PartiallyReturned { slashed_amount: Balance },

    /// å·²ç½šæ²¡ï¼ˆå…¨é¢ï¼‰
    FullySlashed,
}
```

### æŠ¼é‡‘é‡Šæ”¾æœºåˆ¶

```rust
/// é‡Šæ”¾æŠ¼é‡‘ï¼ˆå…¨é¢é€€è¿˜ï¼‰
pub fn release_complaint_deposit(
    complaint_id: u64,
    reason: ReleaseReason,
) -> DispatchResult {
    let deposit_info = ComplaintDeposits::<T>::get(complaint_id)
        .ok_or(Error::<T>::DepositNotFound)?;

    ensure!(
        deposit_info.status == DepositStatus::Locked,
        Error::<T>::DepositAlreadyProcessed
    );

    // é‡Šæ”¾æŠ¼é‡‘
    T::Fungible::release(
        &HoldReason::ComplaintDeposit.into(),
        &deposit_info.depositor,
        deposit_info.amount,
        Precision::Exact,
    )?;

    // æ›´æ–°æŠ¼é‡‘çŠ¶æ€
    ComplaintDeposits::<T>::mutate(complaint_id, |maybe_info| {
        if let Some(info) = maybe_info {
            info.status = DepositStatus::Released;
        }
    });

    // è§¦å‘äº‹ä»¶
    Self::deposit_event(Event::DepositReleased {
        complaint_id,
        depositor: deposit_info.depositor,
        amount: deposit_info.amount,
        reason,
    });

    Ok(())
}

pub enum ReleaseReason {
    ComplaintApproved,      // æŠ•è¯‰è¢«æ‰¹å‡†
    ComplaintWithdrawn,     // æŠ•è¯‰æ’¤å›ï¼ˆéƒ¨åˆ†åœºæ™¯å…¨é¢é€€è¿˜ï¼‰
    ReviewPeriodExpired,    // å®¡æ ¸æœŸè¶…æ—¶
    SystemError,            // ç³»ç»Ÿé”™è¯¯
}
```

### æŠ¼é‡‘ç½šæ²¡æœºåˆ¶

```rust
/// ç½šæ²¡æŠ¼é‡‘
pub fn slash_complaint_deposit(
    complaint_id: u64,
    slash_percentage: Perbill,
    slash_reason: SlashReason,
) -> DispatchResult {
    let deposit_info = ComplaintDeposits::<T>::get(complaint_id)
        .ok_or(Error::<T>::DepositNotFound)?;

    ensure!(
        deposit_info.status == DepositStatus::Locked,
        Error::<T>::DepositAlreadyProcessed
    );

    // è®¡ç®—ç½šæ²¡é‡‘é¢
    let slashed_amount = slash_percentage.mul_floor(deposit_info.amount);
    let returned_amount = deposit_info.amount.saturating_sub(slashed_amount);

    // ç½šæ²¡éƒ¨åˆ†è½¬å…¥å›½åº“
    if slashed_amount > Zero::zero() {
        let treasury_account = T::TreasuryAccount::get();

        T::Fungible::transfer_on_hold(
            &HoldReason::ComplaintDeposit.into(),
            &deposit_info.depositor,
            &treasury_account,
            slashed_amount,
            Precision::Exact,
            Restriction::Free,
            Fortitude::Force,
        )?;
    }

    // å‰©ä½™éƒ¨åˆ†é‡Šæ”¾
    if returned_amount > Zero::zero() {
        T::Fungible::release(
            &HoldReason::ComplaintDeposit.into(),
            &deposit_info.depositor,
            returned_amount,
            Precision::Exact,
        )?;
    }

    // æ›´æ–°æŠ¼é‡‘çŠ¶æ€
    let new_status = if returned_amount == Zero::zero() {
        DepositStatus::FullySlashed
    } else {
        DepositStatus::PartiallyReturned { slashed_amount }
    };

    ComplaintDeposits::<T>::mutate(complaint_id, |maybe_info| {
        if let Some(info) = maybe_info {
            info.status = new_status;
        }
    });

    // è§¦å‘äº‹ä»¶
    Self::deposit_event(Event::DepositSlashed {
        complaint_id,
        depositor: deposit_info.depositor,
        slashed_amount,
        returned_amount,
        reason: slash_reason,
    });

    Ok(())
}

pub enum SlashReason {
    ComplaintRejected,       // æŠ•è¯‰è¢«é©³å›
    MaliciousComplaint,      // æ¶æ„æŠ•è¯‰
    FalseEvidence,          // è™šå‡è¯æ®
    ComplaintAbandoned,     // æŠ•è¯‰è¢«é—å¼ƒ
    RuleViolation,          // è¿åè§„åˆ™
}
```

---

## ğŸ’¸ ç½šæ²¡æ¯”ä¾‹è®¾è®¡

### åˆ†çº§ç½šæ²¡è§„åˆ™

```rust
/// ç½šæ²¡æ¯”ä¾‹é…ç½®
pub struct SlashingSchedule {
    // æŒ‰ç»“æœåˆ†ç±»
    pub rejected_complaint_slash: Perbill,        // æŠ•è¯‰è¢«é©³å›ï¼š30%
    pub withdrawn_complaint_slash: Perbill,       // ä¸»åŠ¨æ’¤å›ï¼š10%
    pub malicious_complaint_slash: Perbill,       // æ¶æ„æŠ•è¯‰ï¼š100%
    pub expired_complaint_slash: Perbill,         // è¶…æ—¶æœªå“åº”ï¼š20%

    // æŒ‰è¯æ®è´¨é‡åˆ†ç±»
    pub false_evidence_slash: Perbill,            // è™šå‡è¯æ®ï¼š80%
    pub insufficient_evidence_slash: Perbill,      // è¯æ®ä¸è¶³ï¼š40%
    pub quality_evidence_bonus: Balance,          // ä¼˜è´¨è¯æ®å¥–åŠ±ï¼š20 DUST

    // æŒ‰æŠ•ç¥¨å‡†ç¡®æ€§åˆ†ç±»
    pub incorrect_vote_slash: Perbill,            // æŠ•ç¥¨é”™è¯¯ï¼š5%
    pub abstain_penalty: Perbill,                 // å¼ƒæƒæƒ©ç½šï¼š2%
}

impl Default for SlashingSchedule {
    fn default() -> Self {
        Self {
            rejected_complaint_slash: Perbill::from_percent(30),
            withdrawn_complaint_slash: Perbill::from_percent(10),
            malicious_complaint_slash: Perbill::from_percent(100),
            expired_complaint_slash: Perbill::from_percent(20),

            false_evidence_slash: Perbill::from_percent(80),
            insufficient_evidence_slash: Perbill::from_percent(40),
            quality_evidence_bonus: 20 * DUST,

            incorrect_vote_slash: Perbill::from_percent(5),
            abstain_penalty: Perbill::from_percent(2),
        }
    }
}
```

### ç´¯è¿›ç½šæ²¡æœºåˆ¶

```rust
/// ç´¯è¿›ç½šæ²¡è®¡ç®—
pub fn calculate_progressive_slash(
    base_slash_percentage: Perbill,
    offense_history: &OffenseHistory,
) -> Perbill {
    let recent_offenses = offense_history.offenses_last_90_days;

    // ç´¯è¿›ç³»æ•°
    let progressive_multiplier = match recent_offenses {
        0..=2 => Perbill::from_percent(100),  // 1.0å€
        3..=5 => Perbill::from_percent(125),  // 1.25å€
        6..=10 => Perbill::from_percent(150), // 1.5å€
        11..=20 => Perbill::from_percent(180), // 1.8å€
        _ => Perbill::from_percent(200),      // 2.0å€ï¼ˆå°é¡¶ï¼‰
    };

    // æ—¶é—´è¡°å‡
    let time_since_last = offense_history.blocks_since_last_offense;
    let decay_factor = if time_since_last > 100_800 {  // 7å¤©ä»¥ä¸Š
        Perbill::from_percent(80)  // å‡å…20%
    } else {
        Perbill::from_percent(100)
    };

    // ç»¼åˆè®¡ç®—
    let adjusted_slash = base_slash_percentage
        .saturating_mul(progressive_multiplier)
        .saturating_mul(decay_factor);

    // æœ€é«˜ä¸è¶…è¿‡100%
    adjusted_slash.min(Perbill::from_percent(100))
}

pub struct OffenseHistory {
    pub total_offenses: u32,
    pub offenses_last_90_days: u32,
    pub blocks_since_last_offense: BlockNumber,
    pub most_serious_offense: SlashReason,
}
```

---

## ğŸ å¥–åŠ±åˆ†é…æœºåˆ¶

### ä¸¾æŠ¥æˆåŠŸå¥–åŠ±

```rust
/// ä¸¾æŠ¥æˆåŠŸåçš„å¥–åŠ±åˆ†é…
pub fn distribute_complaint_rewards(
    complaint_id: u64,
    complaint_result: ComplaintResult,
) -> DispatchResult {
    let deposit_info = ComplaintDeposits::<T>::get(complaint_id)
        .ok_or(Error::<T>::DepositNotFound)?;

    match complaint_result {
        ComplaintResult::Approved => {
            // 1. å…¨é¢é€€è¿˜æŠ¼é‡‘
            Self::release_complaint_deposit(complaint_id, ReleaseReason::ComplaintApproved)?;

            // 2. åŸºç¡€å¥–åŠ±ï¼ˆ20 DUSTï¼‰
            let base_reward = 20 * DUST;

            // 3. è¯æ®è´¨é‡å¥–åŠ±ï¼ˆ0-30 DUSTï¼‰
            let evidence_quality_bonus = calculate_evidence_quality_bonus(complaint_id);

            // 4. å¿«é€Ÿå“åº”å¥–åŠ±ï¼ˆ0-10 DUSTï¼‰
            let speed_bonus = calculate_speed_bonus(complaint_id);

            // 5. ç¤¾ä¼šå½±å“å¥–åŠ±ï¼ˆ0-50 DUSTï¼‰
            let impact_bonus = calculate_social_impact_bonus(complaint_id);

            // æ€»å¥–åŠ±
            let total_reward = base_reward
                .saturating_add(evidence_quality_bonus)
                .saturating_add(speed_bonus)
                .saturating_add(impact_bonus);

            // ä»å¥–åŠ±æ± å‘æ”¾
            let reward_pool = T::RewardPoolAccount::get();
            T::Fungible::transfer(
                &reward_pool,
                &deposit_info.depositor,
                total_reward,
                Preservation::Expendable,
            )?;

            // æ›´æ–°ä¿¡èª‰åˆ†
            T::ReputationProvider::add_reputation(
                &deposit_info.depositor,
                20,  // +20åˆ†
            );

            // è§¦å‘äº‹ä»¶
            Self::deposit_event(Event::ComplaintRewardDistributed {
                complaint_id,
                recipient: deposit_info.depositor,
                total_reward,
                breakdown: RewardBreakdown {
                    base_reward,
                    evidence_quality_bonus,
                    speed_bonus,
                    impact_bonus,
                },
            });
        }

        ComplaintResult::Rejected { reason } => {
            // éƒ¨åˆ†ç½šæ²¡æŠ¼é‡‘
            let slash_percentage = match reason {
                RejectReason::InsufficientEvidence => Perbill::from_percent(30),
                RejectReason::Unsubstantiated => Perbill::from_percent(40),
                RejectReason::Malicious => Perbill::from_percent(100),
            };

            Self::slash_complaint_deposit(
                complaint_id,
                slash_percentage,
                SlashReason::ComplaintRejected,
            )?;

            // æ‰£é™¤ä¿¡èª‰åˆ†
            let reputation_penalty = match reason {
                RejectReason::InsufficientEvidence => -5,
                RejectReason::Unsubstantiated => -10,
                RejectReason::Malicious => -50,
            };

            T::ReputationProvider::add_reputation(
                &deposit_info.depositor,
                reputation_penalty,
            );
        }

        ComplaintResult::Withdrawn => {
            // è½»å¾®ç½šæ²¡ï¼ˆ10%ï¼‰
            Self::slash_complaint_deposit(
                complaint_id,
                Perbill::from_percent(10),
                SlashReason::ComplaintWithdrawn,
            )?;
        }
    }

    Ok(())
}

pub enum ComplaintResult {
    Approved,
    Rejected { reason: RejectReason },
    Withdrawn,
}

pub enum RejectReason {
    InsufficientEvidence,  // è¯æ®ä¸è¶³
    Unsubstantiated,      // æ— æ³•è¯å®
    Malicious,            // æ¶æ„ä¸¾æŠ¥
}
```

### è¯æ®è´¨é‡è¯„åˆ†å¥–åŠ±

```rust
/// è®¡ç®—è¯æ®è´¨é‡å¥–åŠ±ï¼ˆ0-30 DUSTï¼‰
fn calculate_evidence_quality_bonus(complaint_id: u64) -> Balance {
    let evidence_score = T::EvidenceProvider::get_evidence_quality_score(complaint_id);

    // è¯æ®è¯„åˆ† 0-100
    // 60-70: 5 DUST
    // 70-80: 10 DUST
    // 80-90: 20 DUST
    // 90-100: 30 DUST

    let bonus = if evidence_score >= 90 {
        30 * DUST
    } else if evidence_score >= 80 {
        20 * DUST
    } else if evidence_score >= 70 {
        10 * DUST
    } else if evidence_score >= 60 {
        5 * DUST
    } else {
        0
    };

    bonus
}

/// è¯æ®è´¨é‡è¯„åˆ†æ ‡å‡†
pub struct EvidenceQualityMetrics {
    pub completeness: u8,        // å®Œæ•´æ€§ï¼ˆ0-100ï¼‰
    pub authenticity: u8,        // çœŸå®æ€§ï¼ˆ0-100ï¼‰
    pub relevance: u8,          // ç›¸å…³æ€§ï¼ˆ0-100ï¼‰
    pub clarity: u8,            // æ¸…æ™°åº¦ï¼ˆ0-100ï¼‰
    pub timeliness: u8,         // æ—¶æ•ˆæ€§ï¼ˆ0-100ï¼‰
}

impl EvidenceQualityMetrics {
    pub fn calculate_overall_score(&self) -> u8 {
        // åŠ æƒå¹³å‡
        let weighted_sum =
            self.completeness * 25 +
            self.authenticity * 30 +
            self.relevance * 20 +
            self.clarity * 15 +
            self.timeliness * 10;

        (weighted_sum / 100).min(100)
    }
}
```

### å¿«é€Ÿå“åº”å¥–åŠ±

```rust
/// è®¡ç®—å¿«é€Ÿå“åº”å¥–åŠ±ï¼ˆ0-10 DUSTï¼‰
fn calculate_speed_bonus(complaint_id: u64) -> Balance {
    let complaint = Complaints::<T>::get(complaint_id).unwrap();
    let execution_time = complaint.executed_at.unwrap_or(BlockNumber::zero());
    let submit_time = complaint.submitted_at;

    let processing_blocks = execution_time.saturating_sub(submit_time);
    let processing_hours = processing_blocks / (60 * 10);  // å‡è®¾6ç§’ä¸€ä¸ªå—

    // å¤„ç†æ—¶é—´å¥–åŠ±ï¼š
    // 0-24å°æ—¶: 10 DUST
    // 24-48å°æ—¶: 7 DUST
    // 48-72å°æ—¶: 5 DUST
    // 72-168å°æ—¶(7å¤©): 3 DUST
    // 7å¤©ä»¥ä¸Š: 0

    let bonus = if processing_hours <= 24 {
        10 * DUST
    } else if processing_hours <= 48 {
        7 * DUST
    } else if processing_hours <= 72 {
        5 * DUST
    } else if processing_hours <= 168 {
        3 * DUST
    } else {
        0
    };

    bonus
}
```

### ç¤¾ä¼šå½±å“å¥–åŠ±

```rust
/// è®¡ç®—ç¤¾ä¼šå½±å“å¥–åŠ±ï¼ˆ0-50 DUSTï¼‰
fn calculate_social_impact_bonus(complaint_id: u64) -> Balance {
    let impact_metrics = T::ImpactAnalyzer::analyze_social_impact(complaint_id);

    // å½±å“åŠ›æŒ‡æ ‡ï¼š
    // 1. å—å½±å“ç”¨æˆ·æ•°é‡
    // 2. å†…å®¹ä¼ æ’­èŒƒå›´
    // 3. èˆ†è®ºå…³æ³¨åº¦
    // 4. æ³•å¾‹åˆè§„é‡è¦æ€§

    let user_impact_score = calculate_user_impact_score(impact_metrics.affected_users);
    let reach_score = calculate_reach_score(impact_metrics.content_reach);
    let attention_score = calculate_attention_score(impact_metrics.public_attention);
    let compliance_score = calculate_compliance_score(impact_metrics.legal_importance);

    // åŠ æƒç»¼åˆè¯„åˆ†ï¼ˆ0-100ï¼‰
    let overall_score =
        user_impact_score * 30 / 100 +
        reach_score * 25 / 100 +
        attention_score * 25 / 100 +
        compliance_score * 20 / 100;

    // æ˜ å°„åˆ°å¥–åŠ±é‡‘é¢
    // 0-30åˆ†: 0
    // 30-50åˆ†: 10 DUST
    // 50-70åˆ†: 20 DUST
    // 70-85åˆ†: 35 DUST
    // 85-100åˆ†: 50 DUST

    let bonus = if overall_score >= 85 {
        50 * DUST
    } else if overall_score >= 70 {
        35 * DUST
    } else if overall_score >= 50 {
        20 * DUST
    } else if overall_score >= 30 {
        10 * DUST
    } else {
        0
    };

    bonus
}

pub struct SocialImpactMetrics {
    pub affected_users: u32,        // å—å½±å“ç”¨æˆ·æ•°
    pub content_reach: u32,         // å†…å®¹è§¦è¾¾äººæ•°
    pub public_attention: u32,      // å…¬ä¼—å…³æ³¨åº¦ï¼ˆæµè§ˆã€è¯„è®ºç­‰ï¼‰
    pub legal_importance: u8,       // æ³•å¾‹é‡è¦æ€§ï¼ˆ0-100ï¼‰
}
```

---

## ğŸ’§ æŠ¼é‡‘æ± ç®¡ç†

### å¥–åŠ±æ± è®¾è®¡

```rust
/// å¥–åŠ±æ± ç®¡ç†
pub struct RewardPool<T: Config> {
    /// æ€»æ± å®¹é‡
    pub total_capacity: BalanceOf<T>,

    /// å½“å‰ä½™é¢
    pub current_balance: BalanceOf<T>,

    /// è¡¥å……æ¥æº
    pub funding_sources: Vec<FundingSource<T>>,

    /// æ”¯å‡ºç»Ÿè®¡
    pub disbursement_stats: DisbursementStats<T>,
}

pub enum FundingSource<T: Config> {
    /// ç½šæ²¡èµ„é‡‘ï¼ˆå æ¯”70%ï¼‰
    SlashedDeposits,

    /// å›½åº“æ‹¨æ¬¾ï¼ˆå æ¯”20%ï¼‰
    TreasuryGrant,

    /// ç¤¾åŒºæèµ ï¼ˆå æ¯”10%ï¼‰
    CommunityDonations,

    /// å¹³å°æ‰‹ç»­è´¹åˆ†æˆ
    PlatformFees { percentage: Perbill },
}

pub struct DisbursementStats<T: Config> {
    pub total_distributed: BalanceOf<T>,
    pub distributed_last_30_days: BalanceOf<T>,
    pub unique_recipients: u32,
    pub average_reward: BalanceOf<T>,
}

/// å¥–åŠ±æ± è¡¥å……æœºåˆ¶
impl<T: Config> Pallet<T> {
    /// ä»ç½šæ²¡èµ„é‡‘è¡¥å……å¥–åŠ±æ± 
    pub fn replenish_from_slashed(amount: BalanceOf<T>) -> DispatchResult {
        let reward_pool = T::RewardPoolAccount::get();
        let treasury = T::TreasuryAccount::get();

        // 70%è¿›å…¥å¥–åŠ±æ± ï¼Œ30%è¿›å…¥å›½åº“
        let to_reward_pool = Perbill::from_percent(70).mul_floor(amount);
        let to_treasury = amount.saturating_sub(to_reward_pool);

        // è½¬è´¦åˆ°å¥–åŠ±æ± 
        T::Fungible::transfer(
            &treasury,
            &reward_pool,
            to_reward_pool,
            Preservation::Expendable,
        )?;

        // æ›´æ–°ç»Ÿè®¡
        RewardPoolBalance::<T>::mutate(|balance| {
            *balance = balance.saturating_add(to_reward_pool);
        });

        Self::deposit_event(Event::RewardPoolReplenished {
            amount: to_reward_pool,
            source: FundingSource::SlashedDeposits,
        });

        Ok(())
    }

    /// å®šæœŸå›½åº“æ‹¨æ¬¾
    pub fn treasury_grant(amount: BalanceOf<T>) -> DispatchResult {
        let reward_pool = T::RewardPoolAccount::get();
        let treasury = T::TreasuryAccount::get();

        T::Fungible::transfer(
            &treasury,
            &reward_pool,
            amount,
            Preservation::Expendable,
        )?;

        RewardPoolBalance::<T>::mutate(|balance| {
            *balance = balance.saturating_add(amount);
        });

        Self::deposit_event(Event::RewardPoolReplenished {
            amount,
            source: FundingSource::TreasuryGrant,
        });

        Ok(())
    }

    /// ç¤¾åŒºæèµ 
    pub fn accept_community_donation(
        donor: T::AccountId,
        amount: BalanceOf<T>,
    ) -> DispatchResult {
        let reward_pool = T::RewardPoolAccount::get();

        T::Fungible::transfer(
            &donor,
            &reward_pool,
            amount,
            Preservation::Expendable,
        )?;

        RewardPoolBalance::<T>::mutate(|balance| {
            *balance = balance.saturating_add(amount);
        });

        // è®°å½•æèµ è€…
        CommunityDonors::<T>::mutate(&donor, |donated| {
            *donated = donated.saturating_add(amount);
        });

        Self::deposit_event(Event::CommunityDonationReceived {
            donor,
            amount,
        });

        Ok(())
    }
}
```

### èµ„é‡‘ç›‘æ§ä¸é¢„è­¦

```rust
/// èµ„é‡‘æ± å¥åº·æ£€æŸ¥
pub fn check_reward_pool_health() -> PoolHealthStatus {
    let current_balance = RewardPoolBalance::<T>::get();
    let average_monthly_disbursement = calculate_average_monthly_disbursement();

    // è®¡ç®—å¯ç»´æŒæœˆæ•°
    let months_sustainable = if average_monthly_disbursement > Zero::zero() {
        current_balance / average_monthly_disbursement
    } else {
        u32::MAX
    };

    // å¥åº·çŠ¶æ€è¯„ä¼°
    let status = if months_sustainable >= 12 {
        PoolHealthStatus::Healthy
    } else if months_sustainable >= 6 {
        PoolHealthStatus::Adequate
    } else if months_sustainable >= 3 {
        PoolHealthStatus::Warning
    } else {
        PoolHealthStatus::Critical
    };

    // å¦‚æœçŠ¶æ€ä¸ä½³ï¼Œè§¦å‘é¢„è­¦
    if matches!(status, PoolHealthStatus::Warning | PoolHealthStatus::Critical) {
        Self::deposit_event(Event::RewardPoolHealthWarning {
            current_balance,
            months_sustainable,
            status: status.clone(),
        });

        // è§¦å‘è‡ªåŠ¨è¡¥å……æœºåˆ¶
        Self::trigger_auto_replenishment(status.clone())?;
    }

    status
}

#[derive(Clone, PartialEq, Eq, RuntimeDebug)]
pub enum PoolHealthStatus {
    Healthy,      // â‰¥12ä¸ªæœˆ
    Adequate,     // 6-12ä¸ªæœˆ
    Warning,      // 3-6ä¸ªæœˆ
    Critical,     // <3ä¸ªæœˆ
}

/// è‡ªåŠ¨è¡¥å……è§¦å‘
fn trigger_auto_replenishment(status: PoolHealthStatus) -> DispatchResult {
    let target_months = 12u32;
    let current_balance = RewardPoolBalance::<T>::get();
    let average_monthly = calculate_average_monthly_disbursement();
    let target_balance = average_monthly.saturating_mul(target_months.into());
    let needed_amount = target_balance.saturating_sub(current_balance);

    // æäº¤å›½åº“æ‹¨æ¬¾ææ¡ˆ
    let proposal = Call::treasury_grant { amount: needed_amount };

    T::GovernanceOrigin::try_origin(frame_system::RawOrigin::Root.into())
        .map(|_| {
            // å¦‚æœæ˜¯Rootç›´æ¥æ‰§è¡Œ
            Self::treasury_grant(needed_amount)
        })
        .unwrap_or_else(|_| {
            // å¦åˆ™æäº¤æ²»ç†ææ¡ˆ
            T::ProposalProvider::submit_treasury_proposal(proposal)
        })
}
```

---

## ğŸ“‹ æŠ¼é‡‘é€€è¿˜æµç¨‹

### æ ‡å‡†é€€è¿˜æµç¨‹

```rust
/// æŠ¼é‡‘é€€è¿˜æµç¨‹çŠ¶æ€æœº
pub enum DepositReturnFlow {
    /// æ­¥éª¤1: æ²»ç†å†³ç­–å®Œæˆ
    DecisionMade {
        complaint_id: u64,
        decision: GovernanceDecision,
    },

    /// æ­¥éª¤2: è®¡ç®—ç½šæ²¡/å¥–åŠ±
    CalculateOutcome {
        complaint_id: u64,
        slash_percentage: Perbill,
        reward_amount: Balance,
    },

    /// æ­¥éª¤3: æ‰§è¡Œèµ„é‡‘æ“ä½œ
    ExecuteTransfer {
        complaint_id: u64,
        operations: Vec<TransferOperation>,
    },

    /// æ­¥éª¤4: æ›´æ–°è®°å½•
    UpdateRecords {
        complaint_id: u64,
        final_status: DepositStatus,
    },

    /// æ­¥éª¤5: é€šçŸ¥ç”¨æˆ·
    NotifyUser {
        complaint_id: u64,
        notification: UserNotification,
    },
}

pub struct TransferOperation {
    pub operation_type: OperationType,
    pub from: AccountId,
    pub to: AccountId,
    pub amount: Balance,
}

pub enum OperationType {
    ReleaseDeposit,       // é‡Šæ”¾æŠ¼é‡‘
    SlashToTreasury,     // ç½šæ²¡åˆ°å›½åº“
    RewardFromPool,      // ä»å¥–åŠ±æ± å‘æ”¾
    RefundPartial,       // éƒ¨åˆ†é€€è¿˜
}

/// æ‰§è¡Œå®Œæ•´çš„æŠ¼é‡‘é€€è¿˜æµç¨‹
pub fn process_deposit_return(
    complaint_id: u64,
    decision: GovernanceDecision,
) -> DispatchResult {
    // æ­¥éª¤1: éªŒè¯æŠ•è¯‰çŠ¶æ€
    let complaint = Complaints::<T>::get(complaint_id)
        .ok_or(Error::<T>::ComplaintNotFound)?;
    ensure!(
        complaint.status == ComplaintStatus::UnderReview ||
        complaint.status == ComplaintStatus::Approved,
        Error::<T>::InvalidComplaintStatus
    );

    // æ­¥éª¤2: è·å–æŠ¼é‡‘ä¿¡æ¯
    let deposit_info = ComplaintDeposits::<T>::get(complaint_id)
        .ok_or(Error::<T>::DepositNotFound)?;

    // æ­¥éª¤3: æ ¹æ®å†³ç­–è®¡ç®—ç»“æœ
    let outcome = calculate_deposit_outcome(&decision, &complaint, &deposit_info)?;

    // æ­¥éª¤4: æ‰§è¡Œèµ„é‡‘æ“ä½œ
    let mut transfer_results = Vec::new();
    for operation in outcome.operations.iter() {
        let result = execute_transfer_operation(operation)?;
        transfer_results.push(result);
    }

    // æ­¥éª¤5: æ›´æ–°æŠ¼é‡‘çŠ¶æ€
    ComplaintDeposits::<T>::mutate(complaint_id, |maybe_info| {
        if let Some(info) = maybe_info {
            info.status = outcome.final_status.clone();
        }
    });

    // æ­¥éª¤6: æ›´æ–°ä¿¡èª‰åˆ†
    update_reputation_score(
        &deposit_info.depositor,
        &decision,
        outcome.reputation_delta,
    )?;

    // æ­¥éª¤7: å‘é€é€šçŸ¥
    send_deposit_return_notification(
        &deposit_info.depositor,
        complaint_id,
        &outcome,
    )?;

    // æ­¥éª¤8: è§¦å‘äº‹ä»¶
    Self::deposit_event(Event::DepositReturnProcessed {
        complaint_id,
        depositor: deposit_info.depositor,
        outcome: outcome.clone(),
    });

    Ok(())
}

pub struct DepositOutcome {
    pub final_status: DepositStatus,
    pub operations: Vec<TransferOperation>,
    pub reputation_delta: i32,
    pub notification_message: Vec<u8>,
}
```

### å¿«é€Ÿé€€è¿˜é€šé“

```rust
/// å¿«é€Ÿé€€è¿˜é€šé“ï¼ˆç‰¹æ®Šæƒ…å†µï¼‰
pub fn fast_track_deposit_return(
    complaint_id: u64,
    reason: FastTrackReason,
) -> DispatchResult {
    // éªŒè¯å¿«é€Ÿé€€è¿˜èµ„æ ¼
    ensure!(
        is_eligible_for_fast_track(complaint_id, &reason),
        Error::<T>::NotEligibleForFastTrack
    );

    let deposit_info = ComplaintDeposits::<T>::get(complaint_id)
        .ok_or(Error::<T>::DepositNotFound)?;

    // ç›´æ¥é‡Šæ”¾å…¨éƒ¨æŠ¼é‡‘
    T::Fungible::release(
        &HoldReason::ComplaintDeposit.into(),
        &deposit_info.depositor,
        deposit_info.amount,
        Precision::Exact,
    )?;

    // æ›´æ–°çŠ¶æ€
    ComplaintDeposits::<T>::mutate(complaint_id, |maybe_info| {
        if let Some(info) = maybe_info {
            info.status = DepositStatus::Released;
        }
    });

    Self::deposit_event(Event::FastTrackDepositReturn {
        complaint_id,
        depositor: deposit_info.depositor,
        amount: deposit_info.amount,
        reason,
    });

    Ok(())
}

pub enum FastTrackReason {
    SystemError,              // ç³»ç»Ÿé”™è¯¯
    DuplicateComplaint,      // é‡å¤æŠ•è¯‰
    InvalidTarget,           // æ— æ•ˆç›®æ ‡
    ProcessingTimeout,       // å¤„ç†è¶…æ—¶
    EmergencyWithdrawal,     // ç´§æ€¥æ’¤å›
}

fn is_eligible_for_fast_track(
    complaint_id: u64,
    reason: &FastTrackReason,
) -> bool {
    match reason {
        FastTrackReason::SystemError => {
            // æ£€æŸ¥æ˜¯å¦æœ‰ç³»ç»Ÿé”™è¯¯è®°å½•
            SystemErrors::<T>::contains_key(complaint_id)
        }
        FastTrackReason::DuplicateComplaint => {
            // æ£€æŸ¥æ˜¯å¦æ˜¯é‡å¤æŠ•è¯‰
            let complaint = Complaints::<T>::get(complaint_id).unwrap();
            check_duplicate_complaint(&complaint)
        }
        FastTrackReason::ProcessingTimeout => {
            // æ£€æŸ¥æ˜¯å¦è¶…è¿‡æœ€å¤§å¤„ç†æ—¶é™
            let complaint = Complaints::<T>::get(complaint_id).unwrap();
            let current_block = <frame_system::Pallet<T>>::block_number();
            let elapsed = current_block.saturating_sub(complaint.submitted_at);
            elapsed > T::MaxProcessingBlocks::get()
        }
        _ => false,
    }
}
```

---

## ğŸ“Š ç›‘æ§ä¸ç»Ÿè®¡

### æŠ¼é‡‘ç³»ç»Ÿç›‘æ§æŒ‡æ ‡

```rust
/// æŠ¼é‡‘ç³»ç»Ÿç›‘æ§æŒ‡æ ‡
pub struct DepositSystemMetrics {
    // èµ„é‡‘æŒ‡æ ‡
    pub total_deposits_locked: Balance,
    pub total_deposits_released: Balance,
    pub total_deposits_slashed: Balance,
    pub total_rewards_distributed: Balance,

    // ç”¨æˆ·æŒ‡æ ‡
    pub active_depositors: u32,
    pub successful_complainants: u32,
    pub penalized_users: u32,

    // æ•ˆç‡æŒ‡æ ‡
    pub average_lock_duration: BlockNumber,
    pub average_processing_time: BlockNumber,
    pub fast_track_usage_rate: Perbill,

    // å¥åº·æŒ‡æ ‡
    pub reward_pool_balance: Balance,
    pub treasury_balance: Balance,
    pub pool_sustainability_months: u32,
}

/// è·å–ç³»ç»ŸæŒ‡æ ‡
pub fn get_deposit_system_metrics(
    time_range: TimeRange,
) -> DepositSystemMetrics {
    DepositSystemMetrics {
        total_deposits_locked: calculate_total_locked(time_range),
        total_deposits_released: calculate_total_released(time_range),
        total_deposits_slashed: calculate_total_slashed(time_range),
        total_rewards_distributed: calculate_total_rewards(time_range),

        active_depositors: count_active_depositors(time_range),
        successful_complainants: count_successful_complainants(time_range),
        penalized_users: count_penalized_users(time_range),

        average_lock_duration: calculate_avg_lock_duration(time_range),
        average_processing_time: calculate_avg_processing_time(time_range),
        fast_track_usage_rate: calculate_fast_track_rate(time_range),

        reward_pool_balance: RewardPoolBalance::<T>::get(),
        treasury_balance: get_treasury_balance(),
        pool_sustainability_months: calculate_sustainability_months(),
    }
}

pub enum TimeRange {
    Last24Hours,
    Last7Days,
    Last30Days,
    Last90Days,
    AllTime,
    Custom { start: BlockNumber, end: BlockNumber },
}
```

### å¼‚å¸¸æ£€æµ‹ä¸å‘Šè­¦

```rust
/// å¼‚å¸¸æ£€æµ‹ç³»ç»Ÿ
pub struct AnomalyDetector {
    /// å¼‚å¸¸é˜ˆå€¼é…ç½®
    pub thresholds: AnomalyThresholds,

    /// æ£€æµ‹ç»“æœ
    pub detected_anomalies: Vec<Anomaly>,
}

pub struct AnomalyThresholds {
    pub abnormal_deposit_spike_threshold: f64,        // æŠ¼é‡‘æ¿€å¢é˜ˆå€¼ï¼š3å€æ ‡å‡†å·®
    pub abnormal_slash_rate_threshold: Perbill,       // å¼‚å¸¸ç½šæ²¡ç‡ï¼š>50%
    pub reward_pool_depletion_threshold: Perbill,     // å¥–åŠ±æ± è€—å°½é˜ˆå€¼ï¼š<20%
    pub processing_delay_threshold: BlockNumber,       // å¤„ç†å»¶è¿Ÿé˜ˆå€¼ï¼š>14å¤©
}

pub struct Anomaly {
    pub anomaly_type: AnomalyType,
    pub severity: SeverityLevel,
    pub detected_at: BlockNumber,
    pub description: Vec<u8>,
    pub suggested_action: Vec<u8>,
}

pub enum AnomalyType {
    UnusualDepositVolume,      // å¼‚å¸¸æŠ¼é‡‘é‡
    HighSlashRate,             // é«˜ç½šæ²¡ç‡
    RewardPoolDepleting,       // å¥–åŠ±æ± è€—å°½
    ProcessingBacklog,         // å¤„ç†ç§¯å‹
    SuspiciousPattern,         // å¯ç–‘æ¨¡å¼
}

/// æ‰§è¡Œå¼‚å¸¸æ£€æµ‹
pub fn detect_anomalies() -> Vec<Anomaly> {
    let mut anomalies = Vec::new();

    // æ£€æµ‹1: æŠ¼é‡‘é‡å¼‚å¸¸
    if let Some(anomaly) = detect_deposit_volume_anomaly() {
        anomalies.push(anomaly);
    }

    // æ£€æµ‹2: ç½šæ²¡ç‡å¼‚å¸¸
    if let Some(anomaly) = detect_slash_rate_anomaly() {
        anomalies.push(anomaly);
    }

    // æ£€æµ‹3: å¥–åŠ±æ± å¥åº·
    if let Some(anomaly) = detect_reward_pool_anomaly() {
        anomalies.push(anomaly);
    }

    // æ£€æµ‹4: å¤„ç†å»¶è¿Ÿ
    if let Some(anomaly) = detect_processing_delay_anomaly() {
        anomalies.push(anomaly);
    }

    anomalies
}
```

---

## ğŸ”§ Runtime é…ç½®ç¤ºä¾‹

### å®Œæ•´é…ç½®

```rust
// runtime/src/configs/governance_deposit.rs

use frame_support::parameter_types;

parameter_types! {
    // åŸºç¡€æŠ¼é‡‘å‚æ•°
    pub const MinComplaintDeposit: Balance = 20 * DUST;
    pub const MaxComplaintDeposit: Balance = 200 * DUST;
    pub const DefaultComplaintDeposit: Balance = 50 * DUST;

    // ç½šæ²¡æ¯”ä¾‹
    pub const RejectedComplaintSlash: Perbill = Perbill::from_percent(30);
    pub const WithdrawnComplaintSlash: Perbill = Perbill::from_percent(10);
    pub const MaliciousComplaintSlash: Perbill = Perbill::from_percent(100);

    // å¥–åŠ±å‚æ•°
    pub const BaseComplaintReward: Balance = 20 * DUST;
    pub const MaxComplaintReward: Balance = 110 * DUST;  // 20+30+10+50

    // æ—¶é™å‚æ•°
    pub const MaxDepositLockDuration: BlockNumber = 100_800 * 12;  // çº¦84å¤©
    pub const MaxProcessingBlocks: BlockNumber = 100_800 * 2;      // çº¦14å¤©

    // è´¦æˆ·å‚æ•°
    pub RewardPoolAccountId: AccountId = AccountId::from([10u8; 32]);
    pub TreasuryAccountId: AccountId = AccountId::from([11u8; 32]);
}

impl pallet_governance_deposit::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type RuntimeHoldReason = RuntimeHoldReason;
    type Fungible = Balances;

    // æŠ¼é‡‘å‚æ•°
    type MinComplaintDeposit = MinComplaintDeposit;
    type MaxComplaintDeposit = MaxComplaintDeposit;
    type DefaultComplaintDeposit = DefaultComplaintDeposit;

    // ç½šæ²¡å‚æ•°
    type RejectedComplaintSlash = RejectedComplaintSlash;
    type WithdrawnComplaintSlash = WithdrawnComplaintSlash;
    type MaliciousComplaintSlash = MaliciousComplaintSlash;

    // å¥–åŠ±å‚æ•°
    type BaseComplaintReward = BaseComplaintReward;
    type MaxComplaintReward = MaxComplaintReward;

    // æ—¶é™å‚æ•°
    type MaxDepositLockDuration = MaxDepositLockDuration;
    type MaxProcessingBlocks = MaxProcessingBlocks;

    // è´¦æˆ·å‚æ•°
    type RewardPoolAccount = RewardPoolAccountId;
    type TreasuryAccount = TreasuryAccountId;

    // æä¾›è€…æ¥å£
    type ReputationProvider = ReputationSystem;
    type ComplaintHistory = ComplaintHistoryProvider;
    type EvidenceProvider = Evidence;
    type ImpactAnalyzer = SocialImpactAnalyzer;

    // æ²»ç†æ¥å£
    type GovernanceOrigin = EnsureRoot<AccountId>;
    type ProposalProvider = Collective;

    // æƒé‡
    type WeightInfo = pallet_governance_deposit::weights::SubstrateWeight<Runtime>;
}
```

---

## ğŸ“ æ€»ç»“

### æŠ¼é‡‘æœºåˆ¶æ ¸å¿ƒä¼˜åŠ¿

1. **é˜²å¾¡æ€§è®¾è®¡**ï¼šé€šè¿‡ç»æµé—¨æ§›æœ‰æ•ˆè¿‡æ»¤æ¶æ„æŠ•è¯‰
2. **åŠ¨æ€è°ƒæ•´**ï¼šæ ¹æ®ä¿¡èª‰ã€å†å²ã€å†…å®¹ç­‰å¤šç»´åº¦æ™ºèƒ½è®¡ç®—æŠ¼é‡‘
3. **å…¬å¹³æ¿€åŠ±**ï¼šå¥–åŠ±ä¼˜è´¨ä¸¾æŠ¥ï¼Œæƒ©ç½šæ¶æ„è¡Œä¸º
4. **èµ„é‡‘å®‰å…¨**ï¼šä½¿ç”¨Substrate Holds APIç¡®ä¿æŠ¼é‡‘é”å®šå®‰å…¨
5. **é€æ˜å¯è¿½æº¯**ï¼šæ‰€æœ‰æ“ä½œé“¾ä¸Šè®°å½•ï¼Œå®Œå…¨å…¬å¼€é€æ˜
6. **å¯æŒç»­æ€§**ï¼šå¥–åŠ±æ± å¤šæºè¡¥å……ï¼Œç¡®ä¿é•¿æœŸè¿è¥

### é¢„æœŸæ•ˆæœ

- **æ¶æ„æŠ•è¯‰é™ä½**ï¼š90%ä»¥ä¸Š
- **è¯æ®è´¨é‡æå‡**ï¼šå¹³å‡è´¨é‡åˆ†æé«˜40%
- **å¤„ç†æ•ˆç‡æå‡**ï¼šå¹³å‡å¤„ç†æ—¶é—´ç¼©çŸ­50%
- **ç”¨æˆ·æ»¡æ„åº¦**ï¼š85%ä»¥ä¸Š
- **èµ„é‡‘æ± å¯æŒç»­**ï¼šè‡³å°‘12ä¸ªæœˆå‚¨å¤‡

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0.0
**æœ€åæ›´æ–°**ï¼š2025-11-13
**ç»´æŠ¤å›¢é˜Ÿ**ï¼šStardust æ²»ç†å·¥ä½œç»„
**ç›¸å…³æ–‡æ¡£**ï¼š[é€è€…å†…å®¹å…¬ä¼—æ²»ç†æ–¹æ¡ˆ.md](./é€è€…å†…å®¹å…¬ä¼—æ²»ç†æ–¹æ¡ˆ.md)