# 亲友团成员归属方案设计文档

**创建日期**：2025-11-09
**文档版本**：v1.0
**问题**：亲友团成员应该关联到Grave（墓位）还是Deceased（逝者）？

---

## 一、现状分析

### 1.1 当前实现

根据代码分析，**当前系统已经明确将亲友团关联到Deceased（逝者）**：

**存储结构**：`pallets/deceased/src/lib.rs`

```rust
/// 亲友成员： (DeceasedId, AccountId) -> FriendRecord
pub type FriendsOf<T: Config> = StorageDoubleMap<
    _,
    Blake2_128Concat,
    T::DeceasedId,  // ✅ 第一个key是DeceasedId
    Blake2_128Concat,
    T::AccountId,
    FriendRecord<T>,
    OptionQuery,
>;

/// 亲友计数： DeceasedId -> u32
pub type FriendCount<T: Config> =
    StorageMap<_, Blake2_128Concat, T::DeceasedId, u32, ValueQuery>;

/// 亲友策略：DeceasedId -> FriendPolicy
pub type FriendPolicyOf<T: Config> =
    StorageMap<_, Blake2_128Concat, T::DeceasedId, FriendPolicy<T>, OptionQuery>;
```

**相关Extrinsics**：
- `set_friend_policy(deceased_id, ...)` - 设置逝者的亲友策略
- `join_friend_group(deceased_id)` - 加入逝者的亲友团
- `leave_friend_group(deceased_id)` - 退出逝者的亲友团
- `kick_friend(deceased_id, who)` - 移除逝者亲友团成员
- `set_friend_role(deceased_id, who, role)` - 设置逝者亲友团成员角色

### 1.2 Grave的关注功能状态

**已停用**：`pallets/stardust-grave/src/lib.rs:2268`

```rust
/// 函数级详细中文注释：关注墓位（已停用）。
/// - 方案B：亲友/关注统一回归逝者维度；墓位不再承载关注功能。
```

**设计决策**：系统已经明确采用**方案B**，将社交关系统一归到逝者维度。

---

## 二、为什么选择Deceased而不是Grave？

### 2.1 业务逻辑分析

#### ✅ 选择Deceased的理由

1. **符合现实认知**
   - 现实中人们是逝者的亲友，而不是墓位的亲友
   - "张三的亲友团"比"123号墓位的亲友团"更自然
   - 亲友关系是人与人之间的情感联系

2. **数据稳定性**
   - 逝者可能迁移墓位（`transfer_deceased`）
   - 如果亲友团绑定墓位，迁移时需要同步迁移亲友关系
   - 绑定逝者则迁移时亲友关系自动跟随

3. **合葬场景**
   - 一个墓位可以安葬多个逝者（`Interments: Vec<DeceasedId>`）
   - 每个逝者有各自的亲友团更合理
   - 例如：夫妻合葬，丈夫的亲友≠妻子的亲友

4. **权限管理**
   - 每个逝者有独立的owner
   - 亲友团由逝者的owner管理
   - 权限边界清晰

5. **供奉功能联动**
   - 供奉是针对逝者的（`pallet-memo-offerings`）
   - 供奉会自动加入逝者亲友团（`AutoJoinedFriend`事件）
   - 如果亲友团在墓位维度，供奉逻辑会变复杂

#### ❌ 不选择Grave的理由

1. **墓位是容器概念**
   - 墓位类似"房间"，可以安葬多个逝者
   - 房间的访客≠每个逝者的亲友
   - 关注容器不如关注内容

2. **权限冲突**
   - 一个墓位可能属于多个逝者的共同管理
   - 如果亲友团在墓位维度，谁来管理亲友团？
   - 合葬墓位的权限划分会变得复杂

3. **迁移复杂性**
   - 逝者迁移墓位时，如果亲友团在墓位维度：
     - 需要将该逝者的亲友从旧墓位移除
     - 需要将该逝者的亲友加入新墓位
     - 如果新墓位有其他逝者，权限如何处理？

4. **供奉联动困难**
   - 供奉是针对逝者的，不是针对墓位的
   - 如果亲友团在墓位维度，供奉后如何加入亲友团？
   - 需要额外逻辑判断供奉的是墓位中的哪个逝者

### 2.2 数据一致性分析

| 场景 | Deceased维度 | Grave维度 | 结论 |
|------|--------------|-----------|------|
| 单人墓位 | ✅ 简单清晰 | ✅ 可行 | 两者差异不大 |
| 合葬墓位 | ✅ 每个逝者独立亲友团 | ❌ 无法区分各逝者亲友 | Deceased更合理 |
| 逝者迁移 | ✅ 亲友关系自动跟随 | ❌ 需要迁移亲友关系 | Deceased更稳定 |
| 供奉加入亲友 | ✅ 直接加入对应逝者 | ❌ 无法确定加入哪个逝者 | Deceased更自然 |

---

## 三、推荐方案：亲友团关联Deceased

### 3.1 架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                    Grave（墓位/纪念馆）                        │
│  - 作用：物理容器，可安葬多个逝者                              │
│  - 不直接管理亲友关系                                         │
│  - 已停用关注功能（follow_grave）                             │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ Interments (安葬记录)
                              │
                              ▼
        ┌────────────────────────────────────────────┐
        │       Deceased 1          Deceased 2       │
        │    ┌──────────┐         ┌──────────┐      │
        │    │ 逝者档案  │         │ 逝者档案  │      │
        │    │ - owner  │         │ - owner  │      │
        │    │ - name   │         │ - name   │      │
        │    │ - dates  │         │ - dates  │      │
        │    └──────────┘         └──────────┘      │
        │         │                     │            │
        │         │ 各自的亲友团          │            │
        │         ▼                     ▼            │
        │    ┌──────────┐         ┌──────────┐      │
        │    │ Friends  │         │ Friends  │      │
        │    │ - Alice  │         │ - Bob    │      │
        │    │ - Bob    │         │ - Charlie│      │
        │    │ - Dave   │         │ - Eve    │      │
        │    └──────────┘         └──────────┘      │
        └────────────────────────────────────────────┘
```

### 3.2 核心数据结构

```rust
// =================== 亲友团存储（Deceased维度） ===================

/// 亲友策略：DeceasedId -> FriendPolicy
pub type FriendPolicyOf<T: Config> =
    StorageMap<_, Blake2_128Concat, T::DeceasedId, FriendPolicy<T>>;

/// 亲友成员：(DeceasedId, AccountId) -> FriendRecord
pub type FriendsOf<T: Config> = StorageDoubleMap<
    _,
    Blake2_128Concat, T::DeceasedId,   // 第一维：逝者ID
    Blake2_128Concat, T::AccountId,     // 第二维：账户地址
    FriendRecord<T>,
>;

/// 亲友计数：DeceasedId -> u32
pub type FriendCount<T: Config> =
    StorageMap<_, Blake2_128Concat, T::DeceasedId, u32, ValueQuery>;

/// 待审批：(DeceasedId, AccountId) -> JoinRequest
pub type FriendPending<T: Config> = StorageDoubleMap<
    _,
    Blake2_128Concat, T::DeceasedId,
    Blake2_128Concat, T::AccountId,
    JoinRequest<T>,
>;
```

### 3.3 亲友角色设计

```rust
/// 亲友角色枚举（已实施）
#[derive(Encode, Decode, Clone, Copy, PartialEq, Eq, TypeInfo, MaxEncodedLen)]
pub enum FriendRole {
    Member = 0,  // 普通成员
    Core = 1,    // 核心成员（未来可扩展更多权限）
}
```

**角色权限**：
- **Member**：查看公开资料、留言、供奉
- **Core**：Member权限 + 协助管理（未来可扩展）
- **Owner**：完全控制权（通过`DeceasedOf.owner`，不通过亲友团角色）

### 3.4 核心Extrinsics

#### 管理员操作（Owner专属）

```rust
/// 设置亲友策略
#[pallet::call_index(50)]
pub fn set_friend_policy(
    origin: OriginFor<T>,
    deceased_id: T::DeceasedId,
    require_approval: bool,  // 是否需要审批
    is_private: bool,        // 是否私密（仅管理员可见成员列表）
    max_members: u32,        // 最大成员数
) -> DispatchResult

/// 批准亲友申请
#[pallet::call_index(51)]
pub fn approve_friend_join(
    origin: OriginFor<T>,
    deceased_id: T::DeceasedId,
    who: T::AccountId,
) -> DispatchResult

/// 拒绝亲友申请
#[pallet::call_index(52)]
pub fn reject_friend_join(
    origin: OriginFor<T>,
    deceased_id: T::DeceasedId,
    who: T::AccountId,
) -> DispatchResult

/// 移除亲友成员
#[pallet::call_index(53)]
pub fn kick_friend(
    origin: OriginFor<T>,
    deceased_id: T::DeceasedId,
    who: T::AccountId,
) -> DispatchResult

/// 设置成员角色
#[pallet::call_index(54)]
pub fn set_friend_role(
    origin: OriginFor<T>,
    deceased_id: T::DeceasedId,
    who: T::AccountId,
    role: u8,  // 0=Member, 1=Core
) -> DispatchResult
```

#### 用户操作

```rust
/// 申请加入亲友团
#[pallet::call_index(55)]
pub fn join_friend_group(
    origin: OriginFor<T>,
    deceased_id: T::DeceasedId,
    note: Option<BoundedVec<u8, T::StringLimit>>,
) -> DispatchResult

/// 退出亲友团
#[pallet::call_index(56)]
pub fn leave_friend_group(
    origin: OriginFor<T>,
    deceased_id: T::DeceasedId,
) -> DispatchResult
```

### 3.5 供奉自动加入机制

**业务流程**：
1. 用户通过`pallet-memo-offerings::offer(deceased_id, ...)`供奉逝者
2. Offerings Pallet通过hook回调`pallet-deceased`
3. Deceased Pallet自动将供奉者加入亲友团
4. 触发`AutoJoinedFriend`事件

**实现代码**：`pallets/deceased/src/lib.rs:712-715`

```rust
/// 供奉自动加入亲友团
AutoJoinedFriend {
    deceased_id: T::DeceasedId,
    who: T::AccountId,
},
```

**设计优势**：
- ✅ 供奉即认可，自动建立联系
- ✅ 无需手动申请，体验流畅
- ✅ 如果绑定墓位，合葬场景无法确定加入哪个逝者

---

## 四、特殊场景处理

### 4.1 合葬墓位场景

**场景**：一个墓位安葬了夫妻二人

```
Grave #123
├─ Deceased #1（丈夫）
│  └─ Friends: [Alice, Bob, Charlie]
└─ Deceased #2（妻子）
   └─ Friends: [Alice, Dave, Eve]
```

**处理方式**：
- Alice是两人共同的亲友（在两个亲友团中都有记录）
- Bob和Charlie是丈夫的亲友
- Dave和Eve是妻子的亲友
- 前端可以通过查询墓位的所有逝者，聚合展示所有亲友

**前端查询逻辑**：
```typescript
// 查询墓位中所有逝者的亲友团（聚合视图）
async function getGraveFriends(graveId: number) {
  // 1. 查询墓位的所有逝者
  const interments = await api.query.stardust_grave.interments(graveId)

  // 2. 查询每个逝者的亲友团
  const allFriends = new Map()
  for (const deceasedId of interments) {
    const friends = await api.query.deceased.friendsOf.entries(deceasedId)
    for (const [_, account, record] of friends) {
      if (!allFriends.has(account)) {
        allFriends.set(account, {
          account,
          deceasedIds: [],
          roles: []
        })
      }
      allFriends.get(account).deceasedIds.push(deceasedId)
      allFriends.get(account).roles.push(record.role)
    }
  }

  return Array.from(allFriends.values())
}
```

### 4.2 逝者迁移场景

**场景**：逝者从墓位A迁移到墓位B

```
Before:
  Grave A (#1) → Deceased #10 → Friends [Alice, Bob]
  Grave B (#2) → (empty)

After (transfer_deceased):
  Grave A (#1) → (empty)
  Grave B (#2) → Deceased #10 → Friends [Alice, Bob]  ← 亲友关系自动跟随
```

**优势**：
- ✅ 亲友关系无需任何变更，自动跟随逝者
- ✅ 前端通过`deceased_id`查询亲友，无需关心墓位变化
- ✅ 数据一致性自然保证

### 4.3 墓位关注场景（如果需要）

**需求**：某些用户可能想关注整个墓位（如名人纪念馆）

**推荐方案**：通过前端聚合实现，不在链上实施

```typescript
// 前端实现：关注墓位 = 关注墓位中的所有逝者
async function followGrave(graveId: number, account: string) {
  const interments = await api.query.stardust_grave.interments(graveId)

  for (const deceasedId of interments) {
    await api.tx.deceased.joinFriendGroup(deceasedId, null).signAndSend(account)
  }
}

// 查询是否关注墓位 = 是否关注墓位中的所有逝者
async function isFollowingGrave(graveId: number, account: string): boolean {
  const interments = await api.query.stardust_grave.interments(graveId)

  for (const deceasedId of interments) {
    const isMember = await api.query.deceased.friendsOf(deceasedId, account)
    if (!isMember.isSome) return false
  }

  return interments.length > 0
}
```

**优势**：
- ✅ 无需修改链上逻辑
- ✅ 灵活性高（用户可以选择只关注部分逝者）
- ✅ 数据结构简单（避免Grave和Deceased双重维护）

---

## 五、前端集成建议

### 5.1 逝者详情页（核心场景）

```tsx
// src/features/deceased/DeceasedDetailPage.tsx
function DeceasedDetailPage({ deceasedId }) {
  const [friends, setFriends] = useState([])
  const [friendCount, setFriendCount] = useState(0)
  const [isMember, setIsMember] = useState(false)

  useEffect(() => {
    loadFriends()
  }, [deceasedId])

  const loadFriends = async () => {
    const api = await getApi()

    // 查询亲友计数
    const count = await api.query.deceased.friendCount(deceasedId)
    setFriendCount(count.toNumber())

    // 查询亲友列表
    const entries = await api.query.deceased.friendsOf.entries(deceasedId)
    const friendList = entries.map(([_, account, record]) => ({
      account: account.toString(),
      role: record.role,
      note: record.note,
    }))
    setFriends(friendList)

    // 检查当前用户是否已是亲友
    const myRecord = await api.query.deceased.friendsOf(deceasedId, account)
    setIsMember(myRecord.isSome)
  }

  const handleJoin = async () => {
    const api = await getApi()
    const tx = api.tx.deceased.joinFriendGroup(deceasedId, null)
    await tx.signAndSend(account)
  }

  return (
    <div>
      <h1>{deceased.name}</h1>

      <div className="friends-section">
        <h2>亲友团 ({friendCount}人)</h2>

        {!isMember && (
          <Button onClick={handleJoin}>加入亲友团</Button>
        )}

        <FriendsList friends={friends} />
      </div>
    </div>
  )
}
```

### 5.2 墓位详情页（聚合场景）

```tsx
// src/features/grave/GraveDetailPage.tsx
function GraveDetailPage({ graveId }) {
  const [allFriends, setAllFriends] = useState([])

  useEffect(() => {
    loadAllFriends()
  }, [graveId])

  const loadAllFriends = async () => {
    const api = await getApi()

    // 1. 查询墓位中所有逝者
    const interments = await api.query.stardust_grave.interments(graveId)

    // 2. 聚合所有逝者的亲友
    const friendsMap = new Map()

    for (const deceasedId of interments) {
      const entries = await api.query.deceased.friendsOf.entries(deceasedId)

      for (const [_, account, record] of entries) {
        const accountStr = account.toString()

        if (!friendsMap.has(accountStr)) {
          friendsMap.set(accountStr, {
            account: accountStr,
            deceasedCount: 0,
            deceasedIds: [],
          })
        }

        const friend = friendsMap.get(accountStr)
        friend.deceasedCount++
        friend.deceasedIds.push(deceasedId.toNumber())
      }
    }

    setAllFriends(Array.from(friendsMap.values()))
  }

  return (
    <div>
      <h1>墓位 #{graveId}</h1>

      <div className="grave-friends">
        <h2>所有相关亲友 ({allFriends.length}人)</h2>
        <p>聚合展示所有逝者的亲友</p>

        <FriendsList
          friends={allFriends}
          showDeceasedCount={true}
        />
      </div>
    </div>
  )
}
```

---

## 六、方案对比总结

| 维度 | Deceased维度 | Grave维度 |
|------|--------------|-----------|
| **业务合理性** | ✅ 符合现实认知（人的亲友） | ❌ 不够自然（墓位的访客？） |
| **数据稳定性** | ✅ 逝者迁移时关系自动跟随 | ❌ 需要迁移亲友关系 |
| **合葬场景** | ✅ 每个逝者独立亲友团 | ❌ 无法区分各逝者亲友 |
| **供奉联动** | ✅ 直接加入对应逝者亲友团 | ❌ 无法确定加入哪个逝者 |
| **权限管理** | ✅ 由逝者owner管理，边界清晰 | ❌ 合葬墓位权限冲突 |
| **实施状态** | ✅ **已实施** | ❌ 已停用（follow_grave） |
| **代码复杂度** | ✅ 简单直接 | ❌ 需要处理多种边界情况 |

---

## 七、最终推荐

### ✅ **推荐方案：亲友团关联Deceased（逝者）**

**理由**：
1. ✅ **已实施**：当前代码已经采用此方案
2. ✅ **业务合理**：符合现实认知和用户心智模型
3. ✅ **数据稳定**：逝者迁移时关系自动跟随
4. ✅ **功能完备**：支持合葬、供奉联动等复杂场景
5. ✅ **扩展性强**：墓位关注可通过前端聚合实现

### 实施建议

1. **保持当前设计**：无需修改链上逻辑
2. **完善前端实现**：
   - 逝者详情页：展示该逝者的亲友团
   - 墓位详情页：聚合展示所有逝者的亲友（可选）
3. **文档完善**：更新README说明亲友团的归属逻辑
4. **前端组件**：创建通用的亲友团管理组件

---

## 八、备注

### 系统决策历史

根据代码注释（`pallets/stardust-grave/src/lib.rs:2268`）：
- **方案A**（已废弃）：墓位承载关注功能
- **方案B**（当前方案）：亲友/关注统一回归逝者维度

这个决策在系统设计初期已经做出，并且已经完整实施。

### 未来扩展

如果将来需要"墓位粉丝"功能：
- 可以在前端层实现（关注墓位=关注所有逝者）
- 或者在链上新增独立的`GraveFollowers`存储（与亲友团并行）
- 但**不建议**将现有的亲友团迁移到墓位维度

---

**结论**：当前系统的设计是合理、可行且已完整实施的。亲友团关联到Deceased（逝者）是最佳方案。

---

**文档作者**：Claude
**审阅建议**：业务团队 + 前端团队
**实施状态**：✅ 已在链上实施，前端正在对接中
