# 供奉对象设计分析：Grave vs Deceased

> **分析日期**: 2025-11-08  
> **分析范围**: 供奉对象应该是墓地（Grave）还是逝者（Deceased）

---

## 📋 当前设计现状

### 1. 供奉目标结构

**pallet-memorial** 使用 `target: (u8, u64)` 作为供奉目标：

```rust
// target: (domain, target_id)
// domain: 域代码
//   - 1 = Grave（墓地）
//   - 2 = Deceased（逝者）
//   - 3 = Pet（宠物）
//   - 4 = Park（陵园）
```

### 2. 统计存储设计

**pallet-ledger** 同时支持两种统计：

```rust
// 墓位级统计
TotalsByGrave<GraveId>          // 累计供奉次数
TotalMemoByGrave<GraveId>       // 累计供奉金额

// 逝者级统计
TotalMemoByDeceased<DeceasedId> // 累计供奉金额
```

### 3. Grave 和 Deceased 的关系

**从 pallet-stardust-grave 分析**：

- ✅ **一个 Grave 可以安葬多个 Deceased**（通过 `Interred` 事件）
- ✅ **Grave 有主逝者**（PrimaryDeceased）
- ✅ **一个 Deceased 只能安葬在一个 Grave 中**（一对一关系）

---

## 🎯 方案对比分析

### 方案A：供奉对象 = Grave（墓地）

#### ✅ 优势

1. **符合传统习俗**
   - 中国传统祭祀文化中，供奉通常是针对"墓地"或"墓位"
   - 用户习惯：去墓地祭拜，而不是针对某个具体逝者

2. **业务逻辑简单**
   - 一个 Grave 对应一个物理位置
   - 供奉记录清晰，易于理解
   - 统计维度单一，查询简单

3. **技术实现简单**
   - 只需维护 `TotalsByGrave` 和 `TotalMemoByGrave`
   - 不需要处理 Grave 和 Deceased 的映射关系
   - 查询性能好，存储成本低

4. **支持合葬场景**
   - 一个 Grave 可以安葬多个 Deceased
   - 供奉给 Grave 时，所有逝者都能"收到"
   - 符合"合葬"的传统习俗

5. **分账逻辑清晰**
   - 供奉金额直接分配给 Grave 的所有者
   - 不需要考虑多个逝者的分配比例

#### ❌ 劣势

1. **无法区分具体逝者**
   - 如果一个 Grave 有多个 Deceased，无法知道供奉是给谁的
   - 无法统计单个逝者收到的供奉金额

2. **逝者级统计缺失**
   - 无法查询"某个逝者收到了多少供奉"
   - 无法做逝者级的排行榜

3. **用户体验受限**
   - 用户可能想"专门给爷爷供奉"，而不是给整个墓地
   - 无法满足个性化需求

---

### 方案B：供奉对象 = Deceased（逝者）

#### ✅ 优势

1. **精确到个人**
   - 供奉对象明确，是具体的逝者
   - 符合"给爷爷供奉"、"给奶奶供奉"的个性化需求

2. **统计维度丰富**
   - 可以统计单个逝者收到的供奉金额
   - 可以做逝者级的排行榜
   - 可以分析"哪个逝者最受尊敬"

3. **业务扩展性强**
   - 支持"给逝者A供奉"、"给逝者B供奉"的差异化场景
   - 可以基于逝者做个性化推荐

4. **符合现代数字纪念**
   - 数字纪念平台更注重"个人"而非"位置"
   - 符合年轻用户的习惯

#### ❌ 劣势

1. **技术实现复杂**
   - 需要维护 Grave 和 Deceased 的映射关系
   - 需要同时更新 Grave 级和 Deceased 级统计
   - 查询时需要关联查询

2. **合葬场景处理困难**
   - 如果一个 Grave 有多个 Deceased，用户需要选择给谁供奉
   - 增加了用户操作复杂度

3. **分账逻辑复杂**
   - 如果供奉给 Deceased，但 Grave 有多个 Deceased，如何分配？
   - 需要定义分配规则（平均分配？按主次分配？）

4. **存储成本高**
   - 需要同时维护 Grave 级和 Deceased 级统计
   - 数据冗余，存储成本增加

---

### 方案C：双目标支持（当前设计）

#### ✅ 优势

1. **灵活性最高**
   - 支持供奉给 Grave（domain=1）
   - 支持供奉给 Deceased（domain=2）
   - 用户可以选择供奉对象

2. **统计维度完整**
   - Grave 级统计：`TotalsByGrave` / `TotalMemoByGrave`
   - Deceased 级统计：`TotalMemoByDeceased`
   - 两种统计可以并存

3. **业务场景覆盖全面**
   - 传统用户：供奉给 Grave（整个墓地）
   - 现代用户：供奉给 Deceased（具体逝者）
   - 满足不同用户需求

#### ❌ 劣势

1. **实现复杂度最高**
   - 需要同时支持两种目标类型
   - 需要维护两套统计逻辑
   - 查询时需要判断 target 类型

2. **用户选择困难**
   - 用户可能不知道应该选择 Grave 还是 Deceased
   - 需要 UI 引导和说明

3. **数据一致性风险**
   - 如果同时支持两种目标，可能出现数据不一致
   - 需要确保 Grave 级和 Deceased 级统计的同步

---

## 💡 推荐方案

### 🏆 推荐：方案A（供奉对象 = Grave）

#### 理由

1. **符合传统习俗**
   - 中国传统祭祀文化中，供奉通常是针对"墓地"或"墓位"
   - 用户习惯：去墓地祭拜，而不是针对某个具体逝者

2. **技术实现简单**
   - 只需维护 Grave 级统计
   - 查询性能好，存储成本低
   - 代码逻辑清晰，易于维护

3. **业务逻辑清晰**
   - 一个 Grave 对应一个物理位置
   - 供奉记录清晰，易于理解
   - 分账逻辑简单

4. **支持合葬场景**
   - 一个 Grave 可以安葬多个 Deceased
   - 供奉给 Grave 时，所有逝者都能"收到"
   - 符合"合葬"的传统习俗

#### 实现建议

```rust
// 供奉目标固定为 Grave
target: (1, grave_id)  // domain=1 表示 Grave

// 统计存储
TotalsByGrave<GraveId>          // 累计供奉次数
TotalMemoByGrave<GraveId>       // 累计供奉金额

// 可选：如果需要逝者级统计，可以通过 Grave 关联查询
// 但不需要在供奉时指定 Deceased
```

---

## 🔄 备选方案：方案C（双目标支持）

### 适用场景

如果业务需求明确要求：
- ✅ 支持"给具体逝者供奉"的个性化需求
- ✅ 需要逝者级的排行榜和统计
- ✅ 用户群体主要是年轻用户（更接受数字纪念）

### 实现建议

```rust
// 支持两种目标类型
target: (domain, target_id)
// domain=1: Grave
// domain=2: Deceased

// 统计存储（同时维护）
TotalsByGrave<GraveId>          // Grave 级统计
TotalMemoByGrave<GraveId>      // Grave 级统计
TotalMemoByDeceased<DeceasedId> // Deceased 级统计

// 供奉时同时更新两种统计
if domain == 1 {
    // 更新 Grave 级统计
    Ledger::record_from_hook_with_amount(grave_id, ...);
    
    // 如果 Grave 有主逝者，也更新逝者级统计
    if let Some(deceased_id) = get_primary_deceased(grave_id) {
        Ledger::add_to_deceased_total(deceased_id, amount);
    }
} else if domain == 2 {
    // 更新 Deceased 级统计
    Ledger::add_to_deceased_total(deceased_id, amount);
    
    // 如果 Deceased 有对应的 Grave，也更新 Grave 级统计
    if let Some(grave_id) = get_grave_of_deceased(deceased_id) {
        Ledger::record_from_hook_with_amount(grave_id, ...);
    }
}
```

---

## 📊 对比总结

| 维度 | 方案A（Grave） | 方案B（Deceased） | 方案C（双目标） |
|------|---------------|------------------|----------------|
| **传统习俗** | ✅ 符合 | ❌ 不符合 | ⚠️ 部分符合 |
| **技术复杂度** | ✅ 简单 | ⚠️ 中等 | ❌ 复杂 |
| **业务逻辑** | ✅ 清晰 | ⚠️ 中等 | ❌ 复杂 |
| **合葬支持** | ✅ 天然支持 | ❌ 需要选择 | ⚠️ 需要选择 |
| **个性化需求** | ❌ 不支持 | ✅ 支持 | ✅ 支持 |
| **统计维度** | ⚠️ 单一 | ✅ 丰富 | ✅ 最丰富 |
| **存储成本** | ✅ 低 | ⚠️ 中等 | ❌ 高 |
| **查询性能** | ✅ 好 | ⚠️ 中等 | ❌ 需要判断 |
| **用户体验** | ✅ 简单 | ⚠️ 需要选择 | ❌ 需要选择 |

---

## 🎯 最终建议

### 推荐方案：方案A（供奉对象 = Grave）

**理由**：
1. ✅ **符合传统习俗**：中国传统祭祀文化中，供奉通常是针对"墓地"
2. ✅ **技术实现简单**：只需维护 Grave 级统计，代码清晰
3. ✅ **业务逻辑清晰**：一个 Grave 对应一个物理位置，易于理解
4. ✅ **支持合葬场景**：天然支持一个 Grave 多个 Deceased 的场景
5. ✅ **存储成本低**：只需维护 Grave 级统计，存储成本低

**实现方式**：
```rust
// 供奉目标固定为 Grave
target: (1, grave_id)  // domain=1 表示 Grave

// 统计存储
TotalsByGrave<GraveId>          // 累计供奉次数
TotalMemoByGrave<GraveId>       // 累计供奉金额
```

**如果未来需要逝者级统计**：
- 可以通过 Grave 关联查询 Deceased
- 或者在供奉时，如果 Grave 有主逝者，同时更新逝者级统计（但不作为供奉目标）

---

## 📝 实施建议

### 1. 短期（当前阶段）

**采用方案A（供奉对象 = Grave）**

- ✅ 简化实现，快速上线
- ✅ 符合传统习俗，用户接受度高
- ✅ 技术实现简单，维护成本低

### 2. 中期（业务扩展）

**如果需要逝者级统计**：

- ✅ 在供奉时，如果 Grave 有主逝者，同时更新逝者级统计
- ✅ 但不改变供奉目标（仍然是 Grave）
- ✅ 逝者级统计仅用于查询和展示，不作为供奉目标

### 3. 长期（高级功能）

**如果业务需求明确要求"给具体逝者供奉"**：

- ✅ 可以考虑支持方案C（双目标支持）
- ✅ 但需要充分评估技术复杂度和业务价值
- ✅ 建议通过用户调研验证需求

---

## 🔍 可行性分析

### 方案A（Grave）可行性：✅ 高

- ✅ **技术可行性**：当前代码已支持，只需固定 domain=1
- ✅ **业务可行性**：符合传统习俗，用户接受度高
- ✅ **维护可行性**：代码简单，易于维护

### 方案B（Deceased）可行性：⚠️ 中等

- ⚠️ **技术可行性**：需要修改供奉目标逻辑，增加复杂度
- ⚠️ **业务可行性**：需要用户选择，增加操作复杂度
- ⚠️ **维护可行性**：需要维护 Grave 和 Deceased 的映射关系

### 方案C（双目标）可行性：❌ 低

- ❌ **技术可行性**：需要同时支持两种目标，实现复杂
- ❌ **业务可行性**：用户选择困难，需要 UI 引导
- ❌ **维护可行性**：需要维护两套统计逻辑，维护成本高

---

## 📚 相关文档

- `pallets/memorial/README.md` - Memorial Pallet 文档
- `pallets/ledger/README.md` - Ledger Pallet 文档
- `pallets/stardust-grave/README.md` - Grave Pallet 文档

---

**维护者**: Stardust Team  
**最后更新**: 2025-11-08

