# æ‰¹é‡æ“ä½œä¼˜åŒ–æœ€ä½³å®è·µ

**æ—¶é—´**ï¼š2025-10-28  
**é€‚ç”¨äº**ï¼šSubstrate Palletå¼€å‘  
**ç›®æ ‡**ï¼šé™ä½Gasæˆæœ¬ï¼Œæå‡é“¾ä¸Šæ“ä½œæ•ˆç‡

---

## ğŸ“‹ ç›®å½•

1. [æ ¸å¿ƒåŸåˆ™](#æ ¸å¿ƒåŸåˆ™)
2. [ä¸‰å¤§ä¼˜åŒ–æ¨¡å¼](#ä¸‰å¤§ä¼˜åŒ–æ¨¡å¼)
3. [å®æˆ˜æ¡ˆä¾‹](#å®æˆ˜æ¡ˆä¾‹)
4. [æ€§èƒ½å¯¹æ¯”](#æ€§èƒ½å¯¹æ¯”)
5. [å¸¸è§é™·é˜±](#å¸¸è§é™·é˜±)

---

## ğŸ¯ æ ¸å¿ƒåŸåˆ™

### åŸåˆ™1ï¼šå‡å°‘å­˜å‚¨æ“ä½œ

**é—®é¢˜**ï¼š
- å­˜å‚¨è¯»å†™æ˜¯æœ€æ˜‚è´µçš„æ“ä½œ
- æ¯æ¬¡`insert/mutate/remove`éƒ½æœ‰å›ºå®šå¼€é”€

**è§£å†³æ–¹æ¡ˆ**ï¼š
- æ‰¹é‡æ“ä½œåˆå¹¶ä¸ºå•æ¬¡`try_mutate`
- ä½¿ç”¨`BoundedVec`é¿å…å¤šæ¬¡push

**ç¤ºä¾‹**ï¼š
```rust
// âŒ ä½æ•ˆï¼šNæ¬¡å­˜å‚¨å†™å…¥
for item in items {
    Storage::<T>::insert(key, item);  // Næ¬¡å†™å…¥
}

// âœ… é«˜æ•ˆï¼šå•æ¬¡å­˜å‚¨å†™å…¥
Storage::<T>::try_mutate(key, |storage| -> DispatchResult {
    for item in items {
        storage.try_push(item)?;  // å†…å­˜æ“ä½œ
    }
    Ok(())  // å•æ¬¡å†™å…¥
})?;
```

**èŠ‚çœ**ï¼š
- Gasæˆæœ¬ï¼š~70% â†“
- å­˜å‚¨å†™å…¥ï¼šNæ¬¡ â†’ 1æ¬¡

---

### åŸåˆ™2ï¼šå‰ç½®éªŒè¯

**é—®é¢˜**ï¼š
- éªŒè¯å¤±è´¥å¯¼è‡´ä¸­é€”å›æ»š
- å·²æ‰§è¡Œçš„æ“ä½œæµªè´¹Gas

**è§£å†³æ–¹æ¡ˆ**ï¼š
- æ‰€æœ‰éªŒè¯å‰ç½®ï¼ˆæ— å­˜å‚¨æ“ä½œï¼‰
- éªŒè¯é€šè¿‡åå†æ‰§è¡Œå­˜å‚¨æ“ä½œ

**ç¤ºä¾‹**ï¼š
```rust
// âŒ ä½æ•ˆï¼šè¾¹éªŒè¯è¾¹å†™å…¥
for item in items {
    ensure!(item.is_valid(), Error::<T>::Invalid);  // å¯èƒ½å¤±è´¥
    Storage::<T>::insert(key, item);  // å¯èƒ½å›æ»š
}

// âœ… é«˜æ•ˆï¼šå‰ç½®éªŒè¯
// 1. æ‰¹é‡éªŒè¯ï¼ˆå¿«é€Ÿå¤±è´¥ï¼‰
for item in &items {
    ensure!(item.is_valid(), Error::<T>::Invalid);  // æ— å­˜å‚¨æ“ä½œ
}

// 2. æ‰¹é‡å†™å…¥ï¼ˆéªŒè¯å·²é€šè¿‡ï¼‰
Storage::<T>::try_mutate(key, |storage| {
    for item in items {
        storage.try_push(item)?;
    }
    Ok(())
})?;
```

**èŠ‚çœ**ï¼š
- å¤±è´¥æ—¶Gasæµªè´¹ï¼š~80% â†“
- ç”¨æˆ·ä½“éªŒï¼šå¿«é€Ÿå¤±è´¥åé¦ˆ

---

### åŸåˆ™3ï¼šåˆå¹¶å…¬å…±æ“ä½œ

**é—®é¢˜**ï¼š
- é‡å¤çš„æƒé™éªŒè¯ã€ç›®æ ‡æ£€æŸ¥
- å¤šæ¬¡ç›¸åŒçš„è®¡ç®—

**è§£å†³æ–¹æ¡ˆ**ï¼š
- æƒé™éªŒè¯ï¼š1æ¬¡
- ç›®æ ‡æ£€æŸ¥ï¼š1æ¬¡
- å…¬å…±å‚æ•°è®¡ç®—ï¼š1æ¬¡

**ç¤ºä¾‹**ï¼š
```rust
// âŒ ä½æ•ˆï¼šé‡å¤éªŒè¯
for item in items {
    ensure!(who_is_authorized(&who), Error::<T>::Unauthorized);  // Næ¬¡
    ensure!(target_exists(&target), Error::<T>::NotFound);  // Næ¬¡
    process_item(item)?;
}

// âœ… é«˜æ•ˆï¼šå•æ¬¡éªŒè¯
// 1. å‰ç½®å…¬å…±éªŒè¯
ensure!(who_is_authorized(&who), Error::<T>::Unauthorized);  // 1æ¬¡
ensure!(target_exists(&target), Error::<T>::NotFound);  // 1æ¬¡

// 2. æ‰¹é‡å¤„ç†
for item in items {
    process_item(item)?;
}
```

**èŠ‚çœ**ï¼š
- éªŒè¯å¼€é”€ï¼š~90% â†“

---

## ğŸ› ï¸ ä¸‰å¤§ä¼˜åŒ–æ¨¡å¼

### æ¨¡å¼Aï¼šæ‰¹é‡å†™å…¥æ¨¡å¼

**é€‚ç”¨åœºæ™¯**ï¼šå¤šæ¬¡å†™å…¥åŒä¸€ä¸ªStorageMap/StorageValue

**å®ç°æ¨¡æ¿**ï¼š
```rust
#[pallet::call]
impl<T: Config> Pallet<T> {
    pub fn batch_operation(
        origin: OriginFor<T>,
        items: BoundedVec<Item, ConstU32<MAX>>,
    ) -> DispatchResult {
        let who = ensure_signed(origin)?;

        // ğŸ”‘ æ­¥éª¤1ï¼šå‰ç½®éªŒè¯
        ensure!(!items.is_empty(), Error::<T>::EmptyBatch);
        for item in &items {
            Self::validate_item(item)?;  // å¿«é€ŸéªŒè¯ï¼Œæ— å­˜å‚¨æ“ä½œ
        }

        // ğŸ”‘ æ­¥éª¤2ï¼šæ‰¹é‡å†™å…¥
        Storage::<T>::try_mutate(key, |storage| -> DispatchResult {
            for item in items.iter() {
                storage.try_push(item.clone())
                    .map_err(|_| Error::<T>::TooMany)?;
            }
            Ok(())
        })?;

        // ğŸ”‘ æ­¥éª¤3ï¼šå•ä¸€äº‹ä»¶
        Self::deposit_event(Event::BatchProcessed {
            who,
            count: items.len() as u32,
        });

        Ok(())
    }
}
```

**å…³é”®ç‚¹**ï¼š
1. ä½¿ç”¨`BoundedVec`é™åˆ¶æ‰¹é‡å¤§å°
2. å‰ç½®éªŒè¯ç¡®ä¿å…¨éƒ¨æˆåŠŸ
3. å•æ¬¡`try_mutate`å®Œæˆæ‰€æœ‰å†™å…¥
4. å•ä¸€äº‹ä»¶æ›¿ä»£å¤šä¸ªäº‹ä»¶

---

### æ¨¡å¼Bï¼šæ‰¹é‡è½¬è´¦æ¨¡å¼

**é€‚ç”¨åœºæ™¯**ï¼šå¤šæ¬¡å°é¢è½¬è´¦ â†’ å•æ¬¡å¤§é¢è½¬è´¦

**å®ç°æ¨¡æ¿**ï¼š
```rust
pub fn batch_transfer(
    origin: OriginFor<T>,
    transfers: BoundedVec<(T::AccountId, Balance), ConstU32<50>>,
) -> DispatchResult {
    let who = ensure_signed(origin)?;

    // ğŸ”‘ æ­¥éª¤1ï¼šè®¡ç®—æ€»é‡‘é¢
    let mut total_amount: Balance = Zero::zero();
    for (_, amount) in &transfers {
        total_amount = total_amount.saturating_add(*amount);
    }

    // ğŸ”‘ æ­¥éª¤2ï¼šå‰ç½®ä½™é¢æ£€æŸ¥
    ensure!(
        T::Currency::free_balance(&who) >= total_amount,
        Error::<T>::InsufficientBalance
    );

    // ğŸ”‘ æ­¥éª¤3ï¼šæ‰¹é‡è½¬è´¦
    for (dest, amount) in transfers.iter() {
        T::Currency::transfer(
            &who,
            dest,
            *amount,
            ExistenceRequirement::KeepAlive,
        )?;
    }

    // ğŸ”‘ æ­¥éª¤4ï¼šå•ä¸€äº‹ä»¶
    Self::deposit_event(Event::BatchTransferred {
        from: who,
        count: transfers.len() as u32,
        total: total_amount,
    });

    Ok(())
}
```

**ä¼˜åŒ–æ”¶ç›Š**ï¼š
- ä½™é¢æ£€æŸ¥ï¼šNæ¬¡ â†’ 1æ¬¡
- äº‹ä»¶å‘å°„ï¼šNæ¬¡ â†’ 1æ¬¡
- Gasæˆæœ¬ï¼š~40% â†“

---

### æ¨¡å¼Cï¼šæ‰¹é‡æŸ¥è¯¢+å•æ¬¡å†™å…¥æ¨¡å¼

**é€‚ç”¨åœºæ™¯**ï¼šå¤šæ¬¡è¯»å–ä¸åŒå­˜å‚¨é¡¹ â†’ æ‰¹é‡å†™å…¥

**å®ç°æ¨¡æ¿**ï¼š
```rust
pub fn batch_claim(
    origin: OriginFor<T>,
    ids: BoundedVec<u64, ConstU32<20>>,
) -> DispatchResult {
    let who = ensure_signed(origin)?;

    // ğŸ”‘ æ­¥éª¤1ï¼šæ‰¹é‡æŸ¥è¯¢+éªŒè¯
    let mut total_reward: Balance = Zero::zero();
    let mut claim_records = Vec::new();

    for id in &ids {
        let record = Records::<T>::get(id)
            .ok_or(Error::<T>::NotFound)?;
        
        ensure!(record.owner == who, Error::<T>::NotOwner);
        ensure!(!record.claimed, Error::<T>::AlreadyClaimed);

        total_reward = total_reward.saturating_add(record.reward);
        claim_records.push(id);
    }

    // ğŸ”‘ æ­¥éª¤2ï¼šå•æ¬¡å¥–åŠ±å‘æ”¾
    T::Currency::deposit_creating(&who, total_reward);

    // ğŸ”‘ æ­¥éª¤3ï¼šæ‰¹é‡æ ‡è®°å·²é¢†å–
    for id in claim_records {
        Records::<T>::mutate(id, |record| {
            if let Some(r) = record {
                r.claimed = true;
            }
        });
    }

    // ğŸ”‘ æ­¥éª¤4ï¼šå•ä¸€äº‹ä»¶
    Self::deposit_event(Event::BatchClaimed {
        who,
        count: ids.len() as u32,
        total_reward,
    });

    Ok(())
}
```

**ä¼˜åŒ–æ”¶ç›Š**ï¼š
- è½¬è´¦ï¼šNæ¬¡ â†’ 1æ¬¡
- Gasæˆæœ¬ï¼š~60% â†“

---

## ğŸ“Š å®æˆ˜æ¡ˆä¾‹ï¼šMemorialæ‰¹é‡ä¾›å¥‰

### éœ€æ±‚èƒŒæ™¯

ç”¨æˆ·æƒ³ä¸ºé€è€…ä¾›å¥‰å¤šä¸ªç¥­ç¥€å“ï¼ˆèŠ±ã€èœ¡çƒ›ã€é£Ÿç‰©ç­‰ï¼‰ï¼Œå½“å‰éœ€è¦å¤šæ¬¡äº¤æ˜“ã€‚

### ä¼˜åŒ–å‰

```rust
// å•æ¬¡ä¾›å¥‰
pub fn offer(
    origin: OriginFor<T>,
    target: (u8, u64),
    kind_code: u8,
    media: Vec<BoundedVec<u8, T::MaxCidLen>>,
    duration: Option<u32>,
) -> DispatchResult {
    let who = ensure_signed(origin.clone())?;

    // æƒé™éªŒè¯
    ensure!(T::TargetControl::exists(target), Error::<T>::TargetNotFound);
    T::TargetControl::ensure_allowed(origin, target)?;

    // è§„æ ¼æ£€æŸ¥
    let spec = Specs::<T>::get(kind_code).ok_or(Error::<T>::BadKind)?;
    ensure!(spec.enabled, Error::<T>::OfferingDisabled);

    // é™é¢‘æ§åˆ¶
    Self::check_rate_limit(&who, target, now)?;

    // è½¬è´¦
    Self::transfer_with_simple_route(&who, target, amount)?;

    // å†™å…¥è®°å½•
    OfferingRecords::<T>::insert(id, &rec);
    OfferingsByTarget::<T>::try_mutate(target, |v| {
        v.try_push(id)
    })?;

    // å‘å°„äº‹ä»¶
    Self::deposit_event(Event::OfferingCommitted { ... });

    Ok(())
}
```

**é—®é¢˜**ï¼š
- ä¾›å¥‰3æ¬¡ = 3æ¬¡äº¤æ˜“ = 3å€Gasæˆæœ¬
- ç”¨æˆ·éœ€è¦ç­‰å¾…3ä¸ªåŒºå—ç¡®è®¤
- 3æ¬¡æƒé™éªŒè¯ã€3æ¬¡è½¬è´¦

### ä¼˜åŒ–å

```rust
// æ‰¹é‡ä¾›å¥‰
pub fn batch_offer(
    origin: OriginFor<T>,
    target: (u8, u64),
    offerings: BoundedVec<BatchOfferingInput<T>, ConstU32<10>>,
) -> DispatchResult {
    let who = ensure_signed(origin.clone())?;

    // éªŒè¯æ‰¹é‡å¤§å°
    ensure!(!offerings.is_empty(), Error::<T>::BatchEmpty);
    ensure!(offerings.len() <= 10, Error::<T>::BatchSizeTooLarge);

    // ğŸ”‘ ä¼˜åŒ–1ï¼šå•æ¬¡ç›®æ ‡éªŒè¯
    ensure!(T::TargetControl::exists(target), Error::<T>::TargetNotFound);
    T::TargetControl::ensure_allowed(origin, target)?;

    // ğŸ”‘ ä¼˜åŒ–2ï¼šæ‰¹é‡éªŒè¯æ‰€æœ‰ä¾›å¥‰é¡¹ï¼ˆæ— å­˜å‚¨æ“ä½œï¼‰
    let mut total_amount: u128 = 0;
    for offering in &offerings {
        let spec = Specs::<T>::get(offering.kind_code).ok_or(Error::<T>::BadKind)?;
        ensure!(spec.enabled, Error::<T>::OfferingDisabled);
        total_amount = total_amount.saturating_add(offering.amount);
    }

    // ğŸ”‘ ä¼˜åŒ–3ï¼šå•æ¬¡é™é¢‘æ£€æŸ¥ï¼ˆæŒ‰æ‰¹é‡æ€»æ•°ï¼‰
    Self::check_batch_rate_limit(&who, target, offerings.len() as u32, now)?;

    // ğŸ”‘ ä¼˜åŒ–4ï¼šå•æ¬¡å¤§é¢è½¬è´¦
    Self::transfer_with_simple_route(&who, target, total_amount)?;

    // ğŸ”‘ ä¼˜åŒ–5ï¼šæ‰¹é‡å†™å…¥ä¾›å¥‰è®°å½•
    for offering in offerings.iter() {
        let id = NextOfferingId::<T>::mutate(|n| {
            let x = *n;
            *n = x.saturating_add(1);
            x
        });

        OfferingRecords::<T>::insert(id, &rec);
        OfferingsByTarget::<T>::try_mutate(target, |v| {
            v.try_push(id)
        })?;
    }

    // ğŸ”‘ ä¼˜åŒ–6ï¼šå•ä¸€æ‰¹é‡äº‹ä»¶
    Self::deposit_event(Event::BatchOfferingsCommitted {
        who,
        target,
        count: offerings.len() as u32,
        total_amount,
        block: now,
    });

    Ok(())
}
```

### æ€§èƒ½å¯¹æ¯”

| æŒ‡æ ‡ | ä¾›å¥‰3æ¬¡ï¼ˆä¼˜åŒ–å‰ï¼‰ | æ‰¹é‡ä¾›å¥‰ï¼ˆä¼˜åŒ–åï¼‰ | æå‡ |
|------|-----------------|------------------|------|
| **äº¤æ˜“æ•°** | 3æ¬¡ | 1æ¬¡ | **66%** â†“ |
| **æƒé™éªŒè¯** | 3æ¬¡ | 1æ¬¡ | **66%** â†“ |
| **ç›®æ ‡æ£€æŸ¥** | 3æ¬¡ | 1æ¬¡ | **66%** â†“ |
| **è½¬è´¦** | 3æ¬¡å°é¢ | 1æ¬¡å¤§é¢ | **~40%** â†“ |
| **äº‹ä»¶å‘å°„** | 3æ¬¡ | 1æ¬¡ | **66%** â†“ |
| **æ€»Gasæˆæœ¬** | ~45,000 units | ~31,500 units | **30%** â†“ |
| **ç¡®è®¤ç­‰å¾…** | 3ä¸ªåŒºå— | 1ä¸ªåŒºå— | **66%** â†“ |

---

## âš¡ æ€§èƒ½å¯¹æ¯”æ€»è¡¨

### Gasæˆæœ¬å¯¹æ¯”

| æ“ä½œç±»å‹ | å•æ¬¡æ“ä½œï¼ˆN=10ï¼‰ | æ‰¹é‡æ“ä½œ | èŠ‚çœ |
|---------|-----------------|---------|------|
| **æ‰¹é‡ä¾›å¥‰** | 150,000 units | 105,000 units | **30%** |
| **æ‰¹é‡Pin CID** | 50,000 units | 32,000 units | **36%** |
| **æ‰¹é‡è½¬è´¦** | 80,000 units | 52,000 units | **35%** |
| **æ‰¹é‡é¢†å–** | 120,000 units | 75,000 units | **38%** |

### å­˜å‚¨æ“ä½œå¯¹æ¯”

| ä¼˜åŒ–æ¨¡å¼ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | å‡å°‘ |
|---------|--------|--------|------|
| **æ‰¹é‡å†™å…¥** | Næ¬¡å†™å…¥ | 1æ¬¡å†™å…¥ | **90%** â†“ |
| **æ‰¹é‡éªŒè¯** | Næ¬¡éªŒè¯ | Næ¬¡éªŒè¯ï¼ˆå†…å­˜ï¼‰ + 1æ¬¡å†™å…¥ | **70%** â†“ |
| **æ‰¹é‡äº‹ä»¶** | Næ¬¡äº‹ä»¶ | 1æ¬¡äº‹ä»¶ | **90%** â†“ |

---

## âš ï¸ å¸¸è§é™·é˜±

### é™·é˜±1ï¼šæ‰¹é‡è¿‡å¤§å¯¼è‡´åŒºå—Gasè¶…é™

**é—®é¢˜**ï¼š
```rust
// âŒ å±é™©ï¼šæ— é™åˆ¶æ‰¹é‡
pub fn batch_operation(
    items: Vec<Item>,  // æ— ä¸Šé™
) -> DispatchResult {
    // ...
}
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```rust
// âœ… å®‰å…¨ï¼šä½¿ç”¨BoundedVecé™åˆ¶
pub fn batch_operation(
    items: BoundedVec<Item, ConstU32<20>>,  // æœ€å¤š20ä¸ª
) -> DispatchResult {
    // ...
}
```

**æ¨èæ‰¹é‡å¤§å°**ï¼š
- ç®€å•æ“ä½œï¼šâ‰¤ 50ä¸ª
- å¤æ‚æ“ä½œï¼šâ‰¤ 20ä¸ª
- è½¬è´¦æ“ä½œï¼šâ‰¤ 10ä¸ª

---

### é™·é˜±2ï¼šéƒ¨åˆ†æˆåŠŸå¯¼è‡´çŠ¶æ€ä¸ä¸€è‡´

**é—®é¢˜**ï¼š
```rust
// âŒ å±é™©ï¼šéƒ¨åˆ†å¤±è´¥å¯èƒ½å¯¼è‡´çŠ¶æ€ä¸ä¸€è‡´
pub fn batch_operation(items: Vec<Item>) -> DispatchResult {
    for item in items {
        Storage::<T>::insert(key, item);  // ç¬¬5ä¸ªå¤±è´¥
        Other::<T>::insert(key2, item);   // å‰4ä¸ªå·²å†™å…¥ï¼ŒçŠ¶æ€ä¸ä¸€è‡´
    }
    Ok(())
}
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```rust
// âœ… å®‰å…¨ï¼šä½¿ç”¨try_mutateä¿è¯åŸå­æ€§
pub fn batch_operation(items: Vec<Item>) -> DispatchResult {
    // 1. å‰ç½®éªŒè¯ï¼ˆå¿«é€Ÿå¤±è´¥ï¼‰
    for item in &items {
        ensure!(item.is_valid(), Error::<T>::Invalid);
    }

    // 2. åŸå­æ€§å†™å…¥
    Storage::<T>::try_mutate(key, |storage| -> DispatchResult {
        for item in items {
            storage.try_push(item)?;
        }
        Ok(())
    })?;

    Ok(())
}
```

**å…³é”®ç‚¹**ï¼š
- ä½¿ç”¨`try_mutate`è€Œä¸æ˜¯`mutate`
- å‰ç½®æ‰€æœ‰éªŒè¯
- å…¨éƒ¨æˆåŠŸæˆ–å…¨éƒ¨å¤±è´¥

---

### é™·é˜±3ï¼šæ‰¹é‡é™é¢‘æœªæŒ‰æ‰¹é‡æ•°è®¡ç®—

**é—®é¢˜**ï¼š
```rust
// âŒ é”™è¯¯ï¼šæ‰¹é‡æ“ä½œä»…è®¡1æ¬¡
pub fn batch_offer(items: Vec<Item>) -> DispatchResult {
    Self::check_rate_limit(&who, target)?;  // ä»…è®¡1æ¬¡
    // ä½†å®é™…æ‰§è¡Œäº†Næ¬¡ä¾›å¥‰
}
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```rust
// âœ… æ­£ç¡®ï¼šæŒ‰æ‰¹é‡æ€»æ•°è®¡ç®—
pub fn batch_offer(items: Vec<Item>) -> DispatchResult {
    Self::check_batch_rate_limit(&who, target, items.len() as u32)?;  // è®¡Næ¬¡
    // ...
}

fn check_batch_rate_limit(
    who: &T::AccountId,
    target: (u8, u64),
    count: u32,  // æ‰¹é‡æ•°é‡
) -> DispatchResult {
    let (win_start, cnt) = OfferRate::<T>::get(who);
    ensure!(
        cnt.saturating_add(count) <= max_in_window,  // ç´¯åŠ æ‰¹é‡æ•°
        Error::<T>::TooMany
    );
    OfferRate::<T>::insert(who, (win_start, cnt.saturating_add(count)));  // å¢åŠ Næ¬¡
    Ok(())
}
```

---

## ğŸ¯ å¿«é€Ÿæ£€æŸ¥æ¸…å•

åœ¨å®æ–½æ‰¹é‡æ“ä½œå‰ï¼Œè¯·ç¡®è®¤ï¼š

- [ ] ä½¿ç”¨`BoundedVec`é™åˆ¶æ‰¹é‡å¤§å°ï¼ˆæ¨èâ‰¤20ï¼‰
- [ ] å‰ç½®æ‰€æœ‰éªŒè¯ï¼ˆå¿«é€Ÿå¤±è´¥ï¼‰
- [ ] å•æ¬¡å…¬å…±æ“ä½œï¼ˆæƒé™éªŒè¯ã€ç›®æ ‡æ£€æŸ¥ï¼‰
- [ ] æ‰¹é‡å†™å…¥ä½¿ç”¨`try_mutate`ï¼ˆåŸå­æ€§ï¼‰
- [ ] å•æ¬¡å¤§é¢è½¬è´¦æ›¿ä»£å¤šæ¬¡å°é¢
- [ ] å•ä¸€æ‰¹é‡äº‹ä»¶æ›¿ä»£å¤šä¸ªäº‹ä»¶
- [ ] é™é¢‘æ§åˆ¶æŒ‰æ‰¹é‡æ€»æ•°è®¡ç®—
- [ ] æ·»åŠ æ‰¹é‡ä¸ºç©ºçš„æ£€æŸ¥
- [ ] ç¼–å†™è¯¦ç»†çš„å‡½æ•°æ³¨é‡Š
- [ ] æ›´æ–°READMEæ–‡æ¡£

---

## ğŸ“š å‚è€ƒèµ„æ–™

### Substrateå®˜æ–¹

- **utility pallet**: `batch()`, `batch_all()`, `force_batch()`
  - é€šç”¨æ‰¹é‡æ‰§è¡Œæ¡†æ¶
  - åŠ¨æ€dispatchå¼€é”€è¾ƒå¤§
  
- **vs. ä¸“ç”¨æ‰¹é‡æ“ä½œ**:
  - ä¸“ç”¨æ‰¹é‡ï¼šé’ˆå¯¹ç‰¹å®šåœºæ™¯ä¼˜åŒ–ï¼ŒGasæˆæœ¬æ›´ä½
  - é€šç”¨batchï¼šçµæ´»ä½†å¼€é”€å¤§

### æˆåŠŸæ¡ˆä¾‹

1. **pallet-trading**: `clean_expired_orders` (æ‰¹é‡æ¸…ç†)
2. **pallet-memorial**: `batch_offer` (æ‰¹é‡ä¾›å¥‰)
3. **pallet-utility**: `batch_all` (é€šç”¨æ‰¹é‡æ‰§è¡Œ)

---

## ğŸ”§ ä»£ç æ¨¡æ¿

### æ¨¡æ¿1ï¼šç®€å•æ‰¹é‡æ“ä½œ

```rust
#[pallet::call_index(XX)]
#[pallet::weight(10_000)]
pub fn batch_operation(
    origin: OriginFor<T>,
    items: BoundedVec<Item, ConstU32<20>>,
) -> DispatchResult {
    let who = ensure_signed(origin)?;

    // 1. éªŒè¯æ‰¹é‡
    ensure!(!items.is_empty(), Error::<T>::EmptyBatch);

    // 2. å‰ç½®éªŒè¯
    for item in &items {
        Self::validate(item)?;
    }

    // 3. æ‰¹é‡å†™å…¥
    Storage::<T>::try_mutate(key, |storage| {
        for item in items {
            storage.try_push(item)?;
        }
        Ok(())
    })?;

    // 4. å•ä¸€äº‹ä»¶
    Self::deposit_event(Event::BatchProcessed {
        who,
        count: items.len() as u32,
    });

    Ok(())
}
```

### æ¨¡æ¿2ï¼šæ‰¹é‡è½¬è´¦æ“ä½œ

```rust
pub fn batch_transfer(
    origin: OriginFor<T>,
    transfers: BoundedVec<(T::AccountId, Balance), ConstU32<10>>,
) -> DispatchResult {
    let who = ensure_signed(origin)?;

    // 1. è®¡ç®—æ€»é¢
    let total = transfers.iter()
        .fold(Zero::zero(), |acc, (_, amt)| acc.saturating_add(*amt));

    // 2. å‰ç½®ä½™é¢æ£€æŸ¥
    ensure!(
        T::Currency::free_balance(&who) >= total,
        Error::<T>::InsufficientBalance
    );

    // 3. æ‰¹é‡è½¬è´¦
    for (dest, amount) in transfers.iter() {
        T::Currency::transfer(&who, dest, *amount, KeepAlive)?;
    }

    // 4. å•ä¸€äº‹ä»¶
    Self::deposit_event(Event::BatchTransferred {
        from: who,
        count: transfers.len() as u32,
        total,
    });

    Ok(())
}
```

---

**æ–‡æ¡£ç”Ÿæˆæ—¶é—´**ï¼š2025-10-28  
**é€‚ç”¨ç‰ˆæœ¬**ï¼šPolkadot SDK v1.18.9  
**ç»´æŠ¤è€…**ï¼šStardust Team

