# v3.0åˆ†æ•£å­˜å‚¨æ¶æ„å®æ–½æŒ‡å¯¼ - æŠ€æœ¯è§„èŒƒæ–‡æ¡£

## æ–‡æ¡£ä¿¡æ¯

- **åˆ›å»ºæ—¶é—´**: 2025å¹´11æœˆ26æ—¥
- **ç‰ˆæœ¬**: v3.0å®æ–½æŒ‡å¯¼
- **ä½œè€…**: Claude Code åŠ©æ‰‹
- **æ–‡æ¡£æ€§è´¨**: æŠ€æœ¯å®æ–½è§„èŒƒä¸å¼€å‘æŒ‡å¯¼
- **é€‚ç”¨èŒƒå›´**: stardust-media-commonå·¥å…·åº“å¼€å‘ä¸å„æ¨¡å—é›†æˆ

---

## ğŸ“‹ å®æ–½æ¦‚è¿°

### æ ¸å¿ƒç›®æ ‡

åŸºäºv3.0æ¶æ„è®¾è®¡ï¼Œæœ¬æ–‡æ¡£æä¾›**åˆ†æ•£å­˜å‚¨ + å…±äº«å·¥å…·åº“**æ–¹æ¡ˆçš„è¯¦ç»†å®æ–½æŒ‡å¯¼ï¼Œç¡®ä¿ï¼š

1. âœ… **å·¥å…·åº“æ ‡å‡†åŒ–**: å»ºè®¾é«˜è´¨é‡çš„ stardust-media-common å·¥å…·åº“
2. âœ… **é›†æˆè§„èŒƒåŒ–**: å„æ¨¡å—è§„èŒƒé›†æˆå…±äº«å·¥å…·åº“
3. âœ… **æ€§èƒ½æœ€ä¼˜åŒ–**: ç¡®ä¿æ¶æ„ä¼˜åŠ¿å¾—åˆ°å……åˆ†å‘æŒ¥
4. âœ… **è´¨é‡ä¿éšœ**: å®Œæ•´çš„æµ‹è¯•è¦†ç›–å’Œæ–‡æ¡£æ”¯æŒ

### å®æ–½åŸåˆ™

1. **æ¸è¿›å¼å®æ–½**: ä¼˜å…ˆå¼€å‘å·¥å…·åº“ï¼Œç„¶åé€æ¨¡å—é›†æˆ
2. **å‘åå…¼å®¹**: ç¡®ä¿ç°æœ‰åŠŸèƒ½æ— å›å½’
3. **æ€§èƒ½å¯¼å‘**: æ¯ä¸ªå†³ç­–éƒ½è¦è€ƒè™‘æ€§èƒ½å½±å“
4. **æµ‹è¯•é©±åŠ¨**: é«˜æµ‹è¯•è¦†ç›–ç‡ï¼Œä¿è¯è´¨é‡

---

## 1. stardust-media-common å·¥å…·åº“å¼€å‘è§„èŒƒ

### 1.1 é¡¹ç›®ç»“æ„è§„èŒƒ

```
stardust-media-common/
â”œâ”€â”€ Cargo.toml                   # é¡¹ç›®é…ç½®
â”œâ”€â”€ README.md                    # ä½¿ç”¨æŒ‡å—
â”œâ”€â”€ CHANGELOG.md                 # ç‰ˆæœ¬å˜æ›´è®°å½•
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs                   # ä¸»æ¨¡å—å¯¼å‡º
â”‚   â”œâ”€â”€ types.rs                 # æ ¸å¿ƒç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ error.rs                 # é”™è¯¯ç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ validation/              # éªŒè¯æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ mod.rs              # éªŒè¯æ¨¡å—å¯¼å‡º
â”‚   â”‚   â”œâ”€â”€ image.rs            # å›¾ç‰‡éªŒè¯å™¨
â”‚   â”‚   â”œâ”€â”€ video.rs            # è§†é¢‘éªŒè¯å™¨
â”‚   â”‚   â”œâ”€â”€ audio.rs            # éŸ³é¢‘éªŒè¯å™¨
â”‚   â”‚   â””â”€â”€ common.rs           # é€šç”¨éªŒè¯å‡½æ•°
â”‚   â”œâ”€â”€ hash.rs                  # å“ˆå¸Œå·¥å…·
â”‚   â”œâ”€â”€ ipfs.rs                  # IPFSå·¥å…·
â”‚   â”œâ”€â”€ thumbnail.rs             # ç¼©ç•¥å›¾ç”Ÿæˆ
â”‚   â””â”€â”€ metadata.rs              # å…ƒæ•°æ®æå–
â”œâ”€â”€ tests/                       # é›†æˆæµ‹è¯•
â”‚   â”œâ”€â”€ validation_tests.rs      # éªŒè¯åŠŸèƒ½æµ‹è¯•
â”‚   â”œâ”€â”€ hash_tests.rs           # å“ˆå¸ŒåŠŸèƒ½æµ‹è¯•
â”‚   â””â”€â”€ integration_tests.rs     # ç»¼åˆé›†æˆæµ‹è¯•
â”œâ”€â”€ benches/                     # æ€§èƒ½åŸºå‡†æµ‹è¯•
â”‚   â””â”€â”€ benchmarks.rs
â””â”€â”€ examples/                    # ä½¿ç”¨ç¤ºä¾‹
    â”œâ”€â”€ basic_usage.rs
    â””â”€â”€ advanced_usage.rs
```

### 1.2 Cargo.toml é…ç½®è§„èŒƒ

```toml
[package]
name = "stardust-media-common"
version = "1.0.0"
edition = "2021"
authors = ["Stardust Team <dev@stardust.com>"]
description = "Common media handling utilities for Stardust blockchain"
repository = "https://github.com/stardust/stardust-media-common"
documentation = "https://docs.rs/stardust-media-common"
keywords = ["blockchain", "media", "validation", "ipfs", "substrate"]
categories = ["multimedia", "cryptography"]
license = "Apache-2.0"

[dependencies]
# Substrate Core - ä¸é¡¹ç›®ä¸»ç‰ˆæœ¬ä¿æŒä¸€è‡´
sp-core = { version = "21.0.0", default-features = false }
sp-std = { version = "8.0.0", default-features = false }
sp-io = { version = "23.0.0", default-features = false }

# Codec - åºåˆ—åŒ–æ”¯æŒ
codec = { package = "parity-scale-codec", version = "3.0.0", default-features = false, features = ["derive"] }
scale-info = { version = "2.5.0", default-features = false, features = ["derive"] }

# Frame Support - åŸºç¡€æ¡†æ¶æ”¯æŒ
frame-support = { version = "4.0.0", default-features = false }

# å¯é€‰ä¾èµ– - ç”¨äºå®Œæ•´åŠŸèƒ½
image = { version = "0.24", optional = true }
ffmpeg-sys = { version = "4.4", optional = true }

[dev-dependencies]
# æµ‹è¯•æ¡†æ¶
tokio = { version = "1.0", features = ["full"] }
criterion = { version = "0.5", features = ["html_reports"] }

[features]
default = ["std"]

# æ ‡å‡†åº“æ”¯æŒ
std = [
    "sp-core/std",
    "sp-std/std",
    "sp-io/std",
    "codec/std",
    "scale-info/std",
    "frame-support/std",
]

# å®Œæ•´éªŒè¯åŠŸèƒ½ï¼ˆéœ€è¦stdï¼‰
full-validation = ["std", "image", "ffmpeg-sys"]

# è¿è¡Œæ—¶åŠŸèƒ½ï¼ˆæ— stdï¼ŒåŸºç¡€åŠŸèƒ½ï¼‰
runtime = []

[[bench]]
name = "benchmarks"
harness = false
```

### 1.3 æ ¸å¿ƒç±»å‹è®¾è®¡è§„èŒƒ

#### 1.3.1 ç±»å‹å®šä¹‰æ ‡å‡†

```rust
// src/types.rs

use codec::{Decode, Encode, MaxEncodedLen};
use frame_support::BoundedVec;
use scale_info::TypeInfo;
use sp_core::ConstU32;

/// åª’ä½“ç±»å‹æšä¸¾ - ä¸æ‰€æœ‰æ¨¡å—å…¼å®¹
///
/// è®¾è®¡åŸåˆ™:
/// - æ¶µç›–ä¸‰å¤§æ¨¡å—çš„æ‰€æœ‰åª’ä½“ç±»å‹
/// - ä¿æŒå‘åå…¼å®¹æ€§
/// - æ”¯æŒæœªæ¥æ‰©å±•
#[derive(Clone, Copy, Encode, Decode, PartialEq, Eq, TypeInfo, MaxEncodedLen, Debug)]
pub enum MediaKind {
    /// å›¾ç‰‡/ç…§ç‰‡ - ç”¨äºDeceasedç›¸å†Œ, GroupChatå›¾ç‰‡æ¶ˆæ¯
    Photo,
    /// è§†é¢‘ - ç”¨äºDeceasedè§†é¢‘é›†, GroupChatè§†é¢‘æ¶ˆæ¯, Evidenceè§†é¢‘è¯æ®
    Video,
    /// éŸ³é¢‘ - ç”¨äºDeceasedéŸ³é¢‘ä½œå“, GroupChatéŸ³é¢‘æ¶ˆæ¯
    Audio,
    /// æ–‡æ¡£ - ç”¨äºEvidenceæ–‡æ¡£è¯æ®, GroupChatæ–‡ä»¶åˆ†äº«
    Document,
}

impl MediaKind {
    /// ä»MIMEç±»å‹æ¨æ–­åª’ä½“ç±»å‹
    ///
    /// æ”¯æŒçš„æ ¼å¼:
    /// - å›¾ç‰‡: JPEG, PNG, GIF, WebP
    /// - è§†é¢‘: MP4, WebM, QuickTime
    /// - éŸ³é¢‘: MP3, WAV, OGG, AAC
    /// - æ–‡æ¡£: PDF, TXT
    pub fn from_mime_type(mime: &[u8]) -> Result<Self, MediaError> {
        match mime {
            // å›¾ç‰‡æ ¼å¼
            b"image/jpeg" | b"image/jpg" => Ok(Self::Photo),
            b"image/png" => Ok(Self::Photo),
            b"image/gif" => Ok(Self::Photo),
            b"image/webp" => Ok(Self::Photo),

            // è§†é¢‘æ ¼å¼
            b"video/mp4" => Ok(Self::Video),
            b"video/webm" => Ok(Self::Video),
            b"video/quicktime" | b"video/mov" => Ok(Self::Video),

            // éŸ³é¢‘æ ¼å¼
            b"audio/mpeg" | b"audio/mp3" => Ok(Self::Audio),
            b"audio/wav" => Ok(Self::Audio),
            b"audio/ogg" => Ok(Self::Audio),
            b"audio/aac" => Ok(Self::Audio),

            // æ–‡æ¡£æ ¼å¼
            b"application/pdf" => Ok(Self::Document),
            b"text/plain" => Ok(Self::Document),

            _ => Err(MediaError::UnsupportedMimeType),
        }
    }

    /// è·å–é»˜è®¤MIMEç±»å‹
    pub fn default_mime_type(&self) -> &'static [u8] {
        match self {
            Self::Photo => b"image/jpeg",
            Self::Video => b"video/mp4",
            Self::Audio => b"audio/mpeg",
            Self::Document => b"application/pdf",
        }
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºè§†è§‰åª’ä½“ï¼ˆéœ€è¦ç¼©ç•¥å›¾ï¼‰
    pub fn is_visual(&self) -> bool {
        matches!(self, Self::Photo | Self::Video)
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºéŸ³é¢‘åª’ä½“
    pub fn is_audio(&self) -> bool {
        matches!(self, Self::Audio)
    }

    /// è·å–æ¨èçš„æœ€å¤§æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
    pub fn max_file_size(&self) -> u64 {
        match self {
            Self::Photo => 50 * 1024 * 1024,      // 50MB
            Self::Video => 500 * 1024 * 1024,     // 500MB
            Self::Audio => 100 * 1024 * 1024,     // 100MB
            Self::Document => 10 * 1024 * 1024,   // 10MB
        }
    }
}

/// åª’ä½“å…ƒæ•°æ®ç»“æ„ - æ ‡å‡†åŒ–çš„å…ƒæ•°æ®è¡¨ç¤º
///
/// è®¾è®¡åŸåˆ™:
/// - åŒ…å«æ‰€æœ‰æ¨¡å—å…±åŒéœ€è¦çš„å­—æ®µ
/// - å¯é€‰å­—æ®µé€‚é…ä¸åŒåª’ä½“ç±»å‹
/// - ä¿æŒè¾ƒå°çš„å†…å­˜å ç”¨
#[derive(Clone, Encode, Decode, PartialEq, Eq, TypeInfo, Debug)]
pub struct MediaMetadata {
    /// åª’ä½“ç±»å‹
    pub kind: MediaKind,

    /// æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
    pub file_size: u64,

    /// MIMEç±»å‹
    pub mime_type: BoundedVec<u8, ConstU32<64>>,

    /// å†…å®¹å“ˆå¸Œï¼ˆBlake2-256ï¼‰- ç”¨äºå»é‡å’Œå®Œæ•´æ€§æ£€æŸ¥
    pub content_hash: [u8; 32],

    /// å›¾ç‰‡/è§†é¢‘çš„å®½åº¦ï¼ˆåƒç´ ï¼‰
    pub width: Option<u32>,

    /// å›¾ç‰‡/è§†é¢‘çš„é«˜åº¦ï¼ˆåƒç´ ï¼‰
    pub height: Option<u32>,

    /// è§†é¢‘/éŸ³é¢‘çš„æ—¶é•¿ï¼ˆç§’ï¼‰
    pub duration_secs: Option<u32>,

    /// è§†é¢‘/éŸ³é¢‘çš„æ¯”ç‰¹ç‡ï¼ˆkbpsï¼‰
    pub bitrate: Option<u32>,

    /// å¸§ç‡ï¼ˆfpsï¼Œä»…è§†é¢‘ï¼‰
    pub fps: Option<u32>,

    /// åˆ›å»ºæ—¶é—´æˆ³ï¼ˆUnixæ—¶é—´æˆ³ï¼‰
    pub created_at: Option<u64>,

    /// æ˜¯å¦åŒ…å«é€æ˜é€šé“ï¼ˆPNG/WebPï¼‰
    pub has_alpha: Option<bool>,

    /// è‰²å½©ç©ºé—´ä¿¡æ¯
    pub color_space: Option<BoundedVec<u8, ConstU32<16>>>,
}

impl MediaMetadata {
    /// åˆ›å»ºåŸºç¡€å…ƒæ•°æ®
    pub fn new(kind: MediaKind, data: &[u8]) -> Self {
        use sp_core::blake2_256;

        let mime_type = BoundedVec::try_from(kind.default_mime_type().to_vec())
            .unwrap_or_default();

        Self {
            kind,
            file_size: data.len() as u64,
            mime_type,
            content_hash: blake2_256(data),
            width: None,
            height: None,
            duration_secs: None,
            bitrate: None,
            fps: None,
            created_at: None,
            has_alpha: None,
            color_space: None,
        }
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆçš„å›¾ç‰‡å°ºå¯¸
    pub fn is_valid_image_size(&self) -> bool {
        match (self.width, self.height) {
            (Some(w), Some(h)) if w > 0 && h > 0 && w <= 65535 && h <= 65535 => true,
            _ => false,
        }
    }

    /// è®¡ç®—åƒç´ æ€»æ•°
    pub fn pixel_count(&self) -> Option<u64> {
        match (self.width, self.height) {
            (Some(w), Some(h)) => Some(w as u64 * h as u64),
            _ => None,
        }
    }

    /// æ£€æŸ¥æ–‡ä»¶å¤§å°æ˜¯å¦åœ¨åˆç†èŒƒå›´å†…
    pub fn is_valid_file_size(&self) -> bool {
        self.file_size > 0 && self.file_size <= self.kind.max_file_size()
    }
}
```

#### 1.3.2 é”™è¯¯ç±»å‹è®¾è®¡

```rust
// src/error.rs

/// åª’ä½“å¤„ç†é”™è¯¯ç±»å‹
///
/// è®¾è®¡åŸåˆ™:
/// - è¦†ç›–æ‰€æœ‰å¯èƒ½çš„é”™è¯¯æƒ…å†µ
/// - æä¾›è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
/// - ä¾¿äºé”™è¯¯å¤„ç†å’Œè°ƒè¯•
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum MediaError {
    // æ–‡ä»¶ç›¸å…³é”™è¯¯
    /// æ–‡ä»¶è¿‡å°ï¼ˆå°äºæœ€å°é™åˆ¶ï¼‰
    FileTooSmall,
    /// æ–‡ä»¶è¿‡å¤§ï¼ˆè¶…è¿‡æœ€å¤§é™åˆ¶ï¼‰
    FileTooLarge,
    /// æ–‡ä»¶ä¸ºç©º
    EmptyFile,

    // æ ¼å¼ç›¸å…³é”™è¯¯
    /// ä¸æ”¯æŒçš„åª’ä½“æ ¼å¼
    UnsupportedFormat,
    /// ä¸æ”¯æŒçš„MIMEç±»å‹
    UnsupportedMimeType,
    /// æ— æ•ˆçš„æ–‡ä»¶å¤´/é­”æ•°
    InvalidHeader,
    /// æ–‡ä»¶æ ¼å¼æŸå
    CorruptedFile,

    // å†…å®¹ç›¸å…³é”™è¯¯
    /// å›¾ç‰‡ç‚¸å¼¹ï¼ˆåƒç´ æ•°è¿‡å¤šï¼‰
    ImageBomb,
    /// è§†é¢‘æ—¶é•¿è¿‡é•¿
    VideoDurationTooLong,
    /// éŸ³é¢‘æ¯”ç‰¹ç‡å¼‚å¸¸
    InvalidAudioBitrate,
    /// æ£€æµ‹åˆ°å¯ç–‘å†…å®¹
    SuspiciousContent,
    /// æ¶æ„æ–‡ä»¶æ£€æµ‹
    MaliciousContent,

    // IPFSç›¸å…³é”™è¯¯
    /// CIDè¿‡é•¿
    CidTooLong,
    /// æ— æ•ˆCIDé•¿åº¦
    InvalidCidLength,
    /// æ— æ•ˆçš„CIDv0æ ¼å¼
    InvalidCidV0,
    /// æ— æ•ˆçš„CIDv1æ ¼å¼
    InvalidCidV1,
    /// æ— æ•ˆCIDå‰ç¼€
    InvalidCidPrefix,
    /// æ— æ•ˆCIDç¼–ç 
    InvalidCidEncoding,

    // å¤„ç†ç›¸å…³é”™è¯¯
    /// å†…å­˜ä¸è¶³
    OutOfMemory,
    /// å¤„ç†è¶…æ—¶
    ProcessTimeout,
    /// ä¸æ”¯æŒçš„æ“ä½œ
    UnsupportedOperation,
    /// å†…éƒ¨å¤„ç†é”™è¯¯
    InternalError,
}

impl MediaError {
    /// è·å–é”™è¯¯æè¿°
    pub fn description(&self) -> &'static str {
        match self {
            Self::FileTooSmall => "æ–‡ä»¶å¤ªå°ï¼Œä¸ç¬¦åˆæœ€å°å¤§å°è¦æ±‚",
            Self::FileTooLarge => "æ–‡ä»¶å¤ªå¤§ï¼Œè¶…è¿‡æœ€å¤§å¤§å°é™åˆ¶",
            Self::EmptyFile => "æ–‡ä»¶ä¸ºç©º",
            Self::UnsupportedFormat => "ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼",
            Self::UnsupportedMimeType => "ä¸æ”¯æŒçš„MIMEç±»å‹",
            Self::InvalidHeader => "æ— æ•ˆçš„æ–‡ä»¶å¤´",
            Self::CorruptedFile => "æ–‡ä»¶å·²æŸå",
            Self::ImageBomb => "å›¾ç‰‡åƒç´ æ•°è¿‡å¤šï¼Œå¯èƒ½æ˜¯å›¾ç‰‡ç‚¸å¼¹",
            Self::VideoDurationTooLong => "è§†é¢‘æ—¶é•¿è¶…è¿‡é™åˆ¶",
            Self::InvalidAudioBitrate => "éŸ³é¢‘æ¯”ç‰¹ç‡å¼‚å¸¸",
            Self::SuspiciousContent => "æ£€æµ‹åˆ°å¯ç–‘å†…å®¹",
            Self::MaliciousContent => "æ£€æµ‹åˆ°æ¶æ„æ–‡ä»¶",
            Self::CidTooLong => "CIDé•¿åº¦è¶…å‡ºé™åˆ¶",
            Self::InvalidCidLength => "CIDé•¿åº¦æ— æ•ˆ",
            Self::InvalidCidV0 => "æ— æ•ˆçš„CIDv0æ ¼å¼",
            Self::InvalidCidV1 => "æ— æ•ˆçš„CIDv1æ ¼å¼",
            Self::InvalidCidPrefix => "CIDå‰ç¼€æ— æ•ˆ",
            Self::InvalidCidEncoding => "CIDç¼–ç æ— æ•ˆ",
            Self::OutOfMemory => "å†…å­˜ä¸è¶³",
            Self::ProcessTimeout => "å¤„ç†è¶…æ—¶",
            Self::UnsupportedOperation => "ä¸æ”¯æŒçš„æ“ä½œ",
            Self::InternalError => "å†…éƒ¨å¤„ç†é”™è¯¯",
        }
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºè‡´å‘½é”™è¯¯ï¼ˆéœ€è¦åœæ­¢å¤„ç†ï¼‰
    pub fn is_fatal(&self) -> bool {
        matches!(
            self,
            Self::OutOfMemory
            | Self::MaliciousContent
            | Self::InternalError
        )
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºå®‰å…¨ç›¸å…³é”™è¯¯
    pub fn is_security_related(&self) -> bool {
        matches!(
            self,
            Self::ImageBomb
            | Self::SuspiciousContent
            | Self::MaliciousContent
        )
    }
}

/// éªŒè¯ç»“æœç±»å‹
pub type ValidationResult<T> = Result<T, MediaError>;
```

### 1.4 éªŒè¯å™¨å®ç°è§„èŒƒ

#### 1.4.1 é€šç”¨éªŒè¯æ¥å£

```rust
// src/validation/mod.rs

use crate::{MediaMetadata, MediaError, ValidationResult};

/// åª’ä½“éªŒè¯å™¨é€šç”¨æ¥å£
pub trait MediaValidator {
    /// éªŒè¯åª’ä½“å†…å®¹å¹¶è¿”å›å…ƒæ•°æ®
    fn validate(data: &[u8]) -> ValidationResult<MediaMetadata>;

    /// å¿«é€Ÿæ ¼å¼æ£€æµ‹ï¼ˆä¸å®Œæ•´éªŒè¯ï¼‰
    fn detect_format(data: &[u8]) -> ValidationResult<()>;

    /// æ£€æŸ¥æ–‡ä»¶å¤§å°é™åˆ¶
    fn check_size_limits(size: u64) -> ValidationResult<()>;

    /// å®‰å…¨æ£€æŸ¥ï¼ˆæ£€æµ‹æ¶æ„å†…å®¹ï¼‰
    fn security_check(data: &[u8]) -> ValidationResult<()>;
}

/// éªŒè¯é…ç½®
#[derive(Clone, Debug)]
pub struct ValidationConfig {
    /// æœ€å¤§æ–‡ä»¶å¤§å°
    pub max_file_size: u64,
    /// æ˜¯å¦å¯ç”¨å®‰å…¨æ£€æŸ¥
    pub enable_security_check: bool,
    /// æ˜¯å¦æå–å®Œæ•´å…ƒæ•°æ®
    pub extract_full_metadata: bool,
    /// å¤„ç†è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
    pub timeout_ms: u32,
}

impl Default for ValidationConfig {
    fn default() -> Self {
        Self {
            max_file_size: 50 * 1024 * 1024, // 50MB
            enable_security_check: true,
            extract_full_metadata: true,
            timeout_ms: 30000, // 30ç§’
        }
    }
}

// å¯¼å‡ºæ‰€æœ‰éªŒè¯å™¨
pub mod image;
pub mod video;
pub mod audio;
pub mod common;

pub use image::ImageValidator;
pub use video::VideoValidator;
pub use audio::AudioValidator;
pub use common::*;
```

#### 1.4.2 å›¾ç‰‡éªŒè¯å™¨è¯¦ç»†å®ç°

```rust
// src/validation/image.rs

use super::{MediaValidator, ValidationConfig};
use crate::{MediaKind, MediaMetadata, MediaError, ValidationResult};
use sp_core::{blake2_256, ConstU32};
use frame_support::BoundedVec;

/// å›¾ç‰‡æ ¼å¼æšä¸¾
#[derive(Clone, Copy, Debug, PartialEq)]
enum ImageFormat {
    JPEG,
    PNG,
    GIF,
    WebP,
    AVIF,
    BMP,
}

impl ImageFormat {
    /// è·å–MIMEç±»å‹
    fn mime_type(&self) -> &'static [u8] {
        match self {
            Self::JPEG => b"image/jpeg",
            Self::PNG => b"image/png",
            Self::GIF => b"image/gif",
            Self::WebP => b"image/webp",
            Self::AVIF => b"image/avif",
            Self::BMP => b"image/bmp",
        }
    }

    /// è·å–æ–‡ä»¶æ‰©å±•å
    fn extension(&self) -> &'static str {
        match self {
            Self::JPEG => "jpg",
            Self::PNG => "png",
            Self::GIF => "gif",
            Self::WebP => "webp",
            Self::AVIF => "avif",
            Self::BMP => "bmp",
        }
    }
}

/// å›¾ç‰‡éªŒè¯å™¨å®ç°
pub struct ImageValidator;

impl MediaValidator for ImageValidator {
    fn validate(data: &[u8]) -> ValidationResult<MediaMetadata> {
        // 1. åŸºç¡€æ£€æŸ¥
        Self::check_size_limits(data.len() as u64)?;

        // 2. æ ¼å¼æ£€æµ‹
        let format = Self::detect_image_format(data)?;

        // 3. å®‰å…¨æ£€æŸ¥
        Self::security_check(data)?;

        // 4. æå–å…ƒæ•°æ®
        Self::extract_metadata(data, format)
    }

    fn detect_format(data: &[u8]) -> ValidationResult<()> {
        Self::detect_image_format(data).map(|_| ())
    }

    fn check_size_limits(size: u64) -> ValidationResult<()> {
        const MIN_SIZE: u64 = 100;  // 100å­—èŠ‚
        const MAX_SIZE: u64 = 50 * 1024 * 1024;  // 50MB

        if size < MIN_SIZE {
            return Err(MediaError::FileTooSmall);
        }

        if size > MAX_SIZE {
            return Err(MediaError::FileTooLarge);
        }

        Ok(())
    }

    fn security_check(data: &[u8]) -> ValidationResult<()> {
        // 1. æ£€æŸ¥å›¾ç‰‡ç‚¸å¼¹
        if let Ok(format) = Self::detect_image_format(data) {
            if let Ok(metadata) = Self::extract_basic_metadata(data, format) {
                Self::check_image_bomb(metadata.width, metadata.height)?;
            }
        }

        // 2. æ£€æŸ¥å¯ç–‘å†…å®¹
        Self::check_suspicious_content(data)?;

        Ok(())
    }
}

impl ImageValidator {
    /// æ£€æµ‹å›¾ç‰‡æ ¼å¼
    pub fn detect_image_format(data: &[u8]) -> ValidationResult<ImageFormat> {
        if data.len() < 12 {
            return Err(MediaError::InvalidHeader);
        }

        // æ£€æŸ¥æ–‡ä»¶å¤´é­”æ•°
        match &data[0..] {
            // JPEGæ ¼å¼: FF D8 FF
            data if data.starts_with(&[0xFF, 0xD8, 0xFF]) => Ok(ImageFormat::JPEG),

            // PNGæ ¼å¼: 89 50 4E 47 0D 0A 1A 0A
            data if data.starts_with(&[0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]) =>
                Ok(ImageFormat::PNG),

            // GIFæ ¼å¼: 47 49 46 38 (GIF8)
            data if data.starts_with(b"GIF8") => Ok(ImageFormat::GIF),

            // WebPæ ¼å¼: RIFF....WEBP
            data if data.len() >= 12 &&
                   data.starts_with(b"RIFF") &&
                   &data[8..12] == b"WEBP" => Ok(ImageFormat::WebP),

            // AVIFæ ¼å¼: ....ftypavif
            data if data.len() >= 12 &&
                   &data[4..12] == b"ftypavif" => Ok(ImageFormat::AVIF),

            // BMPæ ¼å¼: 42 4D (BM)
            data if data.starts_with(b"BM") => Ok(ImageFormat::BMP),

            _ => Err(MediaError::UnsupportedFormat),
        }
    }

    /// æ£€æŸ¥å›¾ç‰‡ç‚¸å¼¹
    pub fn check_image_bomb(width: Option<u32>, height: Option<u32>) -> ValidationResult<()> {
        const MAX_PIXELS: u64 = 100_000_000; // 1äº¿åƒç´ 
        const MAX_DIMENSION: u32 = 65536;     // å•è¾¹æœ€å¤§65536åƒç´ 

        match (width, height) {
            (Some(w), Some(h)) => {
                // æ£€æŸ¥å•è¾¹å°ºå¯¸
                if w > MAX_DIMENSION || h > MAX_DIMENSION {
                    return Err(MediaError::ImageBomb);
                }

                // æ£€æŸ¥æ€»åƒç´ æ•°
                let pixels = w as u64 * h as u64;
                if pixels > MAX_PIXELS {
                    return Err(MediaError::ImageBomb);
                }
            },
            _ => {}, // æ— æ³•è·å–å°ºå¯¸ï¼Œè·³è¿‡æ£€æŸ¥
        }

        Ok(())
    }

    /// æ£€æŸ¥å¯ç–‘å†…å®¹
    fn check_suspicious_content(data: &[u8]) -> ValidationResult<()> {
        // 1. æ£€æŸ¥æ˜¯å¦åŒ…å«å¯æ‰§è¡Œä»£ç æ ‡è¯†
        const SUSPICIOUS_PATTERNS: &[&[u8]] = &[
            b"<script",
            b"javascript:",
            b"data:text/html",
            b"<?php",
            b"#!/bin/",
        ];

        for pattern in SUSPICIOUS_PATTERNS {
            if Self::contains_pattern(data, pattern) {
                return Err(MediaError::SuspiciousContent);
            }
        }

        // 2. æ£€æŸ¥å¼‚å¸¸å¤§çš„EXIFæ•°æ®
        if let Ok(ImageFormat::JPEG) = Self::detect_image_format(data) {
            if let Some(exif_size) = Self::get_exif_size(data) {
                if exif_size > 1024 * 1024 {  // EXIFè¶…è¿‡1MBè®¤ä¸ºå¼‚å¸¸
                    return Err(MediaError::SuspiciousContent);
                }
            }
        }

        Ok(())
    }

    /// æå–å®Œæ•´å…ƒæ•°æ®
    fn extract_metadata(data: &[u8], format: ImageFormat) -> ValidationResult<MediaMetadata> {
        let mut metadata = MediaMetadata {
            kind: MediaKind::Photo,
            file_size: data.len() as u64,
            mime_type: BoundedVec::try_from(format.mime_type().to_vec())
                .map_err(|_| MediaError::InternalError)?,
            content_hash: blake2_256(data),
            width: None,
            height: None,
            duration_secs: None,
            bitrate: None,
            fps: None,
            created_at: None,
            has_alpha: None,
            color_space: None,
        };

        // æ ¹æ®æ ¼å¼æå–ç‰¹å®šå…ƒæ•°æ®
        match format {
            ImageFormat::JPEG => {
                Self::extract_jpeg_metadata(data, &mut metadata)?;
            },
            ImageFormat::PNG => {
                Self::extract_png_metadata(data, &mut metadata)?;
            },
            ImageFormat::GIF => {
                Self::extract_gif_metadata(data, &mut metadata)?;
            },
            ImageFormat::WebP => {
                Self::extract_webp_metadata(data, &mut metadata)?;
            },
            _ => {
                // å…¶ä»–æ ¼å¼çš„åŸºç¡€æå–
                Self::extract_basic_dimensions(data, format, &mut metadata)?;
            }
        }

        // æœ€ç»ˆéªŒè¯
        if !metadata.is_valid_image_size() {
            return Err(MediaError::InvalidHeader);
        }

        Ok(metadata)
    }

    /// æå–åŸºç¡€å…ƒæ•°æ®ï¼ˆç”¨äºå®‰å…¨æ£€æŸ¥ï¼‰
    fn extract_basic_metadata(data: &[u8], format: ImageFormat) -> ValidationResult<MediaMetadata> {
        let mut metadata = MediaMetadata::new(MediaKind::Photo, data);
        metadata.mime_type = BoundedVec::try_from(format.mime_type().to_vec())
            .map_err(|_| MediaError::InternalError)?;

        Self::extract_basic_dimensions(data, format, &mut metadata)?;
        Ok(metadata)
    }

    /// æå–JPEGå…ƒæ•°æ®
    fn extract_jpeg_metadata(data: &[u8], metadata: &mut MediaMetadata) -> ValidationResult<()> {
        // æŸ¥æ‰¾SOF (Start of Frame) æ ‡è®°
        let mut i = 0;
        while i + 10 < data.len() {
            if data[i] == 0xFF {
                match data[i + 1] {
                    // SOF0 - SOF15 (é™¤SOF4, SOF8, SOF12å¤–)
                    0xC0..=0xCF if data[i + 1] != 0xC4 && data[i + 1] != 0xC8 && data[i + 1] != 0xCC => {
                        // SOFæ ‡è®°æ ¼å¼: FF Cn Lh Ll P Y1 Y0 X1 X0 ...
                        if i + 9 < data.len() {
                            let height = u16::from_be_bytes([data[i + 5], data[i + 6]]) as u32;
                            let width = u16::from_be_bytes([data[i + 7], data[i + 8]]) as u32;

                            metadata.width = Some(width);
                            metadata.height = Some(height);

                            // æ£€æŸ¥è‰²å½©ç©ºé—´
                            if i + 9 < data.len() {
                                let components = data[i + 9];
                                metadata.color_space = match components {
                                    1 => Some(BoundedVec::try_from(b"grayscale".to_vec()).ok()?),
                                    3 => Some(BoundedVec::try_from(b"rgb".to_vec()).ok()?),
                                    4 => Some(BoundedVec::try_from(b"cmyk".to_vec()).ok()?),
                                    _ => None,
                                };
                            }

                            return Ok(());
                        }
                    },
                    _ => {}
                }
            }
            i += 1;
        }

        Err(MediaError::InvalidHeader)
    }

    /// æå–PNGå…ƒæ•°æ®
    fn extract_png_metadata(data: &[u8], metadata: &mut MediaMetadata) -> ValidationResult<()> {
        // PNGç»“æ„: 8å­—èŠ‚ç­¾å + å—(å—é•¿åº¦ + å—ç±»å‹ + å—æ•°æ® + CRC)
        if data.len() < 33 {  // 8å­—èŠ‚ç­¾å + 25å­—èŠ‚IHDRå—
            return Err(MediaError::InvalidHeader);
        }

        // æ£€æŸ¥PNGç­¾å
        if &data[0..8] != &[0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A] {
            return Err(MediaError::InvalidHeader);
        }

        // è¯»å–IHDRå—ï¼ˆç¬¬ä¸€ä¸ªæ•°æ®å—ï¼‰
        let chunk_length = u32::from_be_bytes([data[8], data[9], data[10], data[11]]);
        if chunk_length != 13 {  // IHDRå›ºå®š13å­—èŠ‚
            return Err(MediaError::InvalidHeader);
        }

        // æ£€æŸ¥å—ç±»å‹æ˜¯å¦ä¸ºIHDR
        if &data[12..16] != b"IHDR" {
            return Err(MediaError::InvalidHeader);
        }

        // æå–IHDRæ•°æ®
        let width = u32::from_be_bytes([data[16], data[17], data[18], data[19]]);
        let height = u32::from_be_bytes([data[20], data[21], data[22], data[23]]);
        let bit_depth = data[24];
        let color_type = data[25];

        metadata.width = Some(width);
        metadata.height = Some(height);

        // æ£€æŸ¥æ˜¯å¦æœ‰é€æ˜é€šé“
        metadata.has_alpha = Some(match color_type {
            2 => false,  // RGB
            4 => true,   // Grayscale + Alpha
            6 => true,   // RGB + Alpha
            _ => false,
        });

        // è®¾ç½®è‰²å½©ç©ºé—´ä¿¡æ¯
        metadata.color_space = Some(match color_type {
            0 => BoundedVec::try_from(b"grayscale".to_vec()).ok()?,
            2 | 3 => BoundedVec::try_from(b"rgb".to_vec()).ok()?,
            4 => BoundedVec::try_from(b"gray_alpha".to_vec()).ok()?,
            6 => BoundedVec::try_from(b"rgba".to_vec()).ok()?,
            _ => BoundedVec::try_from(b"unknown".to_vec()).ok()?,
        });

        Ok(())
    }

    /// æå–GIFå…ƒæ•°æ®
    fn extract_gif_metadata(data: &[u8], metadata: &mut MediaMetadata) -> ValidationResult<()> {
        // GIFç»“æ„: 6å­—èŠ‚å¤´ + é€»è¾‘å±å¹•æè¿°ç¬¦
        if data.len() < 10 {
            return Err(MediaError::InvalidHeader);
        }

        // æ£€æŸ¥GIFå¤´
        if !data.starts_with(b"GIF87a") && !data.starts_with(b"GIF89a") {
            return Err(MediaError::InvalidHeader);
        }

        // æå–å°ºå¯¸ï¼ˆå°ç«¯åºï¼‰
        let width = u16::from_le_bytes([data[6], data[7]]) as u32;
        let height = u16::from_le_bytes([data[8], data[9]]) as u32;

        metadata.width = Some(width);
        metadata.height = Some(height);
        metadata.color_space = Some(BoundedVec::try_from(b"indexed".to_vec()).ok()?);

        Ok(())
    }

    /// æå–WebPå…ƒæ•°æ®
    fn extract_webp_metadata(data: &[u8], metadata: &mut MediaMetadata) -> ValidationResult<()> {
        if data.len() < 20 {
            return Err(MediaError::InvalidHeader);
        }

        // æ£€æŸ¥RIFFå¤´å’ŒWEBPæ ‡è¯†
        if !data.starts_with(b"RIFF") || &data[8..12] != b"WEBP" {
            return Err(MediaError::InvalidHeader);
        }

        // WebPæœ‰å¤šç§æ ¼å¼ï¼Œè¿™é‡Œå¤„ç†æœ€å¸¸è§çš„VP8å’ŒVP8L
        if data.len() >= 30 && &data[12..16] == b"VP8 " {
            // VP8 (æœ‰æŸ)æ ¼å¼
            if let Some((width, height)) = Self::extract_vp8_dimensions(&data[20..]) {
                metadata.width = Some(width);
                metadata.height = Some(height);
            }
        } else if data.len() >= 30 && &data[12..16] == b"VP8L" {
            // VP8L (æ— æŸ)æ ¼å¼
            if let Some((width, height)) = Self::extract_vp8l_dimensions(&data[20..]) {
                metadata.width = Some(width);
                metadata.height = Some(height);
                metadata.has_alpha = Some(true);  // VP8Læ”¯æŒé€æ˜é€šé“
            }
        }

        Ok(())
    }

    /// æå–åŸºç¡€å°ºå¯¸ä¿¡æ¯ï¼ˆé€šç”¨æ–¹æ³•ï¼‰
    fn extract_basic_dimensions(
        data: &[u8],
        format: ImageFormat,
        metadata: &mut MediaMetadata
    ) -> ValidationResult<()> {
        match format {
            ImageFormat::JPEG => Self::extract_jpeg_metadata(data, metadata),
            ImageFormat::PNG => Self::extract_png_metadata(data, metadata),
            ImageFormat::GIF => Self::extract_gif_metadata(data, metadata),
            ImageFormat::WebP => Self::extract_webp_metadata(data, metadata),
            _ => {
                // ä¸æ”¯æŒçš„æ ¼å¼ï¼Œè¿”å›åŸºç¡€ä¿¡æ¯
                Ok(())
            }
        }
    }

    /// è¾…åŠ©æ–¹æ³•: æ£€æŸ¥æ•°æ®ä¸­æ˜¯å¦åŒ…å«ç‰¹å®šæ¨¡å¼
    fn contains_pattern(data: &[u8], pattern: &[u8]) -> bool {
        if pattern.is_empty() || data.len() < pattern.len() {
            return false;
        }

        for i in 0..=(data.len() - pattern.len()) {
            if data[i..i + pattern.len()].eq_ignore_ascii_case(pattern) {
                return true;
            }
        }

        false
    }

    /// è¾…åŠ©æ–¹æ³•: è·å–JPEG EXIFæ•°æ®å¤§å°
    fn get_exif_size(data: &[u8]) -> Option<u32> {
        // æŸ¥æ‰¾EXIFæ ‡è®° (FF E1)
        for i in 0..data.len().saturating_sub(10) {
            if data[i] == 0xFF && data[i + 1] == 0xE1 {
                if i + 4 < data.len() {
                    let exif_length = u16::from_be_bytes([data[i + 2], data[i + 3]]) as u32;
                    return Some(exif_length);
                }
            }
        }
        None
    }

    /// è¾…åŠ©æ–¹æ³•: æå–VP8å°ºå¯¸
    fn extract_vp8_dimensions(vp8_data: &[u8]) -> Option<(u32, u32)> {
        if vp8_data.len() < 10 {
            return None;
        }

        // VP8æ ¼å¼æ¯”è¾ƒå¤æ‚ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†
        // å®é™…å®ç°éœ€è¦å®Œæ•´çš„VP8è§£æ
        None
    }

    /// è¾…åŠ©æ–¹æ³•: æå–VP8Lå°ºå¯¸
    fn extract_vp8l_dimensions(vp8l_data: &[u8]) -> Option<(u32, u32)> {
        if vp8l_data.len() < 5 {
            return None;
        }

        // VP8Lå¤´æ ¼å¼: 1å­—èŠ‚ç­¾å + 4å­—èŠ‚å°ºå¯¸ä¿¡æ¯
        if vp8l_data[0] != 0x2F {  // VP8Lç­¾å
            return None;
        }

        // æå–å®½åº¦å’Œé«˜åº¦ (14ä½ + 14ä½)
        let size_data = u32::from_le_bytes([
            vp8l_data[1], vp8l_data[2], vp8l_data[3], vp8l_data[4]
        ]);

        let width = (size_data & 0x3FFF) + 1;
        let height = ((size_data >> 14) & 0x3FFF) + 1;

        Some((width, height))
    }
}

// å•å…ƒæµ‹è¯•
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_jpeg_format_detection() {
        let jpeg_header = [0xFF, 0xD8, 0xFF, 0xE0];
        assert_eq!(
            ImageValidator::detect_image_format(&jpeg_header).unwrap(),
            ImageFormat::JPEG
        );
    }

    #[test]
    fn test_png_format_detection() {
        let png_header = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
        assert_eq!(
            ImageValidator::detect_image_format(&png_header).unwrap(),
            ImageFormat::PNG
        );
    }

    #[test]
    fn test_image_bomb_detection() {
        // æ­£å¸¸å°ºå¯¸
        assert!(ImageValidator::check_image_bomb(Some(1920), Some(1080)).is_ok());

        // è¿‡å¤§å°ºå¯¸
        assert!(ImageValidator::check_image_bomb(Some(100000), Some(100000)).is_err());
    }

    #[test]
    fn test_file_size_limits() {
        // æ­£å¸¸å¤§å°
        assert!(ImageValidator::check_size_limits(1024 * 1024).is_ok());

        // è¿‡å°
        assert!(ImageValidator::check_size_limits(50).is_err());

        // è¿‡å¤§
        assert!(ImageValidator::check_size_limits(100 * 1024 * 1024).is_err());
    }
}
```

---

## 2. å„æ¨¡å—é›†æˆå®æ–½è§„èŒƒ

### 2.1 é›†æˆé¡ºåºä¸ä¼˜å…ˆçº§

**æ¨èé›†æˆé¡ºåº**:
1. **Deceasedæ¨¡å—** (ä¼˜å…ˆçº§: é«˜) - ç»“æ„æœ€ç¨³å®šï¼Œä¸šåŠ¡é€»è¾‘æœ€æ¸…æ™°
2. **Evidenceæ¨¡å—** (ä¼˜å…ˆçº§: ä¸­) - æ¥å£æœ€ç®€å•ï¼Œå½±å“èŒƒå›´æœ€å°
3. **GroupChatæ¨¡å—** (ä¼˜å…ˆçº§: ä½) - æœ€å¤æ‚ï¼Œéœ€è¦å¤„ç†åŠ å¯†é€»è¾‘

### 2.2 Deceasedæ¨¡å—é›†æˆæŒ‡å¯¼

#### 2.2.1 ä¾èµ–é…ç½®

```toml
# pallets/deceased/Cargo.toml
[dependencies]
# ç°æœ‰ä¾èµ–ä¿æŒä¸å˜...

# æ–°å¢: å…±äº«åª’ä½“å·¥å…·åº“
stardust-media-common = { path = "../../stardust-media-common", default-features = false }

[features]
default = ["std"]
std = [
    # ç°æœ‰std features...
    "stardust-media-common/std",
]
```

#### 2.2.2 ä»£ç é›†æˆç¤ºä¾‹

```rust
// pallets/deceased/src/lib.rs

// æ·»åŠ å·¥å…·åº“å¯¼å…¥
use stardust_media_common::{
    MediaKind, MediaMetadata,
    ImageValidator, VideoValidator, AudioValidator,
    HashHelper, IpfsHelper,
    MediaError
};

impl<T: Config> Pallet<T> {
    /// å‡çº§åçš„ç…§ç‰‡ä¸Šä¼ å‡½æ•°
    pub fn upload_photo_to_album(
        origin: OriginFor<T>,
        deceased_id: T::DeceasedId,
        album_id: T::AlbumId,
        photo_data: Vec<u8>,
    ) -> DispatchResult {
        let who = ensure_signed(origin)?;

        // âœ… æƒé™æ£€æŸ¥ (ä¿æŒåŸæœ‰é€»è¾‘)
        let album = Albums::<T>::get(album_id)
            .ok_or(Error::<T>::AlbumNotFound)?;
        ensure!(album.deceased_id == deceased_id, Error::<T>::AlbumDeceasedMismatch);

        // æ£€æŸ¥ä¸Šä¼ æƒé™
        Self::check_media_upload_permission(&who, deceased_id)?;

        // âœ… ä½¿ç”¨å·¥å…·åº“éªŒè¯å›¾ç‰‡
        let metadata = ImageValidator::validate(&photo_data)
            .map_err(Self::convert_media_error)?;

        // âœ… ä½¿ç”¨å·¥å…·åº“è®¡ç®—å“ˆå¸Œ
        let content_hash = HashHelper::content_hash(&photo_data);

        // âœ… ä¸Šä¼ åˆ°IPFS (ä¿æŒåŸæœ‰é€»è¾‘)
        let cid = T::IpfsPinner::request_pin_for_deceased(
            who.clone(),
            deceased_id.into(),
            photo_data,
            PinTier::Critical,
        )?;

        // âœ… åˆ›å»ºåª’ä½“è®°å½• (ä½¿ç”¨å…±äº«ç±»å‹)
        let media_id = Self::next_media_id();
        let media = Media {
            id: media_id,
            album_id: Some(album_id),
            video_collection_id: None,
            deceased_id,
            kind: MediaKind::Photo,  // ä½¿ç”¨å…±äº«ç±»å‹
            uri: cid,
            thumbnail_uri: None,
            content_hash: Some(content_hash),
            width: metadata.width,
            height: metadata.height,
            duration_secs: None,
            order_index: Self::get_next_order_index(album_id),
            created: <frame_system::Pallet<T>>::block_number(),
            updated: <frame_system::Pallet<T>>::block_number(),
            version: 1,
        };

        // å­˜å‚¨åª’ä½“è®°å½•
        MediaRegistry::<T>::insert(media_id, &media);

        // æ›´æ–°ç›¸å†Œåª’ä½“åˆ—è¡¨
        AlbumMediaList::<T>::try_mutate(album_id, |list| -> DispatchResult {
            list.try_push(media_id).map_err(|_| Error::<T>::AlbumFull)?;
            Ok(())
        })?;

        // å‘å‡ºäº‹ä»¶
        Self::deposit_event(Event::PhotoUploaded {
            media_id,
            album_id,
            deceased_id,
            uploader: who,
            file_size: metadata.file_size,
        });

        Ok(())
    }

    /// é”™è¯¯è½¬æ¢å‡½æ•°
    fn convert_media_error(error: MediaError) -> Error<T> {
        match error {
            MediaError::FileTooSmall => Error::<T>::FileTooSmall,
            MediaError::FileTooLarge => Error::<T>::FileTooLarge,
            MediaError::UnsupportedFormat => Error::<T>::UnsupportedImageFormat,
            MediaError::InvalidHeader => Error::<T>::CorruptedImage,
            MediaError::ImageBomb => Error::<T>::ImageTooLarge,
            MediaError::SuspiciousContent => Error::<T>::SuspiciousContent,
            MediaError::MaliciousContent => Error::<T>::MaliciousContent,
            _ => Error::<T>::ImageProcessingFailed,
        }
    }

    /// æ£€æŸ¥åª’ä½“ä¸Šä¼ æƒé™
    fn check_media_upload_permission(
        who: &T::AccountId,
        deceased_id: T::DeceasedId,
    ) -> DispatchResult {
        // æ£€æŸ¥æ˜¯å¦ä¸ºå¢“ä¸»æˆ–æˆæƒç®¡ç†å‘˜
        let deceased = DeceasedRegistry::<T>::get(deceased_id)
            .ok_or(Error::<T>::DeceasedNotFound)?;

        if deceased.owner == *who {
            return Ok(());
        }

        // æ£€æŸ¥æ˜¯å¦ä¸ºæˆæƒç®¡ç†å‘˜
        if DeceasedAdmins::<T>::contains_key((deceased_id, who)) {
            return Ok(());
        }

        Err(Error::<T>::NoUploadPermission.into())
    }
}

// æ·»åŠ æ–°çš„é”™è¯¯ç±»å‹
#[pallet::error]
pub enum Error<T> {
    // ç°æœ‰é”™è¯¯...

    // æ–°å¢åª’ä½“ç›¸å…³é”™è¯¯
    /// æ–‡ä»¶å¤ªå°
    FileTooSmall,
    /// æ–‡ä»¶å¤ªå¤§
    FileTooLarge,
    /// ä¸æ”¯æŒçš„å›¾ç‰‡æ ¼å¼
    UnsupportedImageFormat,
    /// å›¾ç‰‡æŸå
    CorruptedImage,
    /// å›¾ç‰‡è¿‡å¤§(åƒç´ æ•°)
    ImageTooLarge,
    /// æ£€æµ‹åˆ°å¯ç–‘å†…å®¹
    SuspiciousContent,
    /// æ£€æµ‹åˆ°æ¶æ„å†…å®¹
    MaliciousContent,
    /// å›¾ç‰‡å¤„ç†å¤±è´¥
    ImageProcessingFailed,
    /// æ— ä¸Šä¼ æƒé™
    NoUploadPermission,
}
```

### 2.3 Evidenceæ¨¡å—é›†æˆæŒ‡å¯¼

```rust
// pallets/evidence/src/lib.rs

use stardust_media_common::{
    MediaKind, MediaMetadata,
    ImageValidator, VideoValidator,
    HashHelper, MediaError
};

impl<T: Config> Pallet<T> {
    /// å‡çº§åçš„è¯æ®æäº¤å‡½æ•°
    pub fn submit_image_evidence(
        origin: OriginFor<T>,
        domain: u8,
        target_id: u64,
        image_data: Vec<u8>,
        is_encrypted: bool,
        description: Option<BoundedVec<u8, T::MaxDescriptionLen>>,
    ) -> DispatchResult {
        let who = ensure_signed(origin)?;

        // âœ… ä½¿ç”¨å·¥å…·åº“éªŒè¯å›¾ç‰‡
        let metadata = ImageValidator::validate(&image_data)
            .map_err(Self::convert_media_error)?;

        // âœ… è®¡ç®—å†…å®¹å“ˆå¸Œ
        let content_hash = HashHelper::content_hash(&image_data);

        // âœ… ä¸Šä¼ åˆ°IPFS
        let cid = T::IpfsPinner::request_pin(
            who.clone(),
            image_data,
            PinTier::Critical,  // è¯æ®éœ€è¦æœ€é«˜çº§åˆ«ä¿å­˜
        )?;

        // âœ… è®¡ç®—æ‰¿è¯ºå“ˆå¸Œ
        let evidence_id = Self::next_evidence_id();
        let ns = Self::get_namespace(domain, target_id);
        let salt = Self::generate_salt(&who, evidence_id);
        let commit = HashHelper::evidence_commitment(
            &ns,
            target_id,
            &cid,
            &salt,
            1, // version
        );

        // âœ… åˆ›å»ºè¯æ®è®°å½•
        let evidence = Evidence {
            id: evidence_id,
            domain,
            target_id,
            owner: who.clone(),
            content_cid: cid,
            content_type: ContentType::Image,
            content_hash: Some(content_hash),
            file_size: metadata.file_size,
            created_at: <frame_system::Pallet<T>>::block_number(),
            is_encrypted,
            encryption_scheme: None,
            commit: Some(commit),
            ns: Some(ns),
            description,
        };

        Evidences::<T>::insert(evidence_id, &evidence);

        // æ›´æ–°ç´¢å¼•
        DomainEvidences::<T>::try_mutate((domain, target_id), |list| -> DispatchResult {
            list.try_push(evidence_id).map_err(|_| Error::<T>::TooManyEvidences)?;
            Ok(())
        })?;

        Self::deposit_event(Event::EvidenceSubmitted {
            evidence_id,
            domain,
            target_id,
            submitter: who,
            content_type: ContentType::Image,
            file_size: metadata.file_size,
        });

        Ok(())
    }

    /// é”™è¯¯è½¬æ¢å‡½æ•°
    fn convert_media_error(error: MediaError) -> Error<T> {
        match error {
            MediaError::FileTooSmall => Error::<T>::FileTooSmall,
            MediaError::FileTooLarge => Error::<T>::FileTooLarge,
            MediaError::UnsupportedFormat => Error::<T>::UnsupportedFormat,
            MediaError::InvalidHeader => Error::<T>::CorruptedFile,
            MediaError::SuspiciousContent => Error::<T>::SuspiciousContent,
            _ => Error::<T>::ValidationFailed,
        }
    }
}
```

### 2.4 GroupChatæ¨¡å—é›†æˆæŒ‡å¯¼

```rust
// pallets/smart-group-chat/src/lib.rs

use stardust_media_common::{
    MediaKind, MediaMetadata,
    ImageValidator, VideoValidator, AudioValidator,
    HashHelper, MediaError
};

impl<T: Config> Pallet<T> {
    /// å‡çº§åçš„å‘é€å›¾ç‰‡æ¶ˆæ¯å‡½æ•°
    pub fn send_image_message(
        origin: OriginFor<T>,
        group_id: GroupId,
        image_data: Vec<u8>,
        encryption_mode: EncryptionMode,
        is_ephemeral: bool,
    ) -> DispatchResult {
        let who = ensure_signed(origin)?;

        // âœ… æƒé™æ£€æŸ¥ (ä¿æŒåŸæœ‰é€»è¾‘)
        ensure!(
            GroupMembers::<T>::contains_key((group_id, &who)),
            Error::<T>::NotMember
        );

        let group = GroupInfos::<T>::get(group_id)
            .ok_or(Error::<T>::GroupNotFound)?;

        // âœ… ä½¿ç”¨å·¥å…·åº“éªŒè¯å›¾ç‰‡
        let metadata = ImageValidator::validate(&image_data)
            .map_err(Self::convert_media_error)?;

        // âœ… GroupChatç‹¬ç‰¹ä¸šåŠ¡ï¼šé‡å­æŠ—æ€§åŠ å¯†
        let processed_data = match encryption_mode {
            EncryptionMode::Military => {
                // ä½¿ç”¨Kyberé‡å­æŠ—æ€§åŠ å¯†
                Self::quantum_encrypt(&image_data, group_id)?
            },
            EncryptionMode::Business => {
                // ä½¿ç”¨æ ‡å‡†AESåŠ å¯†
                Self::standard_encrypt(&image_data, group_id)?
            },
            EncryptionMode::Selective => {
                // é€‰æ‹©æ€§åŠ å¯†ï¼ˆéƒ¨åˆ†æˆå‘˜å¯è§ï¼‰
                Self::selective_encrypt(&image_data, group_id, &who)?
            },
            EncryptionMode::Transparent => image_data,
        };

        // âœ… ä¸Šä¼ åˆ°IPFS
        let storage_tier = if is_ephemeral {
            PinTier::Temporary
        } else {
            PinTier::Standard
        };

        let cid = T::IpfsPinner::request_pin(
            who.clone(),
            processed_data,
            storage_tier,
        )?;

        // âœ… åˆ›å»ºæ¶ˆæ¯è®°å½•
        let message_id = Self::next_message_id();
        let message = GroupMessageMeta {
            id: message_id,
            group_id,
            sender: who.clone(),
            content: cid,
            message_type: MessageType::Image,
            encryption_mode,
            storage_tier: if is_ephemeral {
                StorageTier::Temporary
            } else {
                StorageTier::IPFS
            },
            sent_at: Self::current_timestamp(),
            temp_id: if is_ephemeral { Some(Self::generate_temp_id()) } else { None },
            confirmation_status: ConfirmationStatus::Pending,
            ai_analysis: None, // å°†åœ¨åå°å¼‚æ­¥åˆ†æ
            access_count: 0,
            last_accessed: 0,
            file_size: Some(metadata.file_size),
            content_hash: Some(HashHelper::content_hash(&image_data)),
        };

        Messages::<T>::insert(message_id, &message);

        // æ›´æ–°ç¾¤ç»„æ¶ˆæ¯åˆ—è¡¨
        GroupMessages::<T>::try_mutate(group_id, |list| -> DispatchResult {
            list.try_push(message_id).map_err(|_| Error::<T>::MessageQueueFull)?;
            Ok(())
        })?;

        // âœ… GroupChatç‹¬ç‰¹ä¸šåŠ¡ï¼šä¸´æ—¶æ¶ˆæ¯å¤„ç†
        if is_ephemeral {
            // æ·»åŠ åˆ°ä¸´æ—¶æ¶ˆæ¯æ¸…ç†é˜Ÿåˆ—
            Self::schedule_ephemeral_cleanup(message_id, Self::current_timestamp() + T::EphemeralTtl::get());
        }

        // âœ… è§¦å‘AIå†…å®¹åˆ†æï¼ˆå¼‚æ­¥ï¼‰
        Self::queue_ai_analysis(message_id, &image_data);

        Self::deposit_event(Event::ImageMessageSent {
            message_id,
            group_id,
            sender: who,
            is_ephemeral,
            file_size: metadata.file_size,
        });

        Ok(())
    }

    /// é‡å­æŠ—æ€§åŠ å¯†å®ç°
    fn quantum_encrypt(data: &[u8], group_id: GroupId) -> Result<Vec<u8>, Error<T>> {
        // è·å–ç¾¤ç»„çš„Kyberå¯†é’¥
        let kyber_key = GroupKyberKeys::<T>::get(group_id)
            .ok_or(Error::<T>::NoKyberKey)?;

        // ä½¿ç”¨KyberåŠ å¯†
        kyber_encrypt(data, &kyber_key)
            .map_err(|_| Error::<T>::EncryptionFailed)
    }

    /// é”™è¯¯è½¬æ¢å‡½æ•°
    fn convert_media_error(error: MediaError) -> Error<T> {
        match error {
            MediaError::FileTooSmall => Error::<T>::FileTooSmall,
            MediaError::FileTooLarge => Error::<T>::FileTooLarge,
            MediaError::UnsupportedFormat => Error::<T>::UnsupportedFormat,
            MediaError::SuspiciousContent => Error::<T>::SuspiciousContent,
            _ => Error::<T>::MediaValidationFailed,
        }
    }
}
```

---

## 3. è´¨é‡ä¿è¯ä¸æµ‹è¯•è§„èŒƒ

### 3.1 å•å…ƒæµ‹è¯•è¦æ±‚

#### 3.1.1 å·¥å…·åº“æµ‹è¯•è¦†ç›–ç‡

**ç›®æ ‡è¦†ç›–ç‡**: â‰¥85%

**å¿…é¡»æµ‹è¯•çš„åŠŸèƒ½**:
```rust
// tests/validation_tests.rs

#[cfg(test)]
mod validation_tests {
    use super::*;
    use stardust_media_common::*;

    #[test]
    fn test_image_validation_success() {
        // æµ‹è¯•æœ‰æ•ˆçš„JPEGå›¾ç‰‡
        let jpeg_data = include_bytes!("fixtures/test_image.jpg");
        let result = ImageValidator::validate(jpeg_data);
        assert!(result.is_ok());

        let metadata = result.unwrap();
        assert_eq!(metadata.kind, MediaKind::Photo);
        assert!(metadata.width.is_some());
        assert!(metadata.height.is_some());
    }

    #[test]
    fn test_image_validation_failure() {
        // æµ‹è¯•æ— æ•ˆæ•°æ®
        let invalid_data = b"not an image";
        let result = ImageValidator::validate(invalid_data);
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), MediaError::UnsupportedFormat);
    }

    #[test]
    fn test_image_bomb_detection() {
        // æµ‹è¯•å›¾ç‰‡ç‚¸å¼¹æ£€æµ‹
        assert!(ImageValidator::check_image_bomb(Some(100000), Some(100000)).is_err());
        assert!(ImageValidator::check_image_bomb(Some(1920), Some(1080)).is_ok());
    }

    #[test]
    fn test_file_size_limits() {
        // æµ‹è¯•æ–‡ä»¶å¤§å°é™åˆ¶
        assert!(ImageValidator::check_size_limits(50).is_err()); // å¤ªå°
        assert!(ImageValidator::check_size_limits(100 * 1024 * 1024).is_err()); // å¤ªå¤§
        assert!(ImageValidator::check_size_limits(1024 * 1024).is_ok()); // æ­£å¸¸
    }

    #[test]
    fn test_hash_functions() {
        let data = b"test data";
        let hash1 = HashHelper::content_hash(data);
        let hash2 = HashHelper::content_hash(data);
        assert_eq!(hash1, hash2); // ç›¸åŒè¾“å…¥åº”äº§ç”Ÿç›¸åŒå“ˆå¸Œ

        let different_data = b"different test data";
        let hash3 = HashHelper::content_hash(different_data);
        assert_ne!(hash1, hash3); // ä¸åŒè¾“å…¥åº”äº§ç”Ÿä¸åŒå“ˆå¸Œ
    }

    #[test]
    fn test_cid_validation() {
        // æµ‹è¯•æœ‰æ•ˆCID
        let valid_cid = b"QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG";
        assert!(IpfsHelper::validate_cid(valid_cid).is_ok());

        // æµ‹è¯•æ— æ•ˆCID
        let invalid_cid = b"invalid_cid";
        assert!(IpfsHelper::validate_cid(invalid_cid).is_err());
    }
}
```

#### 3.1.2 é›†æˆæµ‹è¯•è¦æ±‚

```rust
// tests/integration_tests.rs

#[cfg(test)]
mod integration_tests {
    use super::*;

    #[test]
    fn test_deceased_media_upload_flow() {
        new_test_ext().execute_with(|| {
            // 1. åˆ›å»ºæµ‹è¯•æ•°æ®
            let image_data = create_test_image();
            let deceased_id = create_test_deceased();
            let album_id = create_test_album(deceased_id);

            // 2. ä¸Šä¼ å›¾ç‰‡
            assert_ok!(Deceased::upload_photo_to_album(
                RuntimeOrigin::signed(1),
                deceased_id,
                album_id,
                image_data.clone(),
            ));

            // 3. éªŒè¯ç»“æœ
            let media_list = Deceased::get_album_media(album_id);
            assert_eq!(media_list.len(), 1);

            let media = Deceased::get_media(media_list[0]).unwrap();
            assert_eq!(media.kind, MediaKind::Photo);
            assert!(media.content_hash.is_some());
        });
    }

    #[test]
    fn test_evidence_submission_flow() {
        new_test_ext().execute_with(|| {
            // æµ‹è¯•Evidenceæ¨¡å—é›†æˆ
            let image_data = create_test_image();

            assert_ok!(Evidence::submit_image_evidence(
                RuntimeOrigin::signed(1),
                1, // domain
                123, // target_id
                image_data,
                false, // is_encrypted
                Some(b"Test evidence".to_vec().try_into().unwrap()),
            ));

            // éªŒè¯è¯æ®è®°å½•
            let evidences = Evidence::get_domain_evidences(1, 123);
            assert_eq!(evidences.len(), 1);
        });
    }

    fn create_test_image() -> Vec<u8> {
        // åˆ›å»ºæœ€å°æœ‰æ•ˆJPEGå›¾ç‰‡
        let mut jpeg = vec![0xFF, 0xD8, 0xFF, 0xE0]; // JPEGå¤´
        jpeg.extend_from_slice(&[0x00, 0x10]); // é•¿åº¦
        jpeg.extend_from_slice(b"JFIF"); // JFIFæ ‡è¯†
        jpeg.extend_from_slice(&[0x00, 0x01, 0x01, 0x01, 0x00, 0x48, 0x00, 0x48, 0x00, 0x00]);
        // ... æ·»åŠ æ›´å¤šJPEGæ•°æ®ä½¿å…¶æˆä¸ºæœ‰æ•ˆå›¾ç‰‡
        jpeg.extend_from_slice(&[0xFF, 0xD9]); // JPEGç»“æŸ
        jpeg
    }
}
```

### 3.2 æ€§èƒ½æµ‹è¯•è¦æ±‚

#### 3.2.1 åŸºå‡†æµ‹è¯•

```rust
// benches/benchmarks.rs

use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
use stardust_media_common::*;

fn bench_image_validation(c: &mut Criterion) {
    let small_image = create_test_image(100, 100); // 100x100åƒç´ 
    let medium_image = create_test_image(1920, 1080); // 1920x1080åƒç´ 
    let large_image = create_test_image(4000, 3000); // 4000x3000åƒç´ 

    let mut group = c.benchmark_group("image_validation");

    group.bench_with_input(
        BenchmarkId::new("small", "100x100"),
        &small_image,
        |b, data| {
            b.iter(|| ImageValidator::validate(black_box(data)))
        },
    );

    group.bench_with_input(
        BenchmarkId::new("medium", "1920x1080"),
        &medium_image,
        |b, data| {
            b.iter(|| ImageValidator::validate(black_box(data)))
        },
    );

    group.bench_with_input(
        BenchmarkId::new("large", "4000x3000"),
        &large_image,
        |b, data| {
            b.iter(|| ImageValidator::validate(black_box(data)))
        },
    );

    group.finish();
}

fn bench_hash_functions(c: &mut Criterion) {
    let data_1kb = vec![0u8; 1024];
    let data_1mb = vec![0u8; 1024 * 1024];
    let data_10mb = vec![0u8; 10 * 1024 * 1024];

    let mut group = c.benchmark_group("hash_functions");

    group.bench_with_input(
        BenchmarkId::new("blake2_256", "1KB"),
        &data_1kb,
        |b, data| {
            b.iter(|| HashHelper::content_hash(black_box(data)))
        },
    );

    group.bench_with_input(
        BenchmarkId::new("blake2_256", "1MB"),
        &data_1mb,
        |b, data| {
            b.iter(|| HashHelper::content_hash(black_box(data)))
        },
    );

    group.bench_with_input(
        BenchmarkId::new("blake2_256", "10MB"),
        &data_10mb,
        |b, data| {
            b.iter(|| HashHelper::content_hash(black_box(data)))
        },
    );

    group.finish();
}

criterion_group!(benches, bench_image_validation, bench_hash_functions);
criterion_main!(benches);
```

#### 3.2.2 æ€§èƒ½ç›®æ ‡

| æ“ä½œ | æ–‡ä»¶å¤§å° | ç›®æ ‡æ—¶é—´ | è¯´æ˜ |
|-----|---------|---------|------|
| **å›¾ç‰‡éªŒè¯** | 1MB | <50ms | åŒ…å«æ ¼å¼æ£€æµ‹ã€å°ºå¯¸æå–ã€å®‰å…¨æ£€æŸ¥ |
| **å›¾ç‰‡éªŒè¯** | 10MB | <200ms | å¤§å›¾ç‰‡å¤„ç† |
| **è§†é¢‘éªŒè¯** | 100MB | <1000ms | åŸºç¡€å…ƒæ•°æ®æå– |
| **å“ˆå¸Œè®¡ç®—** | 10MB | <100ms | Blake2-256å“ˆå¸Œ |
| **CIDè®¡ç®—** | 1MB | <10ms | IPFS CIDç”Ÿæˆ |

### 3.3 å®‰å…¨æµ‹è¯•è¦æ±‚

#### 3.3.1 æ¶æ„æ–‡ä»¶æµ‹è¯•

```rust
#[test]
fn test_malicious_file_detection() {
    // æµ‹è¯•å›¾ç‰‡ç‚¸å¼¹
    let bomb_data = create_image_bomb(); // åˆ›å»ºæ¶æ„å¤§å°ºå¯¸å›¾ç‰‡
    assert_eq!(
        ImageValidator::validate(&bomb_data).unwrap_err(),
        MediaError::ImageBomb
    );

    // æµ‹è¯•åŒ…å«è„šæœ¬çš„å›¾ç‰‡
    let script_data = create_image_with_script();
    assert_eq!(
        ImageValidator::validate(&script_data).unwrap_err(),
        MediaError::SuspiciousContent
    );

    // æµ‹è¯•å¼‚å¸¸EXIFæ•°æ®
    let large_exif_data = create_image_with_large_exif();
    assert_eq!(
        ImageValidator::validate(&large_exif_data).unwrap_err(),
        MediaError::SuspiciousContent
    );
}

#[test]
fn test_file_size_limits() {
    // æµ‹è¯•å„ç§è¾¹ç•Œæ¡ä»¶
    let oversized_data = vec![0u8; 100 * 1024 * 1024 + 1]; // è¶…è¿‡100MB
    assert_eq!(
        ImageValidator::check_size_limits(oversized_data.len() as u64).unwrap_err(),
        MediaError::FileTooLarge
    );

    let undersized_data = vec![0u8; 50]; // å°äº100å­—èŠ‚
    assert_eq!(
        ImageValidator::check_size_limits(undersized_data.len() as u64).unwrap_err(),
        MediaError::FileTooSmall
    );
}
```

---

## 4. éƒ¨ç½²ä¸ç›‘æ§æŒ‡å¯¼

### 4.1 åˆ†é˜¶æ®µéƒ¨ç½²ç­–ç•¥

#### 4.1.1 ç¬¬ä¸€é˜¶æ®µï¼šå·¥å…·åº“éƒ¨ç½²

```bash
# 1. åˆ›å»ºå¹¶æµ‹è¯•å·¥å…·åº“
cd stardust-media-common
cargo test --all-features
cargo bench

# 2. å‘å¸ƒå†…éƒ¨ç‰ˆæœ¬
cargo publish --dry-run
git tag v1.0.0-alpha.1
```

#### 4.1.2 ç¬¬äºŒé˜¶æ®µï¼šæ¨¡å—é›†æˆ

```bash
# é€ä¸ªæ¨¡å—é›†æˆå’Œæµ‹è¯•
cd pallets/deceased
cargo test
cd ../evidence
cargo test
cd ../smart-group-chat
cargo test

# è¿è¡Œé›†æˆæµ‹è¯•
cargo test --workspace
```

#### 4.1.3 ç¬¬ä¸‰é˜¶æ®µï¼šç”Ÿäº§éƒ¨ç½²

```bash
# æ„å»ºç”Ÿäº§ç‰ˆæœ¬
cargo build --release

# è¿è¡Œå®Œæ•´æµ‹è¯•å¥—ä»¶
cargo test --release --all-features

# æ€§èƒ½æµ‹è¯•
cargo bench --all

# éƒ¨ç½²åˆ°æµ‹è¯•ç½‘
./deploy-testnet.sh

# ç›‘æ§å’ŒéªŒè¯
./verify-deployment.sh
```

### 4.2 ç›‘æ§æŒ‡æ ‡

#### 4.2.1 æ€§èƒ½æŒ‡æ ‡

```rust
// åœ¨å„æ¨¡å—ä¸­æ·»åŠ æ€§èƒ½ç›‘æ§
impl<T: Config> Pallet<T> {
    fn upload_photo_with_metrics(/* params */) -> DispatchResult {
        let start_time = sp_io::offchain::timestamp();

        // æ‰§è¡Œä¸Šä¼ é€»è¾‘
        let result = Self::upload_photo_internal(/* params */);

        let end_time = sp_io::offchain::timestamp();
        let duration = end_time.saturating_sub(start_time);

        // è®°å½•æ€§èƒ½æŒ‡æ ‡
        Self::record_performance_metric("photo_upload", duration);

        result
    }

    fn record_performance_metric(operation: &str, duration: u64) {
        // è®°å½•åˆ°é“¾ä¸Šæˆ–å‘é€åˆ°å¤–éƒ¨ç›‘æ§ç³»ç»Ÿ
        Self::deposit_event(Event::PerformanceMetric {
            operation: operation.as_bytes().to_vec(),
            duration_ms: duration,
            timestamp: sp_io::offchain::timestamp(),
        });
    }
}
```

#### 4.2.2 é”™è¯¯ç‡ç›‘æ§

```rust
// é”™è¯¯ç»Ÿè®¡
#[pallet::storage]
pub type ErrorStats<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    BoundedVec<u8, ConstU32<32>>, // é”™è¯¯ç±»å‹
    u32, // é”™è¯¯æ¬¡æ•°
    ValueQuery,
>;

impl<T: Config> Pallet<T> {
    fn handle_validation_error(error: MediaError) -> DispatchError {
        // ç»Ÿè®¡é”™è¯¯
        let error_name = format!("{:?}", error);
        let bounded_name = BoundedVec::try_from(error_name.as_bytes().to_vec())
            .unwrap_or_default();

        ErrorStats::<T>::mutate(&bounded_name, |count| {
            *count = count.saturating_add(1);
        });

        // è½¬æ¢ä¸ºæ¨¡å—é”™è¯¯
        Self::convert_media_error(error).into()
    }
}
```

### 4.3 æ•…éšœæ¢å¤é¢„æ¡ˆ

#### 4.3.1 å·¥å…·åº“é—®é¢˜å¤„ç†

```rust
// å·¥å…·åº“å›é€€æœºåˆ¶
impl<T: Config> Pallet<T> {
    fn validate_with_fallback(data: &[u8], kind: MediaKind) -> ValidationResult<MediaMetadata> {
        // å°è¯•ä½¿ç”¨æ–°çš„å·¥å…·åº“
        match kind {
            MediaKind::Photo => {
                match ImageValidator::validate(data) {
                    Ok(metadata) => Ok(metadata),
                    Err(e) if e.is_fatal() => {
                        // è‡´å‘½é”™è¯¯ï¼Œä½¿ç”¨å›é€€éªŒè¯
                        Self::fallback_image_validation(data)
                    },
                    Err(e) => Err(e),
                }
            },
            // å…¶ä»–ç±»å‹...
            _ => Err(MediaError::UnsupportedOperation),
        }
    }

    fn fallback_image_validation(data: &[u8]) -> ValidationResult<MediaMetadata> {
        // ç®€åŒ–çš„å›é€€éªŒè¯é€»è¾‘
        if data.len() < 100 {
            return Err(MediaError::FileTooSmall);
        }

        if data.len() > 50 * 1024 * 1024 {
            return Err(MediaError::FileTooLarge);
        }

        // åŸºç¡€æ ¼å¼æ£€æŸ¥
        if data.starts_with(&[0xFF, 0xD8, 0xFF]) {
            // JPEG
            Ok(MediaMetadata::new(MediaKind::Photo, data))
        } else if data.starts_with(&[0x89, 0x50, 0x4E, 0x47]) {
            // PNG
            Ok(MediaMetadata::new(MediaKind::Photo, data))
        } else {
            Err(MediaError::UnsupportedFormat)
        }
    }
}
```

### 4.4 å‡çº§ç­–ç•¥

#### 4.4.1 å·¥å…·åº“ç‰ˆæœ¬ç®¡ç†

```toml
# ä½¿ç”¨è¯­ä¹‰åŒ–ç‰ˆæœ¬æ§åˆ¶
[dependencies]
stardust-media-common = { version = ">=1.0.0, <2.0.0", default-features = false }
```

#### 4.4.2 å‘åå…¼å®¹ä¿è¯

```rust
// ç‰ˆæœ¬å…¼å®¹æ€§æ£€æŸ¥
impl<T: Config> Pallet<T> {
    fn check_tool_library_compatibility() -> bool {
        // æ£€æŸ¥å·¥å…·åº“ç‰ˆæœ¬å…¼å®¹æ€§
        let min_version = (1, 0, 0);
        let max_version = (1, u32::MAX, u32::MAX);

        let current_version = stardust_media_common::version();
        current_version >= min_version && current_version < (max_version.0 + 1, 0, 0)
    }
}
```

---

## 5. æ–‡æ¡£ä¸åŸ¹è®­

### 5.1 å¼€å‘è€…æ–‡æ¡£

#### 5.1.1 READMEç¤ºä¾‹

```markdown
# stardust-media-common

StarduståŒºå—é“¾é¡¹ç›®çš„å…±äº«åª’ä½“å¤„ç†å·¥å…·åº“ã€‚

## åŠŸèƒ½ç‰¹æ€§

- âœ… å›¾ç‰‡éªŒè¯ (JPEG, PNG, GIF, WebP)
- âœ… è§†é¢‘éªŒè¯ (MP4, WebM, QuickTime)
- âœ… éŸ³é¢‘éªŒè¯ (MP3, WAV, OGG, AAC)
- âœ… å“ˆå¸Œå·¥å…· (Blake2-256, æ‰¿è¯ºå“ˆå¸Œ)
- âœ… IPFSå·¥å…· (CIDè®¡ç®—ã€éªŒè¯)
- âœ… å®‰å…¨æ£€æŸ¥ (å›¾ç‰‡ç‚¸å¼¹ã€æ¶æ„å†…å®¹æ£€æµ‹)

## å¿«é€Ÿå¼€å§‹

```rust
use stardust_media_common::{ImageValidator, MediaKind};

// éªŒè¯å›¾ç‰‡
let image_data = std::fs::read("photo.jpg")?;
let metadata = ImageValidator::validate(&image_data)?;

println!("å›¾ç‰‡å°ºå¯¸: {}x{}",
    metadata.width.unwrap(),
    metadata.height.unwrap()
);
```

## é›†æˆæŒ‡å¯¼

### Deceasedæ¨¡å—é›†æˆ

```rust
use stardust_media_common::{MediaKind, ImageValidator, HashHelper};

impl<T: Config> Pallet<T> {
    pub fn upload_photo(
        origin: OriginFor<T>,
        photo_data: Vec<u8>,
    ) -> DispatchResult {
        // éªŒè¯å›¾ç‰‡
        let metadata = ImageValidator::validate(&photo_data)?;

        // è®¡ç®—å“ˆå¸Œ
        let hash = HashHelper::content_hash(&photo_data);

        // åˆ›å»ºåª’ä½“è®°å½•
        let media = Media {
            kind: MediaKind::Photo,
            content_hash: Some(hash),
            width: metadata.width,
            height: metadata.height,
            // ...
        };

        Ok(())
    }
}
```
```

#### 5.1.2 APIæ–‡æ¡£è¦æ±‚

æ¯ä¸ªå…¬å…±å‡½æ•°éƒ½å¿…é¡»åŒ…å«è¯¦ç»†çš„æ–‡æ¡£æ³¨é‡Šï¼š

```rust
/// éªŒè¯å›¾ç‰‡å†…å®¹å¹¶è¿”å›å…ƒæ•°æ®
///
/// # å‚æ•°
///
/// * `data` - å›¾ç‰‡æ–‡ä»¶çš„äºŒè¿›åˆ¶æ•°æ®
///
/// # è¿”å›å€¼
///
/// æˆåŠŸæ—¶è¿”å› `MediaMetadata`ï¼ŒåŒ…å«å›¾ç‰‡çš„è¯¦ç»†ä¿¡æ¯ï¼š
/// - æ–‡ä»¶å¤§å°
/// - å›¾ç‰‡å°ºå¯¸ (å®½åº¦/é«˜åº¦)
/// - MIMEç±»å‹
/// - å†…å®¹å“ˆå¸Œ
///
/// # é”™è¯¯
///
/// å¯èƒ½è¿”å›ä»¥ä¸‹é”™è¯¯ï¼š
/// - `MediaError::FileTooSmall` - æ–‡ä»¶å°äº100å­—èŠ‚
/// - `MediaError::FileTooLarge` - æ–‡ä»¶å¤§äº50MB
/// - `MediaError::UnsupportedFormat` - ä¸æ”¯æŒçš„å›¾ç‰‡æ ¼å¼
/// - `MediaError::ImageBomb` - æ£€æµ‹åˆ°å›¾ç‰‡ç‚¸å¼¹
/// - `MediaError::SuspiciousContent` - æ£€æµ‹åˆ°å¯ç–‘å†…å®¹
///
/// # ç¤ºä¾‹
///
/// ```rust
/// use stardust_media_common::{ImageValidator, MediaKind};
///
/// let jpeg_data = std::fs::read("photo.jpg")?;
/// let metadata = ImageValidator::validate(&jpeg_data)?;
///
/// assert_eq!(metadata.kind, MediaKind::Photo);
/// assert!(metadata.width.is_some());
/// assert!(metadata.height.is_some());
/// ```
///
/// # å®‰å…¨æ€§
///
/// æ­¤å‡½æ•°ä¼šæ‰§è¡Œä»¥ä¸‹å®‰å…¨æ£€æŸ¥ï¼š
/// - æ£€æµ‹å›¾ç‰‡ç‚¸å¼¹ï¼ˆè¿‡å¤§çš„åƒç´ æ•°ï¼‰
/// - æ‰«æå¯ç–‘çš„åµŒå…¥å†…å®¹
/// - éªŒè¯æ–‡ä»¶å¤´çš„å®Œæ•´æ€§
/// - æ£€æŸ¥å¼‚å¸¸çš„EXIFæ•°æ®
pub fn validate(data: &[u8]) -> ValidationResult<MediaMetadata> {
    // å®ç°...
}
```

### 5.2 åŸ¹è®­ææ–™

#### 5.2.1 å¼€å‘å›¢é˜ŸåŸ¹è®­å¤§çº²

**ç¬¬ä¸€è¯¾ï¼šv3.0æ¶æ„ç†å¿µ** (2å°æ—¶)
- v3.0æ¶æ„å†³ç­–èƒŒæ™¯
- åˆ†æ•£å­˜å‚¨vsé›†ä¸­å­˜å‚¨å¯¹æ¯”
- å…±äº«å·¥å…·åº“è®¾è®¡åŸç†
- ä¸šåŠ¡éœ€æ±‚å¼‚æ„æ€§åˆ†æ

**ç¬¬äºŒè¯¾ï¼šå·¥å…·åº“ä½¿ç”¨** (2å°æ—¶)
- stardust-media-common APIä»‹ç»
- éªŒè¯å™¨ä½¿ç”¨æ–¹æ³•
- å“ˆå¸Œå·¥å…·ä½¿ç”¨æ–¹æ³•
- é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

**ç¬¬ä¸‰è¯¾ï¼šæ¨¡å—é›†æˆå®è·µ** (3å°æ—¶)
- Deceasedæ¨¡å—é›†æˆæ¼”ç¤º
- Evidenceæ¨¡å—é›†æˆæ¼”ç¤º
- GroupChatæ¨¡å—é›†æˆæ¼”ç¤º
- å¸¸è§é—®é¢˜æ’æŸ¥

**ç¬¬å››è¯¾ï¼šæµ‹è¯•ä¸éƒ¨ç½²** (2å°æ—¶)
- å•å…ƒæµ‹è¯•ç¼–å†™è§„èŒƒ
- é›†æˆæµ‹è¯•ç­–ç•¥
- æ€§èƒ½æµ‹è¯•æ–¹æ³•
- éƒ¨ç½²å’Œç›‘æ§

#### 5.2.2 ä»£ç Reviewæ¸…å•

**å·¥å…·åº“ç›¸å…³**:
- [ ] æ˜¯å¦æ­£ç¡®å¯¼å…¥äº† stardust-media-common
- [ ] æ˜¯å¦ä½¿ç”¨äº†å…±äº«ç±»å‹ï¼ˆMediaKindç­‰ï¼‰
- [ ] æ˜¯å¦ä½¿ç”¨äº†éªŒè¯å™¨è¿›è¡Œå†…å®¹éªŒè¯
- [ ] æ˜¯å¦ä½¿ç”¨äº†å“ˆå¸Œå·¥å…·è®¡ç®—å†…å®¹å“ˆå¸Œ
- [ ] é”™è¯¯è½¬æ¢æ˜¯å¦æ­£ç¡®

**æ€§èƒ½ç›¸å…³**:
- [ ] æ˜¯å¦é¿å…äº†ä¸å¿…è¦çš„æ•°æ®å¤åˆ¶
- [ ] æ˜¯å¦ä½¿ç”¨äº†é€‚å½“çš„æ•°æ®ç»“æ„
- [ ] æ˜¯å¦æœ‰å†…å­˜æ³„æ¼é£é™©
- [ ] å¤§æ–‡ä»¶å¤„ç†æ˜¯å¦æœ‰è¶…æ—¶ä¿æŠ¤

**å®‰å…¨ç›¸å…³**:
- [ ] æ˜¯å¦è¿›è¡Œäº†è¾“å…¥éªŒè¯
- [ ] æ˜¯å¦æ£€æŸ¥äº†æ–‡ä»¶å¤§å°é™åˆ¶
- [ ] æ˜¯å¦æœ‰æƒé™æ£€æŸ¥
- [ ] æ˜¯å¦å¤„ç†äº†æ¶æ„è¾“å…¥

---

## 6. æ€»ç»“

### 6.1 å®æ–½å…³é”®ç‚¹

1. **ä¸¥æ ¼æŒ‰ç…§v3.0æ¶æ„**: ä¸è¦è¯•å›¾åˆ›å»ºé›†ä¸­å¼æ–¹æ¡ˆï¼ŒåšæŒåˆ†æ•£å­˜å‚¨+å…±äº«å·¥å…·åº“
2. **å·¥å…·åº“ä¼˜å…ˆ**: å…ˆå®Œå–„å·¥å…·åº“ï¼Œå†è¿›è¡Œæ¨¡å—é›†æˆ
3. **æµ‹è¯•é©±åŠ¨**: é«˜æµ‹è¯•è¦†ç›–ç‡ï¼Œç¡®ä¿è´¨é‡
4. **æ€§èƒ½ç›‘æ§**: æŒç»­ç›‘æ§æ€§èƒ½æŒ‡æ ‡ï¼ŒåŠæ—¶ä¼˜åŒ–
5. **å‘åå…¼å®¹**: ç¡®ä¿ç°æœ‰åŠŸèƒ½æ— å›å½’

### 6.2 é¢„æœŸæ•ˆæœ

**æŠ€æœ¯æŒ‡æ ‡**:
- è€¦åˆåº¦: 2.8/10 (ä¼˜ç§€)
- ä»£ç è¡Œæ•°: å‡å°‘90% (vsé›†ä¸­å¼)
- æŸ¥è¯¢æ€§èƒ½: æå‡10-100å€
- æµ‹è¯•è¦†ç›–ç‡: >85%

**ç»æµæŒ‡æ ‡**:
- å¼€å‘æˆæœ¬: 40ä¸‡ (vsé›†ä¸­å¼80ä¸‡)
- 5å¹´TCO: 102.5ä¸‡ (vsé›†ä¸­å¼195ä¸‡)
- ROI: 122.5ä¸‡å‡€æ”¶ç›Š

**è´¨é‡æŒ‡æ ‡**:
- å®‰å…¨éš”ç¦»: å®Œå…¨éš”ç¦»
- å¯ç»´æŠ¤æ€§: æå‡70%
- æ‰©å±•æ€§: å®Œç¾æ‰©å±•
- å›¢é˜Ÿæ•ˆç‡: æå‡50%+

### 6.3 æˆåŠŸæ ‡å‡†

- [ ] stardust-media-common å·¥å…·åº“æµ‹è¯•è¦†ç›–ç‡ â‰¥85%
- [ ] æ‰€æœ‰æ¨¡å—æˆåŠŸé›†æˆå·¥å…·åº“ï¼Œæ— åŠŸèƒ½å›å½’
- [ ] æ€§èƒ½æµ‹è¯•è¾¾åˆ°ç›®æ ‡æŒ‡æ ‡
- [ ] ä»£ç å®¡æŸ¥100%é€šè¿‡
- [ ] æ–‡æ¡£å®Œæ•´ï¼Œå›¢é˜ŸåŸ¹è®­å®Œæˆ

**å®æ–½å®Œæˆåï¼ŒStardusté¡¹ç›®å°†æ‹¥æœ‰ï¼š**
âœ… ä¸šç•Œé¢†å…ˆçš„ä½è€¦åˆæ¶æ„ (2.8/10)
âœ… é«˜æ€§èƒ½çš„åª’ä½“å¤„ç†èƒ½åŠ› (10-100xæå‡)
âœ… çµæ´»çš„æ‰©å±•èƒ½åŠ› (æ–°å¢æ¨¡å—æ— éœ€ä¿®æ”¹æ ¸å¿ƒ)
âœ… ä¼˜ç§€çš„å®‰å…¨éš”ç¦» (å®Œå…¨ç‹¬ç«‹çš„å­˜å‚¨ç©ºé—´)
âœ… å¯æŒç»­çš„ç»´æŠ¤æˆæœ¬ (é™ä½75%)

è¿™å°†ä¸ºStardusté¡¹ç›®çš„é•¿æœŸå‘å±•å¥ å®šåšå®çš„æŠ€æœ¯åŸºç¡€ã€‚