# Substrate åŒºå—é“¾èŠå¤©ç³»ç»Ÿè®¾è®¡æ–¹æ¡ˆ v2.0
## æ”¯æŒåŠ å¯†ç¾¤ä¸éåŠ å¯†ç¾¤çš„æ··åˆæ¶æ„

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–¹æ¡ˆåŸºäºåŸæœ‰è®¾è®¡ï¼Œæ–°å¢æ”¯æŒ**åŠ å¯†ç¾¤**ä¸**éåŠ å¯†ç¾¤**çš„æ··åˆæ¶æ„ï¼Œæä¾›ï¼š
- âœ… **ä¸€å¯¹ä¸€ç§èŠ**ï¼ˆå·²å®ç°ï¼Œç«¯åˆ°ç«¯åŠ å¯†ï¼‰
- ğŸ†• **åŠ å¯†ç¾¤èŠ**ï¼ˆç«¯åˆ°ç«¯åŠ å¯†ï¼Œéšç§ä¼˜å…ˆï¼‰
- ğŸ†• **éåŠ å¯†ç¾¤èŠ**ï¼ˆå…¬å¼€é€æ˜ï¼Œæ€§èƒ½ä¼˜åŒ–ï¼‰
- ğŸ” **æ··åˆåŠ å¯†æ–¹æ¡ˆ**
- ğŸ“¦ **IPFS æ··åˆå­˜å‚¨**
- ğŸ›¡ï¸ **å®‰å…¨ä¸éšç§ä¿æŠ¤**

---

## ğŸ“ æ€»ä½“æ¶æ„å‡çº§

### 1. æ··åˆå­˜å‚¨æ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     å‰ç«¯åº”ç”¨å±‚                                â”‚
â”‚  (React DApp - æ™ºèƒ½åŠ å¯†/è§£å¯† + UIäº¤äº’)                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  åŒºå—é“¾å±‚ (Substrate)                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  pallet-chat (ä¸€å¯¹ä¸€ç§èŠ - å·²å®ç°)                    â”‚   â”‚
â”‚  â”‚  - å¼ºåˆ¶åŠ å¯†çš„æ¶ˆæ¯å…ƒæ•°æ®å­˜å‚¨                             â”‚   â”‚
â”‚  â”‚  - ä¼šè¯ç®¡ç†                                           â”‚   â”‚
â”‚  â”‚  - å·²è¯»/æœªè¯»çŠ¶æ€                                      â”‚   â”‚
â”‚  â”‚  - é»‘åå•ç®¡ç†                                         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  pallet-group-chat (ç¾¤èŠ - æ–°å¢æ··åˆæ¨¡å¼)             â”‚   â”‚
â”‚  â”‚  - ç¾¤ç»„ç®¡ç† (æ”¯æŒåŠ å¯†è®¾ç½®)                             â”‚   â”‚
â”‚  â”‚  - æˆå‘˜æƒé™                                           â”‚   â”‚
â”‚  â”‚  - ç¾¤æ¶ˆæ¯å…ƒæ•°æ® (æ ¹æ®ç¾¤ç±»å‹æ™ºèƒ½å­˜å‚¨)                  â”‚   â”‚
â”‚  â”‚  - å…¬å‘Š/ç½®é¡¶                                          â”‚   â”‚
â”‚  â”‚  - åŠ å¯†è®¾ç½®ç®¡ç†                                       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 IPFS å­˜å‚¨å±‚                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   åŠ å¯†ç¾¤å­˜å‚¨        â”‚      éåŠ å¯†ç¾¤å­˜å‚¨                â”‚  â”‚
â”‚  â”‚  - åŠ å¯†çš„æ¶ˆæ¯å†…å®¹    â”‚   - æ˜æ–‡æ¶ˆæ¯å†…å®¹ï¼ˆå¯é€‰ï¼‰         â”‚  â”‚
â”‚  â”‚  - ç¾¤å¯†é’¥ï¼ˆåŠ å¯†ï¼‰    â”‚   - å…¬å¼€ç¾¤æ–‡ä»¶                   â”‚  â”‚
â”‚  â”‚  - åª’ä½“æ–‡ä»¶ï¼ˆåŠ å¯†ï¼‰  â”‚   - åª’ä½“æ–‡ä»¶ï¼ˆæ˜æ–‡æˆ–è½»åº¦åŠ å¯†ï¼‰   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. æ··åˆå­˜å‚¨ç­–ç•¥

| ç¾¤ç»„ç±»å‹ | æ¶ˆæ¯å†…å®¹å­˜å‚¨ | CIDåŠ å¯†éªŒè¯ | æ€§èƒ½ç‰¹ç‚¹ | ä½¿ç”¨åœºæ™¯ |
|---------|-------------|-------------|----------|---------|
| **åŠ å¯†ç¾¤** | IPFSåŠ å¯†å­˜å‚¨ | âœ… å¼ºåˆ¶åŠ å¯†CID | æ ‡å‡†æ€§èƒ½ï¼Œé«˜éšç§ | ç§å¯†è®¨è®ºã€å•†ä¸šæœºå¯†ã€ä¸ªäººéšç§ |
| **éåŠ å¯†ç¾¤** | é“¾ä¸Šå­˜å‚¨æˆ–IPFSæ˜æ–‡ | âŒ å…è®¸æ˜æ–‡CID | é«˜æ€§èƒ½ï¼Œé€æ˜å…¬å¼€ | å…¬å¼€è®¨è®ºã€ç¤¾åŒºå…¬å‘Šã€æŠ€æœ¯äº¤æµ |
| **æ··åˆç¾¤** | æŒ‰æ¶ˆæ¯ç±»å‹åˆ†ç±» | ğŸ”„ åŠ¨æ€éªŒè¯ | å¹³è¡¡æ€§èƒ½å’Œéšç§ | åŠå…¬å¼€ç¾¤ç»„ã€å¤šç”¨é€”ç¾¤èŠ |

---

## ğŸ‘¥ å‡çº§åçš„ç¾¤èŠåŠŸèƒ½è®¾è®¡

### æ ¸å¿ƒæ•°æ®ç»“æ„å‡çº§

#### 1. ç¾¤ç»„ä¿¡æ¯ï¼ˆGroupInfoï¼‰- æ–°å¢åŠ å¯†è®¾ç½®

```rust
#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug, TypeInfo, MaxEncodedLen)]
#[scale_info(skip_type_params(T))]
pub struct GroupInfo<T: Config> {
    /// ç¾¤ç»„ID
    pub id: T::Hash,
    /// ç¾¤åç§°
    pub name: BoundedVec<u8, T::MaxGroupNameLen>,
    /// ç¾¤å¤´åƒCIDï¼ˆæ ¹æ®åŠ å¯†è®¾ç½®åŠ å¯†æˆ–æ˜æ–‡ï¼‰
    pub avatar_cid: Option<BoundedVec<u8, T::MaxCidLen>>,
    /// ç¾¤ä»‹ç»
    pub description: BoundedVec<u8, T::MaxGroupDescLen>,
    /// ç¾¤ä¸»
    pub owner: T::AccountId,
    /// åˆ›å»ºæ—¶é—´
    pub created_at: BlockNumberFor<T>,
    /// æˆå‘˜æ•°é‡
    pub member_count: u32,
    /// ç¾¤ç»„ç±»å‹
    pub group_type: GroupType,
    /// åŠ å¯†é…ç½®
    pub encryption_config: EncryptionConfig,
    /// æ˜¯å¦éœ€è¦å®¡æ‰¹åŠ å…¥
    pub join_approval_required: bool,
    /// å…¨å‘˜ç¦è¨€
    pub mute_all: bool,
    /// æœ€å¤§æˆå‘˜æ•°
    pub max_members: u32,
    /// å…¬å¼€å¯è§æ€§ï¼ˆéåŠ å¯†ç¾¤ä¸“ç”¨ï¼‰
    pub public_visibility: bool,
}

/// ç¾¤ç»„ç±»å‹ï¼ˆé‡æ–°è®¾è®¡ï¼‰
#[derive(Encode, Decode, Clone, Copy, PartialEq, Eq, TypeInfo, MaxEncodedLen, RuntimeDebug)]
pub enum GroupType {
    /// æ™®é€šç¾¤ï¼ˆä»»ä½•äººå¯åˆ›å»ºï¼‰
    Normal,
    /// ä¼šå‘˜ç¾¤ï¼ˆéœ€è¦ä¼šå‘˜èµ„æ ¼ï¼‰
    Premium,
    /// å®˜æ–¹ç¾¤ï¼ˆéœ€è¦æ²»ç†æ‰¹å‡†ï¼‰
    Official,
    /// å…¬å¼€ç¾¤ï¼ˆå®Œå…¨å…¬å¼€ï¼Œæœç´¢å¯è§ï¼‰
    Public,
    /// ç¤¾åŒºç¾¤ï¼ˆåŠå…¬å¼€ï¼Œé‚€è¯·åˆ¶ï¼‰
    Community,
}

/// åŠ å¯†é…ç½®ï¼ˆæ ¸å¿ƒæ–°å¢ï¼‰
#[derive(Encode, Decode, Clone, Copy, PartialEq, Eq, TypeInfo, MaxEncodedLen, RuntimeDebug)]
pub struct EncryptionConfig {
    /// åŠ å¯†æ¨¡å¼
    pub mode: EncryptionMode,
    /// æ˜¯å¦å…è®¸æˆå‘˜åˆ‡æ¢åŠ å¯†æ¨¡å¼ï¼ˆç¾¤ä¸»å¯è®¾ç½®ï¼‰
    pub allow_mode_switch: bool,
    /// å¯†é’¥è½®æ¢ç­–ç•¥
    pub key_rotation: KeyRotationPolicy,
    /// å†…å®¹å­˜å‚¨ç­–ç•¥
    pub storage_policy: StoragePolicy,
}

/// åŠ å¯†æ¨¡å¼
#[derive(Encode, Decode, Clone, Copy, PartialEq, Eq, TypeInfo, MaxEncodedLen, RuntimeDebug)]
pub enum EncryptionMode {
    /// å¼ºåˆ¶åŠ å¯†ï¼ˆæ‰€æœ‰æ¶ˆæ¯ç«¯åˆ°ç«¯åŠ å¯†ï¼‰
    ForceEncrypted,
    /// å¯é€‰åŠ å¯†ï¼ˆæˆå‘˜å¯é€‰æ‹©åŠ å¯†æˆ–æ˜æ–‡ï¼‰
    Optional,
    /// ç¦ç”¨åŠ å¯†ï¼ˆæ‰€æœ‰æ¶ˆæ¯æ˜æ–‡ï¼Œé«˜æ€§èƒ½ï¼‰
    NoEncryption,
    /// æ™ºèƒ½åŠ å¯†ï¼ˆæ ¹æ®å†…å®¹ç±»å‹è‡ªåŠ¨é€‰æ‹©ï¼‰
    Smart,
}

/// å¯†é’¥è½®æ¢ç­–ç•¥
#[derive(Encode, Decode, Clone, Copy, PartialEq, Eq, TypeInfo, MaxEncodedLen, RuntimeDebug)]
pub enum KeyRotationPolicy {
    /// ä»ä¸è½®æ¢ï¼ˆé€‚åˆå°ç¾¤ï¼‰
    Never,
    /// æˆå‘˜å˜æ›´æ—¶è½®æ¢ï¼ˆæ¨èï¼‰
    OnMemberChange,
    /// å®šæœŸè½®æ¢ï¼ˆé«˜å®‰å…¨ï¼‰
    Periodic(BlockNumberFor<T>),
    /// æ‰‹åŠ¨è½®æ¢ï¼ˆç¾¤ä¸»æ§åˆ¶ï¼‰
    Manual,
}

/// å­˜å‚¨ç­–ç•¥
#[derive(Encode, Decode, Clone, Copy, PartialEq, Eq, TypeInfo, MaxEncodedLen, RuntimeDebug)]
pub enum StoragePolicy {
    /// çº¯IPFSå­˜å‚¨ï¼ˆæ ‡å‡†æ¨¡å¼ï¼‰
    IpfsOnly,
    /// é“¾ä¸Šå­˜å‚¨çŸ­æ¶ˆæ¯ï¼ˆ<256å­—èŠ‚ï¼‰
    OnChainShort,
    /// æ··åˆå­˜å‚¨ï¼ˆæ ¹æ®æ¶ˆæ¯å¤§å°å’Œç±»å‹é€‰æ‹©ï¼‰
    Hybrid,
    /// ä¸´æ—¶å­˜å‚¨ï¼ˆå®šæœŸæ¸…ç†ï¼‰
    Temporary(BlockNumberFor<T>),
}
```

#### 2. ç¾¤æ¶ˆæ¯å…ƒæ•°æ®ï¼ˆGroupMessageMetaï¼‰- æ”¯æŒæ··åˆå­˜å‚¨

```rust
#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug, TypeInfo, MaxEncodedLen)]
#[scale_info(skip_type_params(T))]
pub struct GroupMessageMeta<T: Config> {
    /// æ¶ˆæ¯ID
    pub id: u64,
    /// ç¾¤ç»„ID
    pub group_id: T::Hash,
    /// å‘é€æ–¹
    pub sender: T::AccountId,
    /// æ¶ˆæ¯å†…å®¹ï¼ˆæ ¹æ®å­˜å‚¨ç­–ç•¥å†³å®šï¼‰
    pub content: MessageContent<T>,
    /// æ¶ˆæ¯ç±»å‹
    pub msg_type: GroupMessageType,
    /// å‘é€æ—¶é—´
    pub sent_at: BlockNumberFor<T>,
    /// æ˜¯å¦è¢«æ’¤å›
    pub is_recalled: bool,
    /// æ’¤å›æ—¶é—´
    pub recalled_at: Option<BlockNumberFor<T>>,
    /// æ˜¯å¦ç½®é¡¶
    pub is_pinned: bool,
    /// å¼•ç”¨çš„æ¶ˆæ¯IDï¼ˆå›å¤åŠŸèƒ½ï¼‰
    pub reply_to: Option<u64>,
    /// åŠ å¯†æ ‡è¯†
    pub encryption_info: Option<EncryptionInfo>,
}

/// æ¶ˆæ¯å†…å®¹ï¼ˆæ”¯æŒå¤šç§å­˜å‚¨æ–¹å¼ï¼‰
#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug, TypeInfo, MaxEncodedLen)]
pub enum MessageContent<T: Config> {
    /// IPFS CIDï¼ˆä¼ ç»Ÿæ–¹å¼ï¼‰
    IpfsCid(BoundedVec<u8, T::MaxCidLen>),
    /// é“¾ä¸Šç›´æ¥å­˜å‚¨ï¼ˆçŸ­æ¶ˆæ¯ï¼‰
    OnChain(BoundedVec<u8, T::MaxOnChainContentLen>),
    /// æ··åˆå­˜å‚¨ï¼ˆCID + ç¼“å­˜çš„å†…å®¹æ‘˜è¦ï¼‰
    Hybrid {
        cid: BoundedVec<u8, T::MaxCidLen>,
        summary: BoundedVec<u8, T::MaxSummaryLen>,
    },
    /// ä¸´æ—¶å¼•ç”¨ï¼ˆ24å°æ—¶åæ¸…ç†ï¼‰
    Temporary(BoundedVec<u8, T::MaxCidLen>),
}

/// åŠ å¯†ä¿¡æ¯
#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug, TypeInfo, MaxEncodedLen)]
pub struct EncryptionInfo {
    /// æ˜¯å¦åŠ å¯†
    pub is_encrypted: bool,
    /// åŠ å¯†ç®—æ³•ç‰ˆæœ¬
    pub algorithm_version: u8,
    /// å¯†é’¥IDï¼ˆç”¨äºå¯†é’¥è½®æ¢ï¼‰
    pub key_id: Option<u32>,
    /// æ¶ˆæ¯æ‘˜è¦/ç­¾åï¼ˆé˜²ç¯¡æ”¹ï¼‰
    pub digest: Option<BoundedVec<u8, 32>>,
}
```

### å­˜å‚¨æ˜ å°„å‡çº§

| Storage | Type | Key | Value | è¯´æ˜ |
|---------|------|-----|-------|------|
| `Groups` | StorageMap | T::Hash | GroupInfo | ç¾¤ç»„ä¿¡æ¯ï¼ˆå«åŠ å¯†é…ç½®ï¼‰ |
| `GroupMembers` | StorageDoubleMap | (T::Hash, T::AccountId) | GroupMember | ç¾¤æˆå‘˜ä¿¡æ¯ |
| `GroupMessages` | StorageMap | u64 | GroupMessageMeta | ç¾¤æ¶ˆæ¯å…ƒæ•°æ®ï¼ˆæ··åˆå­˜å‚¨ï¼‰ |
| `GroupEncryptionKeys` | StorageDoubleMap | (T::Hash, u32) | EncryptedGroupKey | ç¾¤å¯†é’¥ç®¡ç† |
| `PublicGroupContent` | StorageDoubleMap | (T::Hash, u64) | PublicMessage | éåŠ å¯†ç¾¤æ¶ˆæ¯å†…å®¹ |
| `GroupEncryptionSettings` | StorageMap | T::Hash | EncryptionConfig | ç¾¤åŠ å¯†é…ç½® |
| `MessageEncryptionStatus` | StorageMap | u64 | EncryptionInfo | æ¶ˆæ¯åŠ å¯†çŠ¶æ€ |

### å‡çº§çš„å¯è°ƒç”¨å‡½æ•°

#### ç¾¤ç»„ç®¡ç†ï¼ˆæ”¯æŒåŠ å¯†é…ç½®ï¼‰

```rust
/// 1. åˆ›å»ºç¾¤ç»„ï¼ˆæ–°å¢åŠ å¯†é…ç½®å‚æ•°ï¼‰
#[pallet::call_index(0)]
pub fn create_group(
    origin: OriginFor<T>,
    name: Vec<u8>,
    description: Vec<u8>,
    avatar_cid: Option<Vec<u8>>,
    group_type: GroupType,
    max_members: u32,
    encryption_config: EncryptionConfig, // æ–°å¢
) -> DispatchResult

/// 2. æ›´æ–°ç¾¤åŠ å¯†è®¾ç½®ï¼ˆä»…ç¾¤ä¸»ï¼‰
#[pallet::call_index(24)]
pub fn update_encryption_config(
    origin: OriginFor<T>,
    group_id: T::Hash,
    new_config: EncryptionConfig,
) -> DispatchResult

/// 3. è½®æ¢ç¾¤å¯†é’¥ï¼ˆä»…ç¾¤ä¸»/ç®¡ç†å‘˜ï¼‰
#[pallet::call_index(25)]
pub fn rotate_group_key(
    origin: OriginFor<T>,
    group_id: T::Hash,
    reason: KeyRotationReason,
) -> DispatchResult

/// 4. è®¾ç½®ç¾¤å…¬å¼€å¯è§æ€§ï¼ˆéåŠ å¯†ç¾¤ä¸“ç”¨ï¼‰
#[pallet::call_index(26)]
pub fn set_public_visibility(
    origin: OriginFor<T>,
    group_id: T::Hash,
    public: bool,
) -> DispatchResult

/// å¯†é’¥è½®æ¢åŸå› 
#[derive(Encode, Decode, Clone, Copy, PartialEq, Eq, TypeInfo, MaxEncodedLen, RuntimeDebug)]
pub enum KeyRotationReason {
    /// æˆå‘˜ç¦»å¼€
    MemberLeft,
    /// å®‰å…¨äº‹ä»¶
    SecurityBreach,
    /// å®šæœŸè½®æ¢
    Scheduled,
    /// æ‰‹åŠ¨è½®æ¢
    Manual,
}
```

#### æ¶ˆæ¯ç®¡ç†ï¼ˆæ”¯æŒæ··åˆæ¨¡å¼ï¼‰

```rust
/// 16. å‘é€ç¾¤æ¶ˆæ¯ï¼ˆæ”¯æŒåŠ å¯†é€‰æ‹©ï¼‰
#[pallet::call_index(15)]
pub fn send_group_message(
    origin: OriginFor<T>,
    group_id: T::Hash,
    content: MessageContentInput,
    msg_type_code: u8,
    reply_to: Option<u64>,
    encryption_preference: Option<bool>, // æ–°å¢ï¼šç”¨æˆ·å¯é€‰æ‹©æ˜¯å¦åŠ å¯†
) -> DispatchResult

/// æ¶ˆæ¯å†…å®¹è¾“å…¥
#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug, TypeInfo)]
pub enum MessageContentInput {
    /// IPFS CID
    IpfsCid(Vec<u8>),
    /// çŸ­æ–‡æœ¬ï¼ˆç›´æ¥ä¸Šé“¾ï¼‰
    ShortText(Vec<u8>),
    /// è‡ªåŠ¨é€‰æ‹©ï¼ˆç³»ç»Ÿæ ¹æ®é•¿åº¦å’Œç¾¤è®¾ç½®å†³å®šï¼‰
    Auto(Vec<u8>),
}

/// 17. æ‰¹é‡å‘é€æ¶ˆæ¯ï¼ˆå…¬å‘Šç­‰ï¼‰
#[pallet::call_index(27)]
pub fn broadcast_message(
    origin: OriginFor<T>,
    group_id: T::Hash,
    content: MessageContentInput,
    msg_type: BroadcastType,
    priority: MessagePriority,
) -> DispatchResult

/// å¹¿æ’­ç±»å‹
#[derive(Encode, Decode, Clone, Copy, PartialEq, Eq, TypeInfo, MaxEncodedLen, RuntimeDebug)]
pub enum BroadcastType {
    /// ç³»ç»Ÿå…¬å‘Š
    SystemAnnouncement,
    /// ç¾¤å…¬å‘Š
    GroupAnnouncement,
    /// ç´§æ€¥é€šçŸ¥
    Emergency,
    /// æ™®é€šå¹¿æ’­
    Regular,
}

/// æ¶ˆæ¯ä¼˜å…ˆçº§
#[derive(Encode, Decode, Clone, Copy, PartialEq, Eq, TypeInfo, MaxEncodedLen, RuntimeDebug)]
pub enum MessagePriority {
    Low = 0,
    Normal = 1,
    High = 2,
    Critical = 3,
}
```

---

## ğŸ” å‡çº§åçš„åŠ å¯†ä¸å®‰å…¨è®¾è®¡

### 1. å¤šå±‚æ¬¡åŠ å¯†æ–¹æ¡ˆ

#### æ–¹æ¡ˆAï¼šåŠ å¯†ç¾¤ï¼ˆForceEncrypted æ¨¡å¼ï¼‰
```text
1. ç¾¤å¯†é’¥ç®¡ç†ï¼ˆSignal Protocol + ç¾¤å¯¹ç§°å¯†é’¥ï¼‰:
   groupKey_v1 = generateRandomKey(256bit)

2. æˆå‘˜å¯†é’¥åˆ†å‘:
   for each member:
     encryptedGroupKey_member = RSA-OAEP.encrypt(publicKey_member, groupKey_v1)
     store(encryptedGroupKey_member) -> IPFS

3. æ¶ˆæ¯åŠ å¯†æµç¨‹:
   plainMessage = "Hello Encrypted Group"
   encryptedMessage = AES-GCM.encrypt(groupKey_v1, plainMessage)
   cid = ipfs.add(encryptedMessage)

4. å¼ºåˆ¶CIDåŠ å¯†éªŒè¯:
   require(is_cid_encrypted(cid) == true)
   send_group_message(group_id, IpfsCid(cid), ...)

5. å¯†é’¥è½®æ¢ï¼ˆæˆå‘˜å˜æ›´æ—¶ï¼‰:
   groupKey_v2 = generateRandomKey(256bit)
   re-encrypt for current members only

6. å‰å‘å®‰å…¨æ€§:
   æ—§å¯†é’¥è¢«åˆ é™¤ï¼Œç¦»å¼€çš„æˆå‘˜æ— æ³•è§£å¯†æ–°æ¶ˆæ¯
```

#### æ–¹æ¡ˆBï¼šéåŠ å¯†ç¾¤ï¼ˆNoEncryption æ¨¡å¼ï¼‰
```text
1. ç›´æ¥å­˜å‚¨ç­–ç•¥:
   çŸ­æ¶ˆæ¯(<256å­—èŠ‚) -> é“¾ä¸Šç›´æ¥å­˜å‚¨
   é•¿æ¶ˆæ¯(>256å­—èŠ‚) -> IPFSæ˜æ–‡å­˜å‚¨

2. æ¶ˆæ¯å‘é€æµç¨‹:
   plainMessage = "Hello Public Group"

   if len(plainMessage) <= 256:
     content = OnChain(plainMessage.bytes())
   else:
     cid = ipfs.add(plainMessage)  // æ˜æ–‡ä¸Šä¼ 
     content = IpfsCid(cid)

   send_group_message(group_id, content, ...)

3. æ€§èƒ½ä¼˜åŒ–:
   - æ— åŠ å¯†/è§£å¯†å¼€é”€
   - æ”¯æŒé“¾ä¸Šæœç´¢
   - å¿«é€Ÿæ¶ˆæ¯åŒæ­¥
   - é™ä½IPFSä¾èµ–

4. é€æ˜æ€§:
   - æ‰€æœ‰æ¶ˆæ¯å…¬å¼€å¯æŸ¥
   - æ”¯æŒåŒºå—é“¾æµè§ˆå™¨æŸ¥çœ‹
   - ä¾¿äºå®¡è®¡å’Œæ²»ç†
```

#### æ–¹æ¡ˆCï¼šæ™ºèƒ½æ··åˆæ¨¡å¼ï¼ˆSmart æ¨¡å¼ï¼‰
```text
1. å†…å®¹åˆ†æä¸è‡ªåŠ¨é€‰æ‹©:
   function chooseEncryption(content, msgType, sender, groupConfig) {
     if msgType == "SystemAnnouncement": return false  // ç³»ç»Ÿæ¶ˆæ¯ä¸åŠ å¯†
     if content.contains("@everyone"): return false    // å…¬å‘Šç±»æ¶ˆæ¯
     if sender.is_admin && content.startsWith("/"): return false  // ç®¡ç†å‘½ä»¤
     if content.length > 1KB: return true             // å¤§æ–‡ä»¶å¼ºåˆ¶åŠ å¯†
     if groupConfig.defaultEncryption: return true    // ç¾¤é»˜è®¤è®¾ç½®
     return userPreference(sender)                     // ç”¨æˆ·åå¥½
   }

2. åŠ¨æ€åŠ å¯†å†³ç­–:
   - ç³»ç»Ÿæ¶ˆæ¯/å…¬å‘Š -> æ˜æ–‡å­˜å‚¨ï¼ˆä¾¿äºæ£€ç´¢ï¼‰
   - ä¸ªäººèŠå¤©å†…å®¹ -> åŠ å¯†å­˜å‚¨ï¼ˆä¿æŠ¤éšç§ï¼‰
   - ç®¡ç†å‘½ä»¤ -> æ˜æ–‡å­˜å‚¨ï¼ˆä¾¿äºå®¡è®¡ï¼‰
   - åª’ä½“æ–‡ä»¶ -> æ ¹æ®å¤§å°å’Œç±»å‹å†³å®š

3. ç”¨æˆ·å¯æ§åˆ¶:
   ç”¨æˆ·å¯é€šè¿‡UIé€‰æ‹©æ¯æ¡æ¶ˆæ¯æ˜¯å¦åŠ å¯†
   ç¾¤ä¸»å¯è®¾ç½®ç¾¤é»˜è®¤åŠ å¯†ç­–ç•¥

4. å…¼å®¹æ€§:
   æ”¯æŒåŠ å¯†å’ŒéåŠ å¯†æ¶ˆæ¯å…±å­˜
   å®¢æˆ·ç«¯è‡ªåŠ¨è¯†åˆ«æ¶ˆæ¯ç±»å‹å¹¶å¤„ç†
```

### 2. CIDéªŒè¯å‡çº§

```rust
/// æ™ºèƒ½CIDéªŒè¯ï¼ˆæ ¹æ®ç¾¤è®¾ç½®ï¼‰
pub fn validate_message_content(
    group_id: &T::Hash,
    content: &MessageContentInput,
    encryption_preference: Option<bool>,
) -> Result<MessageContent<T>, DispatchError> {
    let group = Groups::<T>::get(group_id).ok_or(Error::<T>::GroupNotFound)?;
    let config = &group.encryption_config;

    match config.mode {
        EncryptionMode::ForceEncrypted => {
            // å¼ºåˆ¶åŠ å¯†æ¨¡å¼ï¼šæ‰€æœ‰å†…å®¹å¿…é¡»åŠ å¯†
            match content {
                MessageContentInput::IpfsCid(cid) => {
                    ensure!(is_cid_encrypted(cid), Error::<T>::CidNotEncrypted);
                    Ok(MessageContent::IpfsCid(cid.clone().try_into()?))
                }
                MessageContentInput::ShortText(_) => {
                    return Err(Error::<T>::PlaintextNotAllowed.into());
                }
                MessageContentInput::Auto(data) => {
                    // è‡ªåŠ¨ä¸Šä¼ å¹¶åŠ å¯†åˆ°IPFS
                    let encrypted_data = Self::encrypt_for_group(group_id, data)?;
                    let cid = Self::upload_to_ipfs(encrypted_data)?;
                    Ok(MessageContent::IpfsCid(cid))
                }
            }
        }

        EncryptionMode::NoEncryption => {
            // éåŠ å¯†æ¨¡å¼ï¼šä¼˜åŒ–å­˜å‚¨
            match content {
                MessageContentInput::ShortText(text) => {
                    if text.len() <= T::MaxOnChainContentLen::get() as usize {
                        Ok(MessageContent::OnChain(text.clone().try_into()?))
                    } else {
                        // é•¿æ¶ˆæ¯ä¸Šä¼ åˆ°IPFSï¼ˆæ˜æ–‡ï¼‰
                        let cid = Self::upload_to_ipfs_plaintext(text)?;
                        Ok(MessageContent::IpfsCid(cid))
                    }
                }
                MessageContentInput::IpfsCid(cid) => {
                    // å…è®¸æ˜æ–‡CID
                    Ok(MessageContent::IpfsCid(cid.clone().try_into()?))
                }
                MessageContentInput::Auto(data) => {
                    // æ ¹æ®å¤§å°è‡ªåŠ¨é€‰æ‹©å­˜å‚¨æ–¹å¼
                    if data.len() <= T::MaxOnChainContentLen::get() as usize {
                        Ok(MessageContent::OnChain(data.clone().try_into()?))
                    } else {
                        let cid = Self::upload_to_ipfs_plaintext(data)?;
                        Ok(MessageContent::IpfsCid(cid))
                    }
                }
            }
        }

        EncryptionMode::Optional | EncryptionMode::Smart => {
            // å¯é€‰æˆ–æ™ºèƒ½æ¨¡å¼ï¼šæ ¹æ®ç”¨æˆ·åå¥½å’Œå†…å®¹åˆ†æ
            let should_encrypt = match config.mode {
                EncryptionMode::Optional => encryption_preference.unwrap_or(false),
                EncryptionMode::Smart => Self::smart_encryption_decision(content, group_id)?,
                _ => false,
            };

            if should_encrypt {
                // åŠ å¯†è·¯å¾„
                let encrypted_data = match content {
                    MessageContentInput::Auto(data) | MessageContentInput::ShortText(data) => {
                        Self::encrypt_for_group(group_id, data)?
                    }
                    MessageContentInput::IpfsCid(cid) => {
                        ensure!(is_cid_encrypted(cid), Error::<T>::CidNotEncrypted);
                        return Ok(MessageContent::IpfsCid(cid.clone().try_into()?));
                    }
                };
                let cid = Self::upload_to_ipfs(encrypted_data)?;
                Ok(MessageContent::IpfsCid(cid))
            } else {
                // éåŠ å¯†è·¯å¾„ï¼ˆåŒNoEncryptionæ¨¡å¼å¤„ç†ï¼‰
                Self::handle_plaintext_content(content)
            }
        }
    }
}

/// æ™ºèƒ½åŠ å¯†å†³ç­–ç®—æ³•
fn smart_encryption_decision(
    content: &MessageContentInput,
    group_id: &T::Hash,
) -> Result<bool, DispatchError> {
    let group = Groups::<T>::get(group_id).unwrap();

    // åˆ†ææ¶ˆæ¯å†…å®¹
    let data = match content {
        MessageContentInput::Auto(d) | MessageContentInput::ShortText(d) => d,
        MessageContentInput::IpfsCid(_) => return Ok(true), // CIDé»˜è®¤è®¤ä¸ºéœ€è¦åŠ å¯†
    };

    let text = String::from_utf8_lossy(data);

    // è§„åˆ™1ï¼šç³»ç»Ÿç±»æ¶ˆæ¯ä¸åŠ å¯†
    if text.starts_with("/") || text.starts_with("@everyone") {
        return Ok(false);
    }

    // è§„åˆ™2ï¼šå¤§æ–‡ä»¶åŠ å¯†
    if data.len() > 1024 {
        return Ok(true);
    }

    // è§„åˆ™3ï¼šåŒ…å«æ•æ„Ÿè¯åŠ å¯†
    const SENSITIVE_KEYWORDS: &[&str] = &["private", "secret", "confidential", "password"];
    if SENSITIVE_KEYWORDS.iter().any(|&kw| text.to_lowercase().contains(kw)) {
        return Ok(true);
    }

    // è§„åˆ™4ï¼šç¾¤é»˜è®¤è®¾ç½®
    Ok(group.encryption_config.mode == EncryptionMode::ForceEncrypted)
}
```

### 3. å¯†é’¥ç®¡ç†å‡çº§

```rust
/// ç¾¤å¯†é’¥ç®¡ç†
#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug, TypeInfo, MaxEncodedLen)]
pub struct EncryptedGroupKey<T: Config> {
    /// å¯†é’¥ç‰ˆæœ¬
    pub version: u32,
    /// ä¸ºç‰¹å®šæˆå‘˜åŠ å¯†çš„ç¾¤å¯†é’¥
    pub encrypted_key: BoundedVec<u8, T::MaxEncryptedKeyLen>,
    /// å¯†é’¥åˆ›å»ºæ—¶é—´
    pub created_at: BlockNumberFor<T>,
    /// å¯†é’¥æœ‰æ•ˆæœŸ
    pub expires_at: Option<BlockNumberFor<T>>,
    /// å¯†é’¥çŠ¶æ€
    pub status: KeyStatus,
}

#[derive(Encode, Decode, Clone, Copy, PartialEq, Eq, TypeInfo, MaxEncodedLen, RuntimeDebug)]
pub enum KeyStatus {
    Active,
    Deprecated,
    Revoked,
}

/// å­˜å‚¨æ˜ å°„ï¼šç¾¤å¯†é’¥ç®¡ç†
pub type GroupEncryptionKeys<T: Config> = StorageDoubleMap<
    _,
    Blake2_128Concat,
    T::Hash,                    // group_id
    Blake2_128Concat,
    (T::AccountId, u32),        // (member, key_version)
    EncryptedGroupKey<T>,
>;

impl<T: Config> Pallet<T> {
    /// è½®æ¢ç¾¤å¯†é’¥
    pub fn rotate_group_key(
        group_id: &T::Hash,
        reason: KeyRotationReason,
    ) -> DispatchResult {
        let group = Groups::<T>::get(group_id).ok_or(Error::<T>::GroupNotFound)?;
        let current_members = Self::list_active_members(group_id)?;

        // ç”Ÿæˆæ–°å¯†é’¥ç‰ˆæœ¬
        let new_version = Self::get_next_key_version(group_id);
        let new_group_key = Self::generate_group_key();

        // ä¸ºæ¯ä¸ªå½“å‰æˆå‘˜åŠ å¯†æ–°å¯†é’¥
        for member in current_members.iter() {
            let member_public_key = Self::get_member_public_key(member)?;
            let encrypted_key = Self::encrypt_group_key(&new_group_key, &member_public_key)?;

            let key_info = EncryptedGroupKey {
                version: new_version,
                encrypted_key: encrypted_key.try_into()?,
                created_at: frame_system::Pallet::<T>::block_number(),
                expires_at: None,
                status: KeyStatus::Active,
            };

            GroupEncryptionKeys::<T>::insert(group_id, (member.clone(), new_version), key_info);
        }

        // æ ‡è®°æ—§å¯†é’¥ä¸ºå·²åºŸå¼ƒ
        Self::deprecate_old_keys(group_id, new_version)?;

        // å‘å‡ºäº‹ä»¶
        Self::deposit_event(Event::GroupKeyRotated {
            group_id: *group_id,
            new_version,
            reason,
            affected_members: current_members.len() as u32,
        });

        Ok(())
    }

    /// æ·»åŠ æ–°æˆå‘˜æ—¶åˆ†å‘å¯†é’¥
    pub fn distribute_key_to_new_member(
        group_id: &T::Hash,
        new_member: &T::AccountId,
    ) -> DispatchResult {
        let current_key_version = Self::get_current_key_version(group_id)?;
        let group_key = Self::get_current_group_key(group_id)?;
        let member_public_key = Self::get_member_public_key(new_member)?;

        let encrypted_key = Self::encrypt_group_key(&group_key, &member_public_key)?;

        let key_info = EncryptedGroupKey {
            version: current_key_version,
            encrypted_key: encrypted_key.try_into()?,
            created_at: frame_system::Pallet::<T>::block_number(),
            expires_at: None,
            status: KeyStatus::Active,
        };

        GroupEncryptionKeys::<T>::insert(group_id, (new_member.clone(), current_key_version), key_info);

        Ok(())
    }
}
```

---

## ğŸ“± å‰ç«¯é›†æˆå‡çº§

### 1. ç¾¤èŠç»„ä»¶ï¼ˆæ”¯æŒæ··åˆæ¨¡å¼ï¼‰

```typescript
// stardust-dapp/src/features/chat/EnhancedGroupChatPage.tsx
import React, { useState, useEffect } from 'react';
import { EncryptionMode, MessageContentInput } from '@/types/chat';
import { encryptGroupMessage, decryptGroupMessage } from '@/utils/groupEncryption';
import { EncryptionToggle, MessageTypeSelector } from '@/components/chat';

export const EnhancedGroupChatPage: React.FC = () => {
  const { groupId } = useParams<{ groupId: string }>();
  const [groupInfo, setGroupInfo] = useState<GroupInfo | null>(null);
  const [encryptionEnabled, setEncryptionEnabled] = useState<boolean>(false);
  const [messageMode, setMessageMode] = useState<'auto' | 'short' | 'ipfs'>('auto');

  // æ£€æŸ¥ç¾¤åŠ å¯†é…ç½®
  useEffect(() => {
    loadGroupInfo();
  }, [groupId]);

  const loadGroupInfo = async () => {
    const info = await api.query.groupChat.groups(groupId);
    const parsed = info.toJSON() as GroupInfo;
    setGroupInfo(parsed);

    // æ ¹æ®ç¾¤è®¾ç½®åˆå§‹åŒ–åŠ å¯†å¼€å…³
    switch (parsed.encryption_config.mode) {
      case 'ForceEncrypted':
        setEncryptionEnabled(true);
        break;
      case 'NoEncryption':
        setEncryptionEnabled(false);
        break;
      case 'Optional':
      case 'Smart':
        setEncryptionEnabled(localStorage.getItem(`encrypt-pref-${groupId}`) === 'true');
        break;
    }
  };

  const sendMessage = async (content: string, forceEncrypt?: boolean) => {
    if (!content.trim()) return;

    try {
      let messageContent: MessageContentInput;
      let shouldEncrypt = forceEncrypt ?? encryptionEnabled;

      // æ™ºèƒ½å†…å®¹å¤„ç†
      if (messageMode === 'auto') {
        messageContent = { Auto: new TextEncoder().encode(content) };
      } else if (messageMode === 'short' && content.length <= 256) {
        messageContent = { ShortText: new TextEncoder().encode(content) };
        shouldEncrypt = false; // çŸ­æ¶ˆæ¯ç›´æ¥ä¸Šé“¾ï¼Œä¸åŠ å¯†
      } else {
        // IPFSå­˜å‚¨
        if (shouldEncrypt) {
          const groupKey = await getGroupKey(groupId);
          const encrypted = await encryptGroupMessage(content, groupKey);
          const cid = await uploadToIPFS(encrypted);
          messageContent = { IpfsCid: cid };
        } else {
          const cid = await uploadToIPFS(content); // æ˜æ–‡ä¸Šä¼ 
          messageContent = { IpfsCid: cid };
        }
      }

      const tx = api.tx.groupChat.sendGroupMessage(
        groupId,
        messageContent,
        0, // Text
        null, // ä¸å›å¤
        shouldEncrypt // åŠ å¯†åå¥½
      );

      await tx.signAndSend(account, ({ status }) => {
        if (status.isInBlock) {
          setInputText('');
          loadMessages();
        }
      });
    } catch (error) {
      console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', error);
    }
  };

  const toggleEncryption = () => {
    if (!groupInfo) return;

    const config = groupInfo.encryption_config;
    if (config.mode === 'ForceEncrypted' || config.mode === 'NoEncryption') {
      // å¼ºåˆ¶æ¨¡å¼ä¸å…è®¸åˆ‡æ¢
      return;
    }

    const newState = !encryptionEnabled;
    setEncryptionEnabled(newState);
    localStorage.setItem(`encrypt-pref-${groupId}`, newState.toString());
  };

  const getEncryptionIcon = () => {
    if (!groupInfo) return 'ğŸ”’';

    switch (groupInfo.encryption_config.mode) {
      case 'ForceEncrypted': return 'ğŸ”'; // å¼ºåˆ¶åŠ å¯†
      case 'NoEncryption': return 'ğŸ”“';   // å®Œå…¨å¼€æ”¾
      case 'Optional': return encryptionEnabled ? 'ğŸ”’' : 'ğŸ”“'; // å¯é€‰
      case 'Smart': return 'ğŸ§ ';          // æ™ºèƒ½æ¨¡å¼
      default: return 'â“';
    }
  };

  return (
    <div className="enhanced-group-chat">
      <div className="group-header">
        <h2>{groupInfo?.name}</h2>
        <div className="encryption-status">
          {getEncryptionIcon()}
          <span>{getEncryptionModeText(groupInfo?.encryption_config.mode)}</span>
        </div>

        {/* åŠ å¯†æ§åˆ¶é¢æ¿ */}
        {groupInfo?.encryption_config.mode === 'Optional' && (
          <EncryptionToggle
            enabled={encryptionEnabled}
            onToggle={toggleEncryption}
            disabled={!groupInfo.encryption_config.allow_mode_switch}
          />
        )}
      </div>

      <div className="message-list">
        {messages.map((msg) => (
          <MessageItem
            key={msg.id}
            message={msg}
            showEncryptionStatus={true}
            groupEncryptionMode={groupInfo?.encryption_config.mode}
          />
        ))}
      </div>

      <div className="enhanced-chat-input">
        <MessageTypeSelector
          mode={messageMode}
          onModeChange={setMessageMode}
          groupConfig={groupInfo?.encryption_config}
        />

        <input
          type="text"
          value={inputText}
          onChange={(e) => setInputText(e.target.value)}
          placeholder={getInputPlaceholder()}
        />

        <button onClick={() => sendMessage(inputText)}>
          å‘é€ {encryptionEnabled ? 'ğŸ”’' : 'ğŸ“¤'}
        </button>
      </div>
    </div>
  );
};

// æ¶ˆæ¯ç±»å‹é€‰æ‹©å™¨ç»„ä»¶
const MessageTypeSelector: React.FC<{
  mode: string;
  onModeChange: (mode: string) => void;
  groupConfig?: EncryptionConfig;
}> = ({ mode, onModeChange, groupConfig }) => {
  if (groupConfig?.mode === 'ForceEncrypted') {
    return <div className="mode-indicator">ğŸ” å¼ºåˆ¶åŠ å¯†</div>;
  }

  if (groupConfig?.mode === 'NoEncryption') {
    return <div className="mode-indicator">ğŸ”“ å…¬å¼€ç¾¤ç»„</div>;
  }

  return (
    <select value={mode} onChange={(e) => onModeChange(e.target.value)}>
      <option value="auto">ğŸ§  æ™ºèƒ½é€‰æ‹©</option>
      <option value="short">âš¡ å¿«é€Ÿæ¶ˆæ¯</option>
      <option value="ipfs">ğŸ’¾ IPFSå­˜å‚¨</option>
    </select>
  );
};

// æ¶ˆæ¯é¡¹ç»„ä»¶ï¼ˆæ˜¾ç¤ºåŠ å¯†çŠ¶æ€ï¼‰
const MessageItem: React.FC<{
  message: any;
  showEncryptionStatus: boolean;
  groupEncryptionMode?: string;
}> = ({ message, showEncryptionStatus, groupEncryptionMode }) => {
  const getStorageIcon = () => {
    if (message.content.OnChain) return 'âš¡'; // é“¾ä¸Šå­˜å‚¨
    if (message.content.IpfsCid) {
      return message.encryption_info?.is_encrypted ? 'ğŸ”’' : 'ğŸ“'; // åŠ å¯†/æ˜æ–‡IPFS
    }
    return 'ğŸ“¤';
  };

  return (
    <div className={`message ${message.sender === account.address ? 'sent' : 'received'}`}>
      <div className="message-header">
        <span className="sender">{getMemberNickname(message.sender)}</span>
        {showEncryptionStatus && (
          <span className="storage-indicator" title={getStorageTooltip()}>
            {getStorageIcon()}
          </span>
        )}
      </div>
      <div className="message-content">
        {message.is_recalled ? 'æ¶ˆæ¯å·²æ’¤å›' : message.content}
      </div>
      <div className="message-time">{formatTime(message.timestamp)}</div>
    </div>
  );
};
```

### 2. åŠ å¯†å·¥å…·åº“å‡çº§

```typescript
// stardust-dapp/src/utils/hybridEncryption.ts

export class HybridChatEncryption {
  private static instance: HybridChatEncryption;
  private groupKeys = new Map<string, CryptoKey>();
  private keyVersions = new Map<string, number>();

  static getInstance(): HybridChatEncryption {
    if (!this.instance) {
      this.instance = new HybridChatEncryption();
    }
    return this.instance;
  }

  /**
   * æ ¹æ®ç¾¤é…ç½®æ™ºèƒ½é€‰æ‹©åŠ å¯†æ–¹å¼
   */
  async smartEncrypt(
    content: string,
    groupId: string,
    groupConfig: EncryptionConfig,
    userPreference?: boolean
  ): Promise<{
    encrypted: Uint8Array;
    method: 'aes-gcm' | 'plaintext' | 'hybrid';
    cid?: string;
  }> {
    switch (groupConfig.mode) {
      case 'ForceEncrypted':
        return this.forceEncrypt(content, groupId);

      case 'NoEncryption':
        return this.noEncrypt(content);

      case 'Optional':
        return userPreference
          ? this.forceEncrypt(content, groupId)
          : this.noEncrypt(content);

      case 'Smart':
        return this.intelligentEncrypt(content, groupId, groupConfig);

      default:
        throw new Error(`Unknown encryption mode: ${groupConfig.mode}`);
    }
  }

  /**
   * å¼ºåˆ¶åŠ å¯†æ¨¡å¼
   */
  private async forceEncrypt(content: string, groupId: string) {
    const groupKey = await this.getGroupKey(groupId);
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encoder = new TextEncoder();

    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      groupKey,
      encoder.encode(content)
    );

    // ç»„åˆIVå’ŒåŠ å¯†æ•°æ®
    const combined = new Uint8Array(iv.length + encrypted.byteLength);
    combined.set(iv);
    combined.set(new Uint8Array(encrypted), iv.length);

    return {
      encrypted: combined,
      method: 'aes-gcm' as const,
    };
  }

  /**
   * éåŠ å¯†æ¨¡å¼
   */
  private async noEncrypt(content: string) {
    const encoder = new TextEncoder();
    return {
      encrypted: encoder.encode(content),
      method: 'plaintext' as const,
    };
  }

  /**
   * æ™ºèƒ½åŠ å¯†å†³ç­–
   */
  private async intelligentEncrypt(
    content: string,
    groupId: string,
    config: EncryptionConfig
  ) {
    // å†³ç­–é€»è¾‘
    const shouldEncrypt = this.analyzeContentForEncryption(content);

    if (shouldEncrypt) {
      return this.forceEncrypt(content, groupId);
    } else {
      return this.noEncrypt(content);
    }
  }

  /**
   * å†…å®¹åˆ†æï¼ˆå†³å®šæ˜¯å¦éœ€è¦åŠ å¯†ï¼‰
   */
  private analyzeContentForEncryption(content: string): boolean {
    // è§„åˆ™1ï¼šç³»ç»Ÿå‘½ä»¤ä¸åŠ å¯†
    if (content.startsWith('/') || content.startsWith('@everyone')) {
      return false;
    }

    // è§„åˆ™2ï¼šæ•æ„Ÿè¯æ±‡åŠ å¯†
    const sensitivePatterns = [
      /password/i, /secret/i, /private/i, /confidential/i,
      /é’±åŒ…/i, /å¯†ç /i, /ç§é’¥/i, /åŠ©è®°è¯/i
    ];

    if (sensitivePatterns.some(pattern => pattern.test(content))) {
      return true;
    }

    // è§„åˆ™3ï¼šé•¿å†…å®¹åŠ å¯†
    if (content.length > 500) {
      return true;
    }

    // è§„åˆ™4ï¼šåŒ…å«é“¾æ¥æˆ–ä»£ç 
    if (content.includes('http://') || content.includes('https://') ||
        content.includes('```') || content.includes('0x')) {
      return true;
    }

    // é»˜è®¤ä¸åŠ å¯†ï¼ˆå…¬å¼€è®¨è®ºï¼‰
    return false;
  }

  /**
   * æ™ºèƒ½è§£å¯†
   */
  async smartDecrypt(
    encryptedData: Uint8Array,
    encryptionInfo: EncryptionInfo,
    groupId: string
  ): Promise<string> {
    if (!encryptionInfo?.is_encrypted) {
      // æ˜æ–‡æ•°æ®
      const decoder = new TextDecoder();
      return decoder.decode(encryptedData);
    }

    // åŠ å¯†æ•°æ®
    const groupKey = await this.getGroupKey(groupId, encryptionInfo.key_id);
    const iv = encryptedData.slice(0, 12);
    const encrypted = encryptedData.slice(12);

    const decrypted = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv },
      groupKey,
      encrypted
    );

    const decoder = new TextDecoder();
    return decoder.decode(decrypted);
  }

  /**
   * è·å–ç¾¤å¯†é’¥
   */
  private async getGroupKey(groupId: string, keyId?: number): Promise<CryptoKey> {
    const cacheKey = `${groupId}-${keyId || 'current'}`;

    if (this.groupKeys.has(cacheKey)) {
      return this.groupKeys.get(cacheKey)!;
    }

    // ä»é“¾ä¸Šæˆ–æœ¬åœ°å­˜å‚¨è·å–åŠ å¯†çš„ç¾¤å¯†é’¥
    const encryptedGroupKey = await this.fetchEncryptedGroupKey(groupId, keyId);
    const userPrivateKey = await this.getUserPrivateKey();

    // è§£å¯†ç¾¤å¯†é’¥
    const decryptedGroupKey = await this.decryptGroupKeyWithUserKey(
      encryptedGroupKey,
      userPrivateKey
    );

    // å¯¼å…¥ä¸ºCryptoKey
    const groupKey = await crypto.subtle.importKey(
      'raw',
      decryptedGroupKey,
      { name: 'AES-GCM' },
      false,
      ['encrypt', 'decrypt']
    );

    this.groupKeys.set(cacheKey, groupKey);
    return groupKey;
  }

  /**
   * å¯†é’¥è½®æ¢å¤„ç†
   */
  async handleKeyRotation(groupId: string, newKeyVersion: number) {
    // æ¸…é™¤æ—§å¯†é’¥ç¼“å­˜
    const oldCacheKeys = Array.from(this.groupKeys.keys())
      .filter(key => key.startsWith(`${groupId}-`));

    oldCacheKeys.forEach(key => this.groupKeys.delete(key));
    this.keyVersions.set(groupId, newKeyVersion);

    // é¢„åŠ è½½æ–°å¯†é’¥
    await this.getGroupKey(groupId, newKeyVersion);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
export const hybridEncryption = HybridChatEncryption.getInstance();

// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
const sendMessage = async (content: string) => {
  const result = await hybridEncryption.smartEncrypt(
    content,
    groupId,
    groupInfo.encryption_config,
    encryptionEnabled
  );

  let messageContentInput: MessageContentInput;

  if (result.method === 'plaintext' && content.length <= 256) {
    messageContentInput = { ShortText: result.encrypted };
  } else if (result.cid) {
    messageContentInput = { IpfsCid: result.cid };
  } else {
    const cid = await uploadToIPFS(result.encrypted);
    messageContentInput = { IpfsCid: cid };
  }

  // å‘é€åˆ°é“¾ä¸Š
  await api.tx.groupChat.sendGroupMessage(
    groupId,
    messageContentInput,
    0,
    null,
    result.method !== 'plaintext'
  ).signAndSend(account);
};
```

---

## ğŸ“Š æ€§èƒ½ä¸æ‰©å±•æ€§åˆ†æ

### 1. å­˜å‚¨å¼€é”€å¯¹æ¯”

| ç¾¤ç»„ç±»å‹ | é“¾ä¸Šå­˜å‚¨ | IPFSå­˜å‚¨ | å¯†é’¥ç®¡ç† | æ€»å¼€é”€ |
|---------|---------|---------|---------|-------|
| **å¼ºåˆ¶åŠ å¯†ç¾¤** | å…ƒæ•°æ®(~200B) | åŠ å¯†å†…å®¹(+20%ä½“ç§¯) | ç¾¤å¯†é’¥ç®¡ç† | ä¸­ç­‰ |
| **éåŠ å¯†ç¾¤** | å…ƒæ•°æ®+çŸ­æ¶ˆæ¯(~500B) | é•¿å†…å®¹æ˜æ–‡ | æ—  | æœ€ä½ |
| **æ™ºèƒ½æ··åˆç¾¤** | åŠ¨æ€(200-500B) | æ··åˆå­˜å‚¨ | å¯é€‰å¯†é’¥ç®¡ç† | å¹³è¡¡ |

### 2. æ€§èƒ½æŒ‡æ ‡æµ‹è¯•

```typescript
// stardust-dapp/src/utils/performanceAnalysis.ts

export class ChatPerformanceAnalyzer {
  static async benchmarkEncryption() {
    const testData = "Hello World ".repeat(100); // ~1.2KB
    const iterations = 1000;

    console.time('Force Encryption');
    for (let i = 0; i < iterations; i++) {
      await hybridEncryption.forceEncrypt(testData, 'test-group');
    }
    console.timeEnd('Force Encryption');

    console.time('No Encryption');
    for (let i = 0; i < iterations; i++) {
      await hybridEncryption.noEncrypt(testData);
    }
    console.timeEnd('No Encryption');

    console.time('Smart Encryption');
    for (let i = 0; i < iterations; i++) {
      await hybridEncryption.intelligentEncrypt(testData, 'test-group', {
        mode: 'Smart',
        allow_mode_switch: true,
        key_rotation: 'OnMemberChange',
        storage_policy: 'Hybrid'
      });
    }
    console.timeEnd('Smart Encryption');
  }

  static async analyzeStorageCosts() {
    const messages = [
      { type: 'çŸ­æ–‡æœ¬', content: 'Hello', encrypted: false },
      { type: 'é•¿æ–‡æœ¬', content: 'A'.repeat(1000), encrypted: false },
      { type: 'åŠ å¯†çŸ­æ–‡æœ¬', content: 'Hello', encrypted: true },
      { type: 'åŠ å¯†é•¿æ–‡æœ¬', content: 'A'.repeat(1000), encrypted: true },
    ];

    const results = [];

    for (const msg of messages) {
      const startSize = new Blob([msg.content]).size;

      let processedSize: number;
      if (msg.encrypted) {
        const encrypted = await hybridEncryption.forceEncrypt(msg.content, 'test');
        processedSize = encrypted.encrypted.length;
      } else {
        processedSize = new Blob([msg.content]).size;
      }

      results.push({
        type: msg.type,
        originalSize: startSize,
        processedSize,
        overhead: ((processedSize - startSize) / startSize * 100).toFixed(1) + '%',
        storageLocation: msg.encrypted || startSize > 256 ? 'IPFS' : 'OnChain'
      });
    }

    console.table(results);
  }
}
```

### 3. æ‰©å±•æ€§è€ƒè™‘

```rust
// runtime/src/configs/chat_optimizations.rs

parameter_types! {
    // æ€§èƒ½è°ƒä¼˜å‚æ•°
    pub const MaxOnChainContentLen: u32 = 256;      // çŸ­æ¶ˆæ¯ç›´æ¥ä¸Šé“¾
    pub const MaxSummaryLen: u32 = 64;              // æ··åˆå­˜å‚¨æ‘˜è¦é•¿åº¦
    pub const MaxEncryptedKeyLen: u32 = 512;        // åŠ å¯†å¯†é’¥æœ€å¤§é•¿åº¦
    pub const MaxGroupsPerUser: u32 = 100;          // æ¯ç”¨æˆ·æœ€å¤§ç¾¤æ•°
    pub const MaxKeysPerGroup: u32 = 1000;          // æ¯ç¾¤æœ€å¤§å¯†é’¥æ•°

    // ç¼“å­˜å’Œæ¸…ç†
    pub const MessageCacheWindow: BlockNumber = 1000;   // æ¶ˆæ¯ç¼“å­˜çª—å£
    pub const KeyRotationCooldown: BlockNumber = 100;   // å¯†é’¥è½®æ¢å†·å´æœŸ
    pub const GroupCleanupThreshold: u32 = 30;          // ç¾¤æ¸…ç†é˜ˆå€¼ï¼ˆå¤©ï¼‰
}

// æ‰¹é‡æ“ä½œæ”¯æŒ
impl<T: Config> Pallet<T> {
    /// æ‰¹é‡æ¶ˆæ¯å‘é€ï¼ˆå…¬å‘Šã€é€šçŸ¥ç­‰ï¼‰
    #[pallet::weight(T::WeightInfo::send_batch_messages(recipients.len() as u32))]
    pub fn send_batch_messages(
        origin: OriginFor<T>,
        recipients: Vec<T::Hash>, // ç¾¤ç»„åˆ—è¡¨
        content: MessageContentInput,
        msg_type: BroadcastType,
        encryption_override: Option<bool>,
    ) -> DispatchResult {
        let sender = ensure_signed(origin)?;

        for group_id in recipients {
            // æ£€æŸ¥å‘é€æƒé™
            ensure!(
                Self::check_permission(&group_id, &sender, MemberRole::Admin)?,
                Error::<T>::InsufficientPermission
            );

            // æ ¹æ®ç¾¤è®¾ç½®å’Œoverrideå†³å®šåŠ å¯†æ–¹å¼
            let should_encrypt = Self::determine_batch_encryption(
                &group_id,
                encryption_override,
                &msg_type
            )?;

            // å‘é€æ¶ˆæ¯
            Self::do_send_group_message(
                &group_id,
                &sender,
                content.clone(),
                GroupMessageType::from(msg_type),
                None,
                should_encrypt,
            )?;
        }

        Self::deposit_event(Event::BatchMessagesSent {
            sender,
            recipient_count: recipients.len() as u32,
            msg_type,
        });

        Ok(())
    }

    /// ç¾¤æ¶ˆæ¯æœç´¢ï¼ˆä»…æ”¯æŒéåŠ å¯†ç¾¤æˆ–å·²è§£å¯†å†…å®¹ï¼‰
    pub fn search_group_messages(
        group_id: &T::Hash,
        query: &[u8],
        limit: u32,
    ) -> Result<Vec<u64>, DispatchError> {
        let group = Groups::<T>::get(group_id).ok_or(Error::<T>::GroupNotFound)?;

        // åªæœ‰éåŠ å¯†ç¾¤æ”¯æŒæœåŠ¡ç«¯æœç´¢
        if group.encryption_config.mode != EncryptionMode::NoEncryption {
            return Err(Error::<T>::SearchNotSupportedInEncryptedGroup.into());
        }

        let mut results = Vec::new();
        let messages = GroupMessageList::<T>::iter_prefix(group_id)
            .take(limit as usize);

        for (msg_id, _) in messages {
            if let Some(message) = GroupMessages::<T>::get(msg_id) {
                // æ£€æŸ¥é“¾ä¸Šå­˜å‚¨çš„å†…å®¹
                if let MessageContent::OnChain(content) = &message.content {
                    if content.as_ref().windows(query.len()).any(|w| w == query) {
                        results.push(msg_id);
                    }
                }
                // IPFSå†…å®¹éœ€è¦å®¢æˆ·ç«¯æœç´¢
            }
        }

        Ok(results)
    }
}
```

---

## ğŸ¯ å‡çº§å®æ–½è·¯çº¿å›¾

### Phase 1: æ ¸å¿ƒæ¶æ„å‡çº§ âœ…
- âœ… è®¾è®¡æ··åˆåŠ å¯†æ¶æ„
- âœ… é‡æ–°å®šä¹‰ç¾¤ç»„ç±»å‹å’ŒåŠ å¯†é…ç½®
- âœ… å‡çº§æ•°æ®ç»“æ„æ”¯æŒå¤šç§å­˜å‚¨æ¨¡å¼

### Phase 2: Pallet å‡çº§å¼€å‘ï¼ˆå½“å‰é˜¶æ®µï¼‰
- ğŸ”¨ å®ç° `pallet-group-chat` æ··åˆæ¨¡å¼
- ğŸ”¨ æ·»åŠ æ™ºèƒ½CIDéªŒè¯é€»è¾‘
- ğŸ”¨ å®ç°å¯†é’¥ç®¡ç†å’Œè½®æ¢æœºåˆ¶
- ğŸ”¨ ç¼–å†™å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
- ğŸ”¨ æƒé‡è®¡ç®—å’Œæ€§èƒ½ä¼˜åŒ–

### Phase 3: å‰ç«¯é›†æˆå¼€å‘
- ğŸ“… å¼€å‘æ··åˆåŠ å¯†å·¥å…·åº“
- ğŸ“… å‡çº§ç¾¤èŠUIç»„ä»¶
- ğŸ“… å®ç°åŠ å¯†åˆ‡æ¢æ§åˆ¶
- ğŸ“… æ·»åŠ æ€§èƒ½ç›‘æ§å’Œåˆ†æ
- ğŸ“… ç”¨æˆ·ä½“éªŒä¼˜åŒ–

### Phase 4: é«˜çº§åŠŸèƒ½å¼€å‘
- ğŸ“… æ‰¹é‡æ¶ˆæ¯å‘é€
- ğŸ“… ç¾¤å†…æœç´¢ï¼ˆéåŠ å¯†ç¾¤ï¼‰
- ğŸ“… æ¶ˆæ¯ç»Ÿè®¡å’Œåˆ†æ
- ğŸ“… ç®¡ç†é¢æ¿å’Œç›‘æ§
- ğŸ“… ç¬¬ä¸‰æ–¹é›†æˆAPI

### Phase 5: ç”Ÿäº§éƒ¨ç½²ä¼˜åŒ–
- ğŸ“… å®‰å…¨å®¡è®¡å’Œæµ‹è¯•
- ğŸ“… æ€§èƒ½åŸºå‡†æµ‹è¯•
- ğŸ“… æ–‡æ¡£å’ŒåŸ¹è®­ææ–™
- ğŸ“… ç¤¾åŒºåé¦ˆå’Œè¿­ä»£
- ğŸ“… æ­£å¼ç‰ˆå‘å¸ƒ

---

## ğŸ“š é…ç½®ç¤ºä¾‹å’Œæœ€ä½³å®è·µ

### 1. Runtime é…ç½®æ¨è

```rust
// runtime/src/configs/chat_hybrid.rs
impl pallet_group_chat::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type WeightInfo = pallet_group_chat::weights::SubstrateWeight<Runtime>;

    // åŸºç¡€é…ç½®
    type MaxCidLen = ConstU32<128>;
    type MaxGroupNameLen = ConstU32<50>;
    type MaxGroupDescLen = ConstU32<500>;
    type MaxNicknameLen = ConstU32<30>;
    type DefaultMaxMembers = ConstU32<500>;

    // æ–°å¢ï¼šæ··åˆæ¨¡å¼é…ç½®
    type MaxOnChainContentLen = ConstU32<256>;      // çŸ­æ¶ˆæ¯é˜ˆå€¼
    type MaxSummaryLen = ConstU32<64>;              // æ‘˜è¦é•¿åº¦
    type MaxEncryptedKeyLen = ConstU32<512>;        // åŠ å¯†å¯†é’¥é•¿åº¦

    // æ€§èƒ½é…ç½®
    type MessageRecallWindow = ConstU32<20>;        // 2åˆ†é’Ÿæ’¤å›çª—å£
    type RateLimitWindow = ConstU32<100>;          // 10åˆ†é’Ÿé™åˆ¶çª—å£
    type MaxMessagesPerWindow = ConstU32<50>;      // çª—å£å†…æœ€å¤§æ¶ˆæ¯æ•°
    type KeyRotationCooldown = ConstU32<10>;       // å¯†é’¥è½®æ¢å†·å´æœŸ

    // å­˜å‚¨ä¼˜åŒ–
    type GroupExpirationTime = ConstU32<518400>;   // 360å¤©ä¸æ´»è·ƒæ¸…ç†
    type MessageCacheWindow = ConstU32<1000>;      // æ¶ˆæ¯ç¼“å­˜çª—å£
    type MaxGroupsPerUser = ConstU32<100>;         // ç”¨æˆ·æœ€å¤§ç¾¤ç»„æ•°
}
```

### 2. å‰ç«¯é…ç½®æœ€ä½³å®è·µ

```typescript
// stardust-dapp/src/config/chatHybrid.ts
export const HYBRID_CHAT_CONFIG = {
  // åŠ å¯†é…ç½®
  encryption: {
    forceEncrypted: {
      algorithm: 'AES-GCM',
      keySize: 256,
      keyRotation: 'OnMemberChange',
      description: 'æ‰€æœ‰æ¶ˆæ¯å¼ºåˆ¶ç«¯åˆ°ç«¯åŠ å¯†ï¼Œæœ€é«˜éšç§ä¿æŠ¤',
    },
    noEncryption: {
      enableOnChainStorage: true,
      onChainLimit: 256, // å­—èŠ‚
      enableSearch: true,
      description: 'æ‰€æœ‰æ¶ˆæ¯å…¬å¼€é€æ˜ï¼Œæ”¯æŒæœç´¢å’Œå®¡è®¡',
    },
    optional: {
      defaultEncryption: false,
      allowUserOverride: true,
      rememberPreference: true,
      description: 'ç”¨æˆ·å¯è‡ªç”±é€‰æ‹©æ¯æ¡æ¶ˆæ¯çš„åŠ å¯†çŠ¶æ€',
    },
    smart: {
      sensitiveKeywords: ['password', 'secret', 'private', 'å¯†ç ', 'ç§é’¥'],
      encryptLongMessages: true,
      longMessageThreshold: 500, // å­—ç¬¦
      encryptMediaFiles: true,
      description: 'æ™ºèƒ½åˆ†ææ¶ˆæ¯å†…å®¹ï¼Œè‡ªåŠ¨å†³å®šåŠ å¯†ç­–ç•¥',
    },
  },

  // å­˜å‚¨ç­–ç•¥
  storage: {
    onChainLimit: 256,        // é“¾ä¸Šå­˜å‚¨é˜ˆå€¼ï¼ˆå­—èŠ‚ï¼‰
    ipfsTimeout: 30000,       // IPFSæ“ä½œè¶…æ—¶ï¼ˆæ¯«ç§’ï¼‰
    enableLocalCache: true,   // å¯ç”¨æœ¬åœ°ç¼“å­˜
    cacheExpiry: 86400,       // ç¼“å­˜è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰
    enableCompression: true,  // å¯ç”¨å†…å®¹å‹ç¼©
  },

  // ç”¨æˆ·ä½“éªŒ
  ui: {
    showEncryptionStatus: true,     // æ˜¾ç¤ºåŠ å¯†çŠ¶æ€å›¾æ ‡
    encryptionIndicators: {
      forceEncrypted: 'ğŸ”',
      noEncryption: 'ğŸ”“',
      optional: 'ğŸ”’',
      smart: 'ğŸ§ ',
    },
    defaultMessageMode: 'auto',     // é»˜è®¤æ¶ˆæ¯æ¨¡å¼
    enableQuickToggle: true,        // å¯ç”¨å¿«é€ŸåŠ å¯†åˆ‡æ¢
    showStorageType: true,          // æ˜¾ç¤ºå­˜å‚¨ç±»å‹
  },

  // æ€§èƒ½ä¼˜åŒ–
  performance: {
    messageLoadBatch: 50,           // æ¶ˆæ¯åŠ è½½æ‰¹æ¬¡å¤§å°
    enableVirtualScrolling: true,   // å¯ç”¨è™šæ‹Ÿæ»šåŠ¨
    preloadGroupKeys: true,         // é¢„åŠ è½½ç¾¤å¯†é’¥
    enableMessageCaching: true,     // å¯ç”¨æ¶ˆæ¯ç¼“å­˜
    maxCachedMessages: 1000,        // æœ€å¤§ç¼“å­˜æ¶ˆæ¯æ•°
  },
};

// ç¾¤ç»„åˆ›å»ºå‘å¯¼é…ç½®
export const GROUP_CREATION_TEMPLATES = {
  privateDiscussion: {
    name: 'ç§å¯†è®¨è®º',
    encryptionConfig: {
      mode: 'ForceEncrypted',
      allow_mode_switch: false,
      key_rotation: 'OnMemberChange',
      storage_policy: 'IpfsOnly',
    },
    suggested_max_members: 20,
    description: 'é€‚åˆç§å¯†å•†åŠ¡è®¨è®ºã€æ•æ„Ÿè¯é¢˜äº¤æµ',
  },

  publicCommunity: {
    name: 'å…¬å¼€ç¤¾åŒº',
    encryptionConfig: {
      mode: 'NoEncryption',
      allow_mode_switch: false,
      key_rotation: 'Never',
      storage_policy: 'OnChainShort',
    },
    suggested_max_members: 500,
    public_visibility: true,
    description: 'é€‚åˆå¼€æ”¾è®¨è®ºã€ç¤¾åŒºå…¬å‘Šã€æŠ€æœ¯äº¤æµ',
  },

  flexibleTeam: {
    name: 'çµæ´»å›¢é˜Ÿ',
    encryptionConfig: {
      mode: 'Optional',
      allow_mode_switch: true,
      key_rotation: 'Manual',
      storage_policy: 'Hybrid',
    },
    suggested_max_members: 100,
    description: 'é€‚åˆå›¢é˜Ÿåä½œï¼Œæˆå‘˜å¯æ ¹æ®å†…å®¹é€‰æ‹©åŠ å¯†',
  },

  smartWorkspace: {
    name: 'æ™ºèƒ½å·¥ä½œåŒº',
    encryptionConfig: {
      mode: 'Smart',
      allow_mode_switch: true,
      key_rotation: 'OnMemberChange',
      storage_policy: 'Hybrid',
    },
    suggested_max_members: 200,
    description: 'é€‚åˆå¤šç”¨é€”ç¾¤ç»„ï¼ŒAIæ™ºèƒ½é€‰æ‹©åŠ å¯†ç­–ç•¥',
  },
};
```

### 3. éƒ¨ç½²æ£€æŸ¥æ¸…å•

```bash
#!/bin/bash
# æ··åˆèŠå¤©ç³»ç»Ÿéƒ¨ç½²æ£€æŸ¥è„šæœ¬

echo "ğŸš€ Stardust æ··åˆèŠå¤©ç³»ç»Ÿéƒ¨ç½²æ£€æŸ¥"
echo "================================"

# 1. é“¾ç«¯æ£€æŸ¥
echo "ğŸ“‹ æ£€æŸ¥é“¾ç«¯é…ç½®..."
if cargo check -p pallet-group-chat --features runtime-benchmarks; then
    echo "âœ… pallet-group-chat ç¼–è¯‘é€šè¿‡"
else
    echo "âŒ pallet-group-chat ç¼–è¯‘å¤±è´¥"
    exit 1
fi

# 2. Runtimeé…ç½®æ£€æŸ¥
echo "ğŸ“‹ æ£€æŸ¥Runtimeé…ç½®..."
if grep -q "MaxOnChainContentLen" runtime/src/lib.rs; then
    echo "âœ… æ··åˆå­˜å‚¨é…ç½®å·²æ·»åŠ "
else
    echo "âš ï¸  è¯·æ£€æŸ¥Runtimeæ··åˆå­˜å‚¨é…ç½®"
fi

# 3. IPFSæ£€æŸ¥
echo "ğŸ“‹ æ£€æŸ¥IPFSè¿æ¥..."
if curl -f http://localhost:5001/api/v0/id; then
    echo "âœ… IPFSèŠ‚ç‚¹è¿è¡Œæ­£å¸¸"
else
    echo "âŒ IPFSèŠ‚ç‚¹è¿æ¥å¤±è´¥"
    exit 1
fi

# 4. å‰ç«¯ä¾èµ–æ£€æŸ¥
echo "ğŸ“‹ æ£€æŸ¥å‰ç«¯ä¾èµ–..."
cd stardust-dapp
if npm list @polkadot/api crypto-js; then
    echo "âœ… å‰ç«¯åŠ å¯†ä¾èµ–å·²å®‰è£…"
else
    echo "âŒ å‰ç«¯ä¾èµ–ç¼ºå¤±ï¼Œè¯·è¿è¡Œ npm install"
    exit 1
fi

# 5. é…ç½®æ–‡ä»¶æ£€æŸ¥
echo "ğŸ“‹ æ£€æŸ¥é…ç½®æ–‡ä»¶..."
if [ -f "src/config/chatHybrid.ts" ]; then
    echo "âœ… æ··åˆèŠå¤©é…ç½®æ–‡ä»¶å­˜åœ¨"
else
    echo "âš ï¸  è¯·åˆ›å»ºæ··åˆèŠå¤©é…ç½®æ–‡ä»¶"
fi

echo "ğŸ‰ æ£€æŸ¥å®Œæˆï¼è¯·æ ¹æ®ä¸Šè¿°ç»“æœè°ƒæ•´é…ç½®ã€‚"
```

---

## ğŸ“ æ€»ç»“ä¸å‡çº§è¦ç‚¹

æœ¬ v2.0 å‡çº§æ–¹æ¡ˆç›¸æ¯”åŸç‰ˆæœ¬çš„ä¸»è¦æ”¹è¿›ï¼š

### ğŸ†• æ ¸å¿ƒæ–°åŠŸèƒ½
1. **æ··åˆåŠ å¯†æ¶æ„**ï¼šæ”¯æŒå¼ºåˆ¶åŠ å¯†ã€ç¦ç”¨åŠ å¯†ã€å¯é€‰åŠ å¯†ã€æ™ºèƒ½åŠ å¯†å››ç§æ¨¡å¼
2. **çµæ´»å­˜å‚¨ç­–ç•¥**ï¼šé“¾ä¸ŠçŸ­æ¶ˆæ¯ã€IPFSé•¿å†…å®¹ã€æ··åˆå­˜å‚¨ã€ä¸´æ—¶å­˜å‚¨
3. **æ™ºèƒ½åŠ å¯†å†³ç­–**ï¼šåŸºäºå†…å®¹åˆ†æçš„è‡ªåŠ¨åŠ å¯†é€‰æ‹©
4. **å¯†é’¥ç®¡ç†å‡çº§**ï¼šæ”¯æŒå¯†é’¥è½®æ¢ã€ç‰ˆæœ¬æ§åˆ¶ã€æ‰¹é‡åˆ†å‘

### ğŸ”§ æŠ€æœ¯ä¼˜åŒ–
1. **æ€§èƒ½æå‡**ï¼šéåŠ å¯†ç¾¤æ”¯æŒé“¾ä¸Šç›´æ¥å­˜å‚¨ï¼Œå‡å°‘IPFSä¾èµ–
2. **å­˜å‚¨ä¼˜åŒ–**ï¼šæ ¹æ®æ¶ˆæ¯é•¿åº¦å’Œç±»å‹æ™ºèƒ½é€‰æ‹©å­˜å‚¨æ–¹å¼
3. **ç”¨æˆ·ä½“éªŒ**ï¼šå¯è§†åŒ–åŠ å¯†çŠ¶æ€ï¼Œçµæ´»çš„åŠ å¯†æ§åˆ¶
4. **æ‰©å±•æ€§å¢å¼º**ï¼šæ”¯æŒæ‰¹é‡æ“ä½œã€æœç´¢åŠŸèƒ½ã€ç›‘æ§åˆ†æ

### ğŸ›¡ï¸ å®‰å…¨åŠ å¼º
1. **åˆ†çº§éšç§ä¿æŠ¤**ï¼šä»å®Œå…¨å…¬å¼€åˆ°ç«¯åˆ°ç«¯åŠ å¯†çš„å…¨è°±è¦†ç›–
2. **å¯†é’¥è½®æ¢æœºåˆ¶**ï¼šæ”¯æŒå®šæœŸã€äº‹ä»¶é©±åŠ¨ã€æ‰‹åŠ¨å¯†é’¥æ›´æ–°
3. **æ™ºèƒ½å¨èƒæ£€æµ‹**ï¼šåŸºäºå†…å®¹åˆ†æçš„è‡ªåŠ¨åŠ å¯†å»ºè®®
4. **å®¡è®¡å‹å¥½**ï¼šéåŠ å¯†ç¾¤æ”¯æŒå®Œæ•´çš„é“¾ä¸Šå®¡è®¡

### ğŸ¯ åº”ç”¨åœºæ™¯æ‰©å±•
- **ç§å¯†å•†åŠ¡ç¾¤**ï¼šForceEncrypted æ¨¡å¼ï¼Œæœ€é«˜çº§åˆ«éšç§ä¿æŠ¤
- **å…¬å¼€ç¤¾åŒºç¾¤**ï¼šNoEncryption æ¨¡å¼ï¼Œé€æ˜é«˜æ•ˆçš„å…¬å…±è®¨è®º
- **çµæ´»åä½œç¾¤**ï¼šOptional æ¨¡å¼ï¼Œç”¨æˆ·è‡ªä¸»é€‰æ‹©åŠ å¯†
- **æ™ºèƒ½å·¥ä½œç¾¤**ï¼šSmart æ¨¡å¼ï¼ŒAIé©±åŠ¨çš„åŠ å¯†å†³ç­–

è¿™ä¸ªå‡çº§æ–¹æ¡ˆå®Œç¾å¹³è¡¡äº†**éšç§ä¿æŠ¤**ä¸**ä½¿ç”¨ä¾¿åˆ©**ï¼Œ**å®‰å…¨æ€§**ä¸**æ€§èƒ½è¡¨ç°**ï¼Œä¸ºä¸åŒåœºæ™¯çš„ç”¨æˆ·æä¾›äº†æœ€é€‚åˆçš„èŠå¤©è§£å†³æ–¹æ¡ˆã€‚

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"activeForm": "\u5206\u6790\u5f53\u524d\u804a\u5929\u7cfb\u7edf\u8bbe\u8ba1\u65b9\u6848", "content": "\u5206\u6790\u5f53\u524d\u804a\u5929\u7cfb\u7edf\u8bbe\u8ba1\u65b9\u6848\uff0c\u7406\u89e3\u73b0\u6709\u67b6\u6784", "status": "completed"}, {"activeForm": "\u8bbe\u8ba1\u52a0\u5bc6\u7fa4\u4e0e\u975e\u52a0\u5bc6\u7fa4\u7684\u67b6\u6784\u533a\u522b", "content": "\u8bbe\u8ba1\u52a0\u5bc6\u7fa4\u4e0e\u975e\u52a0\u5bc6\u7fa4\u7684\u67b6\u6784\u533a\u522b", "status": "completed"}, {"activeForm": "\u91cd\u65b0\u5b9a\u4e49\u7fa4\u7ec4\u7c7b\u578b\u679a\u4e3e", "content": "\u91cd\u65b0\u5b9a\u4e49\u7fa4\u7ec4\u7c7b\u578b\u679a\u4e3e\uff0c\u589e\u52a0\u52a0\u5bc6\u8bbe\u7f6e", "status": "completed"}, {"activeForm": "\u8bbe\u8ba1\u975e\u52a0\u5bc6\u7fa4\u7684\u6d88\u606f\u5b58\u50a8\u65b9\u6848", "content": "\u8bbe\u8ba1\u975e\u52a0\u5bc6\u7fa4\u7684\u6d88\u606f\u5b58\u50a8\u65b9\u6848", "status": "completed"}, {"activeForm": "\u66f4\u65b0\u7fa4\u7ec4\u7ba1\u7406\u51fd\u6570", "content": "\u66f4\u65b0\u7fa4\u7ec4\u7ba1\u7406\u51fd\u6570\u652f\u6301\u52a0\u5bc6\u8bbe\u7f6e", "status": "completed"}, {"activeForm": "\u91cd\u65b0\u8bbe\u8ba1\u52a0\u5bc6\u65b9\u6848", "content": "\u91cd\u65b0\u8bbe\u8ba1\u52a0\u5bc6\u65b9\u6848\uff0c\u652f\u6301\u6df7\u5408\u6a21\u5f0f", "status": "completed"}, {"activeForm": "\u66f4\u65b0\u524d\u7aef\u7ec4\u4ef6", "content": "\u66f4\u65b0\u524d\u7aef\u7ec4\u4ef6\u652f\u6301\u52a0\u5bc6/\u975e\u52a0\u5bc6\u5207\u6362", "status": "completed"}, {"activeForm": "\u5b8c\u5584\u914d\u7f6e\u53c2\u6570", "content": "\u5b8c\u5584\u914d\u7f6e\u53c2\u6570\u548c\u6743\u91cd\u8ba1\u7b97", "status": "completed"}, {"activeForm": "\u66f4\u65b0\u6587\u6863\u548c\u793a\u4f8b\u4ee3\u7801", "content": "\u66f4\u65b0\u6587\u6863\u548c\u793a\u4f8b\u4ee3\u7801", "status": "completed"}]