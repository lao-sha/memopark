# Stardust é¡¹ç›®æ¶æ„ä¼˜åŒ–æ–¹æ¡ˆ

**åˆ¶å®šæ—¥æœŸ**: 2025-10-27  
**åŸºäº**: å®‰å…¨å®¡è®¡æŠ¥å‘Š + ç°æœ‰30ä¸ªè‡ªç ”Palletåˆ†æ  
**ç›®æ ‡**: æå‡æ€§èƒ½ã€å®‰å…¨æ€§ã€å¯ç»´æŠ¤æ€§ã€å¯æ‰©å±•æ€§

---

## ğŸ“Š ä¼˜åŒ–æ¦‚è§ˆ

### ä¼˜åŒ–ç»´åº¦

| ç»´åº¦ | ç°çŠ¶è¯„åˆ† | ç›®æ ‡è¯„åˆ† | ä¼˜åŒ–æ–¹å‘ |
|------|---------|---------|----------|
| **æ€§èƒ½** | 3.5/5 | 4.5/5 | å­˜å‚¨ä¼˜åŒ–ã€æ‰¹å¤„ç†ã€å¼‚æ­¥æ‰§è¡Œ |
| **å®‰å…¨** | 4/5 | 5/5 | ä¿®å¤3ä¸ªé«˜å±é—®é¢˜ã€å¢å¼ºéªŒè¯ |
| **å¯ç»´æŠ¤æ€§** | 3/5 | 4.5/5 | å‡å°‘å†—ä½™ã€ä½¿ç”¨å®˜æ–¹pallet |
| **å¯æ‰©å±•æ€§** | 3/5 | 4.5/5 | æ¨¡å—åŒ–ã€traitæŠ½è±¡ã€è·¨é“¾ |
| **ç”¨æˆ·ä½“éªŒ** | 3.5/5 | 4.5/5 | å‰ç«¯ä¼˜åŒ–ã€é”™è¯¯æç¤ºã€Gasä¼˜åŒ– |

---

## ğŸ—ï¸ ä¸€ã€æ¶æ„çº§ä¼˜åŒ–æ–¹æ¡ˆ

### 1.1 é‡‡ç”¨Substrateå®˜æ–¹Palletæ›¿ä»£è‡ªç ”ï¼ˆé™ä½ç»´æŠ¤æˆæœ¬ï¼‰

#### âœ… å¯æ›¿ä»£çš„è‡ªç ”Pallet

| è‡ªç ”Pallet | å®˜æ–¹/ç”Ÿæ€æ›¿ä»£æ–¹æ¡ˆ | ä¼˜åŠ¿ | è¿ç§»éš¾åº¦ | å»ºè®® |
|-----------|-----------------|------|---------|------|
| `pallet-deposits` | **pallet-balances** (Holds API) | å®˜æ–¹ç»´æŠ¤ã€æ›´å®‰å…¨ | ä¸­ | **æ¨èæ›¿ä»£** |
| `pallet-arbitration` | **pallet-referenda** + **pallet-collective** | æˆç†Ÿçš„æ²»ç†æœºåˆ¶ | é«˜ | è¯„ä¼°åå†³å®š |
| `pallet-ledger` | **frame-system** (Account Info) | å†…ç½®åŠŸèƒ½ | ä½ | **æ¨èæ›¿ä»£** |
| `pallet-chat` | **off-chain messaging** + IPFS | å‡å°‘é“¾ä¸Šå­˜å‚¨ | ä¸­ | **æ¨èè¿ç§»** |
| `pallet-sudo` | **å®˜æ–¹pallet-sudo** | å·²æœ‰å®˜æ–¹å®ç° | æ—  | **ç«‹å³æ›¿ä»£** |

---

#### æ–¹æ¡ˆ1: ä½¿ç”¨ `pallet-balances` çš„ Holds API æ›¿ä»£ `pallet-deposits`

**ç°çŠ¶é—®é¢˜**:
- `pallet-deposits` è‡ªç ”æŠ¼é‡‘ç®¡ç†ï¼Œéœ€è¦æŒç»­ç»´æŠ¤
- åŠŸèƒ½ä¸å®˜æ–¹ `pallet-balances` çš„ Holds é‡å 

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```rust
// âœ… ä½¿ç”¨å®˜æ–¹ pallet-balances Holds API
use frame_support::traits::{
    fungible::{Inspect, MutateHold},
};

// å®šä¹‰ HoldReason æšä¸¾
#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug, TypeInfo, MaxEncodedLen)]
pub enum HoldReason {
    Appeal { appeal_id: u64 },
    OfferingReview { offering_id: u64 },
    TextComplaint { text_id: u64 },
    MediaComplaint { media_id: u64 },
}

// å†»ç»“æŠ¼é‡‘
T::Currency::hold(&HoldReason::Appeal { appeal_id }, &who, amount)?;

// é‡Šæ”¾æŠ¼é‡‘
T::Currency::release(&HoldReason::Appeal { appeal_id }, &who, amount, Precision::Exact)?;

// ç½šæ²¡æŠ¼é‡‘
T::Currency::transfer_on_hold(
    &HoldReason::Appeal { appeal_id },
    &who,
    &treasury,
    amount,
    Precision::Exact,
    Restriction::Free,
    Fortitude::Force,
)?;
```

**ä¼˜åŠ¿**:
- âœ… å®˜æ–¹ç»´æŠ¤ï¼Œå®‰å…¨æ€§æ›´é«˜
- âœ… ä¸ `pallet-balances` æ·±åº¦é›†æˆ
- âœ… å‡å°‘è‡ªç ”ä»£ç é‡çº¦500è¡Œ
- âœ… æ”¯æŒå¤šç§ HoldReasonï¼Œæ›´çµæ´»

**è¿ç§»æ­¥éª¤**:
1. å®šä¹‰ `HoldReason` æšä¸¾ï¼ˆ1å¤©ï¼‰
2. ä¿®æ”¹ `stardust-appeals` ç­‰palletä½¿ç”¨Holds APIï¼ˆ2-3å¤©ï¼‰
3. æ•°æ®è¿ç§»ï¼šå°† `pallet-deposits` çš„æŠ¼é‡‘è½¬ä¸ºHoldsï¼ˆ1å¤©ï¼‰
4. å½’æ¡£ `pallet-deposits`ï¼ˆ1å¤©ï¼‰

**é£é™©**:
- âš ï¸ éœ€è¦runtimeå‡çº§å’Œæ•°æ®è¿ç§»
- âš ï¸ æµ‹è¯•å·¥ä½œé‡ä¸­ç­‰

---

#### æ–¹æ¡ˆ2: ä½¿ç”¨ Off-chain Messaging æ›¿ä»£ `pallet-chat`

**ç°çŠ¶é—®é¢˜**:
- `pallet-chat` å°†èŠå¤©æ¶ˆæ¯å­˜å‚¨åœ¨é“¾ä¸Š
- å­˜å‚¨æˆæœ¬é«˜ï¼Œå¯èƒ½è¢«æ»¥ç”¨ï¼ˆDoSæ”»å‡»ï¼‰
- éšç§ä¿æŠ¤ä¸è¶³

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```typescript
// âœ… é“¾ä¸‹èŠå¤©æ¶æ„ï¼ˆlibp2p + IPFSï¼‰

// 1. é“¾ä¸Šä»…å­˜å‚¨èŠå¤©ä¼šè¯å…ƒæ•°æ®
#[pallet::storage]
pub type ChatSessions<T: Config> = StorageDoubleMap<
    _,
    Blake2_128Concat, T::AccountId,  // ç”¨æˆ·A
    Blake2_128Concat, T::AccountId,  // ç”¨æˆ·B
    ChatSessionMetadata<T>,          // ä¼šè¯å…ƒæ•°æ®
    OptionQuery,
>;

pub struct ChatSessionMetadata<T: Config> {
    pub created_at: BlockNumberFor<T>,
    pub last_message_at: BlockNumberFor<T>,
    pub message_count: u32,
    pub ipfs_archive_cid: Option<BoundedVec<u8, ConstU32<256>>>,  // å½’æ¡£CID
}

// 2. å®æ—¶æ¶ˆæ¯é€šè¿‡ libp2p ç‚¹å¯¹ç‚¹ä¼ è¾“
// 3. é‡è¦æ¶ˆæ¯åŠ å¯†åå­˜å‚¨åˆ° IPFS
// 4. å®šæœŸå°†èŠå¤©è®°å½•å½’æ¡£åˆ° IPFSï¼Œé“¾ä¸Šä»…å­˜ CID
```

**æ¶æ„å›¾**:
```
ç”¨æˆ·A <--> libp2p P2P Network <--> ç”¨æˆ·B
  |                                    |
  v                                    v
IPFSï¼ˆåŠ å¯†å­˜å‚¨æ¶ˆæ¯ï¼‰          IPFSï¼ˆåŠ å¯†å­˜å‚¨æ¶ˆæ¯ï¼‰
  |                                    |
  v                                    v
Substrateé“¾ï¼ˆä»…å­˜CID + å…ƒæ•°æ®ï¼‰
```

**ä¼˜åŠ¿**:
- âœ… å­˜å‚¨æˆæœ¬é™ä½ 99%ï¼ˆé“¾ä¸Šä»…å­˜å…ƒæ•°æ®ï¼‰
- âœ… éšç§æ›´å¥½ï¼ˆç«¯åˆ°ç«¯åŠ å¯†ï¼‰
- âœ… å®æ—¶æ€§æ›´é«˜ï¼ˆlibp2pç‚¹å¯¹ç‚¹ï¼‰
- âœ… å¯æ‰©å±•æ€§å¼ºï¼ˆæ”¯æŒæ–‡ä»¶ã€å›¾ç‰‡ã€è§†é¢‘ï¼‰

**è¿ç§»æ­¥éª¤**:
1. æ­å»º libp2p æ¶ˆæ¯ä¸­ç»§èŠ‚ç‚¹ï¼ˆ3-5å¤©ï¼‰
2. å®ç°å‰ç«¯ libp2p å®¢æˆ·ç«¯ï¼ˆ5-7å¤©ï¼‰
3. é›†æˆ IPFS åŠ å¯†å­˜å‚¨ï¼ˆ2-3å¤©ï¼‰
4. æ•°æ®è¿ç§»ï¼šå°†å†å²èŠå¤©è®°å½•å½’æ¡£åˆ° IPFSï¼ˆ2å¤©ï¼‰
5. å½’æ¡£ `pallet-chat`ï¼ˆ1å¤©ï¼‰

**é£é™©**:
- âš ï¸ éœ€è¦è¿ç»´æ¶ˆæ¯ä¸­ç»§èŠ‚ç‚¹
- âš ï¸ å‰ç«¯å¤æ‚åº¦å¢åŠ 

---

#### æ–¹æ¡ˆ3: åˆå¹¶ `pallet-arbitration` åˆ° `pallet-stardust-appeals`

**ç°çŠ¶é—®é¢˜**:
- `pallet-arbitration` åŠŸèƒ½å•ä¸€ï¼Œå¯ä»¥ä½œä¸º `pallet-stardust-appeals` çš„ä¸€éƒ¨åˆ†
- å¢åŠ äº†ç³»ç»Ÿå¤æ‚åº¦

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```rust
// âœ… åœ¨ pallet-stardust-appeals ä¸­é›†æˆä»²è£åŠŸèƒ½

// ç”³è¯‰çŠ¶æ€æ‰©å±•
pub enum AppealStatus {
    Pending,
    Approved,
    Rejected,
    Withdrawn,
    Executed,
    RetryExhausted,
    AutoDismissed,
    // ğŸ†• æ–°å¢ä»²è£çŠ¶æ€
    InArbitration,       // è¿›å…¥ä»²è£
    ArbitrationApproved, // ä»²è£é€šè¿‡
    ArbitrationRejected, // ä»²è£é©³å›
}

// ä»²è£è®°å½•ï¼ˆå¯é€‰å­˜å‚¨ï¼‰
#[pallet::storage]
pub type ArbitrationRecords<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    u64, // appeal_id
    ArbitrationRecord<T>,
    OptionQuery,
>;

pub struct ArbitrationRecord<T: Config> {
    pub arbitrator: T::AccountId,
    pub started_at: BlockNumberFor<T>,
    pub evidence_cids: BoundedVec<BoundedVec<u8, ConstU32<256>>, ConstU32<10>>,
    pub decision: Option<ArbitrationDecision>,
    pub decided_at: Option<BlockNumberFor<T>>,
}

// æ–°å¢ä»²è£å‡½æ•°
#[pallet::call]
impl<T: Config> Pallet<T> {
    /// å‘èµ·ä»²è£ï¼ˆç”¨æˆ·æˆ–æ²»ç†ï¼‰
    pub fn initiate_arbitration(
        origin: OriginFor<T>,
        appeal_id: u64,
        reason_cid: BoundedVec<u8, ConstU32<256>>,
    ) -> DispatchResult {
        // ...
    }
    
    /// ä»²è£è£å†³ï¼ˆä»²è£å‘˜/æ²»ç†ï¼‰
    pub fn arbitrate(
        origin: OriginFor<T>,
        appeal_id: u64,
        decision: ArbitrationDecision,
        evidence_cid: BoundedVec<u8, ConstU32<256>>,
    ) -> DispatchResult {
        // ...
    }
}
```

**ä¼˜åŠ¿**:
- âœ… å‡å°‘ä¸€ä¸ªpalletï¼Œé™ä½ç»´æŠ¤æˆæœ¬
- âœ… ç”³è¯‰å’Œä»²è£é€»è¾‘æ›´ç»Ÿä¸€
- âœ… å‡å°‘è·¨palletè°ƒç”¨å¼€é”€

**è¿ç§»æ­¥éª¤**:
1. å°†ä»²è£é€»è¾‘é›†æˆåˆ° `pallet-stardust-appeals`ï¼ˆ3-5å¤©ï¼‰
2. æ•°æ®è¿ç§»ï¼ˆ1å¤©ï¼‰
3. å½’æ¡£ `pallet-arbitration`ï¼ˆ1å¤©ï¼‰

---

### 1.2 å¼•å…¥è·¨é“¾åŠŸèƒ½ï¼ˆå¢å¼ºäº’æ“ä½œæ€§ï¼‰

#### æ–¹æ¡ˆ4: é›†æˆ XCM æ”¯æŒè·¨é“¾èµ„äº§è½¬ç§»

**ä¸šåŠ¡åœºæ™¯**:
- ç”¨æˆ·ä» Polkadot/Kusama è½¬è´¦ DOT/KSM åˆ° Stardust
- Stardust æ¡¥æ¥ USDT åˆ° Polkadot ç”Ÿæ€å…¶ä»–é“¾
- è·¨é“¾ä¾›å¥‰å“è´­ä¹°ï¼ˆåœ¨ A é“¾è´­ä¹° B é“¾çš„ä¾›å¥‰å“ï¼‰

**æŠ€æœ¯æ–¹æ¡ˆ**:
```rust
// âœ… ä½¿ç”¨ XCM V5 å®ç°è·¨é“¾èµ„äº§è½¬ç§»

// 1. é…ç½® XCM æ‰§è¡Œå™¨
impl pallet_xcm::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type SendXcmOrigin = EnsureXcmOrigin<RuntimeOrigin, LocalOriginToLocation>;
    type XcmRouter = XcmRouter;
    type ExecuteXcmOrigin = EnsureXcmOrigin<RuntimeOrigin, LocalOriginToLocation>;
    type XcmExecuteFilter = Everything;
    type XcmExecutor = XcmExecutor<XcmConfig>;
    // ...
}

// 2. å®ç°è·¨é“¾ä¾›å¥‰å“è´­ä¹°
pub fn buy_offering_xcm(
    origin: OriginFor<T>,
    offering_id: u64,
    duration_weeks: u32,
    beneficiary_location: MultiLocation,  // ğŸ†• è·¨é“¾å—ç›Šäºº
) -> DispatchResult {
    let who = ensure_signed(origin)?;
    
    // è®¡ç®—è´¹ç”¨
    let amount = Self::calculate_offering_fee(offering_id, duration_weeks)?;
    
    // æ„å»º XCM ç¨‹åº
    let xcm = Xcm(vec![
        // 1. ä»ç”¨æˆ·è´¦æˆ·æå–èµ„äº§
        WithdrawAsset((Here, amount).into()),
        
        // 2. è´­ä¹°æ‰§è¡Œæƒé‡
        BuyExecution { 
            fees: (Here, amount / 10).into(),  // 10% ä½œä¸ºæ‰‹ç»­è´¹
            weight_limit: Limited(Weight::from_parts(1_000_000_000, 64 * 1024)),
        },
        
        // 3. åœ¨ç›®æ ‡é“¾æ‰§è¡Œä¾›å¥‰å“è´­ä¹°
        Transact {
            origin_kind: OriginKind::SovereignAccount,
            require_weight_at_most: Weight::from_parts(500_000_000, 32 * 1024),
            call: RuntimeCall::MemoOfferings(
                memo_offerings::Call::purchase_offering {
                    offering_id,
                    duration_weeks,
                }
            ).encode().into(),
        },
        
        // 4. å°†å‰©ä½™èµ„äº§å­˜å…¥å—ç›Šäººè´¦æˆ·
        DepositAsset {
            assets: All.into(),
            beneficiary: beneficiary_location,
        },
    ]);
    
    // æ‰§è¡Œ XCM
    let outcome = T::XcmExecutor::execute_xcm(Here, xcm, hash, Weight::MAX)?;
    
    Ok(())
}
```

**ä¼˜åŠ¿**:
- âœ… è¿æ¥ Polkadot ç”Ÿæ€ï¼Œæ‰©å¤§ç”¨æˆ·ç¾¤
- âœ… èµ„äº§æµåŠ¨æ€§æ›´å¼º
- âœ… è·¨é“¾ä¾›å¥‰å“å¸‚åœºï¼ˆåˆ›æ–°åŠŸèƒ½ï¼‰
- âœ… é™ä½æ¡¥æ¥æˆæœ¬ï¼ˆåˆ©ç”¨ XCM è€Œéä¸­å¿ƒåŒ–æ¡¥ï¼‰

**å®æ–½è·¯çº¿**:
1. Phase 1: é›†æˆ pallet-xcmï¼ˆ2-3å‘¨ï¼‰
2. Phase 2: å®ç° DOT/KSM èµ„äº§è½¬å…¥ï¼ˆ2å‘¨ï¼‰
3. Phase 3: å®ç°è·¨é“¾ä¾›å¥‰å“è´­ä¹°ï¼ˆ3-4å‘¨ï¼‰
4. Phase 4: é›†æˆ Polkadot Asset Hubï¼ˆ4-6å‘¨ï¼‰

---

#### æ–¹æ¡ˆ5: ä½¿ç”¨ ORML Pallets å¢å¼ºåŠŸèƒ½

**ORML (Open Runtime Module Library)** æ˜¯ Acala/Karura å¼€æºçš„é«˜è´¨é‡ Substrate pallet é›†åˆã€‚

**å¯ä½¿ç”¨çš„ ORML Pallets**:

| ORML Pallet | æ›¿ä»£è‡ªç ” | ç”¨é€” | ä¼˜åŠ¿ |
|------------|---------|------|------|
| `orml-tokens` | éƒ¨åˆ†æ›¿ä»£ `pallet-balances` | å¤šå¸ç§æ”¯æŒ | åŸç”Ÿæ”¯æŒå¤šèµ„äº§ |
| `orml-vesting` | å¯å¢å¼º `pallet-affiliate` | åˆ†æœŸé‡Šæ”¾å¥–åŠ± | çµæ´»çš„é‡Šæ”¾ç­–ç•¥ |
| `orml-oracle` | æ–°å¢åŠŸèƒ½ | ä»·æ ¼é¢„è¨€æœº | æ›´å¯é çš„ä»·æ ¼æº |
| `orml-nft` | å¯å¢å¼ºä¾›å¥‰å“ | NFT åŒ–ä¾›å¥‰å“ | æ ‡å‡†åŒ– NFT å®ç° |

**ç¤ºä¾‹ï¼šä½¿ç”¨ orml-oracle æ›¿ä»£ pallet-pricing**

```rust
// âœ… ä½¿ç”¨ ORML Oracle è·å–ä»·æ ¼

// 1. é…ç½® Oracle
impl orml_oracle::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type OnNewData = ();
    type CombineData = orml_oracle::DefaultCombineData<Runtime, MinimumCount, ExpiresIn>;
    type Time = Timestamp;
    type OracleKey = CurrencyId;
    type OracleValue = Price;
    type RootOperatorAccountId = RootOperatorAccountId;
    type Members = OracleMembers;
    type MaxHasDispatchedSize = ConstU32<40>;
    type WeightInfo = ();
}

// 2. è·å–ä»·æ ¼
let memo_usdt_price = orml_oracle::Pallet::<T>::get_no_op(&CurrencyId::DUST)?;
```

**ä¼˜åŠ¿**:
- âœ… ç¤¾åŒºç»´æŠ¤ï¼Œè´¨é‡é«˜
- âœ… ä¸ Polkadot ç”Ÿæ€æ·±åº¦é›†æˆ
- âœ… å‡å°‘è‡ªç ”ä»£ç é‡

---

## ğŸš€ äºŒã€æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ

### 2.1 ä¿®å¤é«˜å±æ€§èƒ½é—®é¢˜

#### æ–¹æ¡ˆ6: ä¼˜åŒ– `escrow::on_initialize`ï¼ˆH-1 ä¿®å¤ï¼‰

**é—®é¢˜**: è¿­ä»£æ‰€æœ‰ `ExpiryOf` å­˜å‚¨é¡¹ï¼ŒGasæ¶ˆè€—è¿‡é«˜

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```rust
// âŒ å½“å‰å®ç°ï¼ˆä½æ•ˆï¼‰
fn on_initialize(n: BlockNumberFor<T>) -> Weight {
    for (id, at) in ExpiryOf::<T>::iter() {  // è¿­ä»£æ‰€æœ‰é¡¹
        if at != n { continue; }  // å¤§éƒ¨åˆ†é¡¹ä¸åŒ¹é…
        // å¤„ç†åˆ°æœŸé¡¹
    }
}

// âœ… ä¼˜åŒ–æ–¹æ¡ˆ1: ä½¿ç”¨ ExpiringAt ç´¢å¼•ï¼ˆæ¨èï¼‰
#[pallet::storage]
pub type ExpiringAt<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    BlockNumberFor<T>,                          // åˆ°æœŸåŒºå—å·
    BoundedVec<u64, T::MaxExpiringPerBlock>,    // è¯¥åŒºå—åˆ°æœŸçš„è®¢å•åˆ—è¡¨
    ValueQuery,
>;

fn on_initialize(n: BlockNumberFor<T>) -> Weight {
    // ç›´æ¥è·å–å½“å‰å—åˆ°æœŸçš„é¡¹ï¼ŒO(1) å¤æ‚åº¦
    let expiring_ids = ExpiringAt::<T>::take(n);
    
    for id in expiring_ids.iter() {
        // å¤„ç†åˆ°æœŸé¡¹
        match T::ExpiryPolicy::on_expire(*id) {
            Ok(ExpiryAction::ReleaseAll(to)) => {
                let _ = <Self as Escrow<T::AccountId, BalanceOf<T>>>::release_all(*id, &to);
            }
            Ok(ExpiryAction::RefundAll(to)) => {
                let _ = <Self as Escrow<T::AccountId, BalanceOf<T>>>::refund_all(*id, &to);
            }
            _ => {}
        }
        ExpiryOf::<T>::remove(id);
    }
    
    Weight::from_parts(
        20_000u64.saturating_mul(expiring_ids.len() as u64), 
        0
    )
}

// schedule_expiry æ—¶åŒæ—¶æ›´æ–°ä¸¤ä¸ªç´¢å¼•
pub fn schedule_expiry(id: u64, at: BlockNumberFor<T>) -> DispatchResult {
    ExpiryOf::<T>::insert(id, at);
    
    // ğŸ†• æ›´æ–° ExpiringAt ç´¢å¼•
    ExpiringAt::<T>::try_mutate(at, |ids| -> DispatchResult {
        ids.try_push(id).map_err(|_| Error::<T>::TooManyExpiringItems)?;
        Ok(())
    })?;
    
    Ok(())
}
```

**æ€§èƒ½æå‡**:
- â±ï¸ **æ—¶é—´å¤æ‚åº¦**: O(N) â†’ O(1)ï¼ˆN = æ€»å­˜å‚¨é¡¹æ•°ï¼‰
- âš¡ **Gas æ¶ˆè€—**: å‡å°‘ 95%+
- ğŸ“ˆ **å¯æ‰©å±•æ€§**: æ”¯æŒç™¾ä¸‡çº§å­˜å‚¨é¡¹

---

#### æ–¹æ¡ˆ7: æ‰¹é‡å¤„ç†ä¼˜åŒ–ï¼ˆé€šç”¨æ–¹æ¡ˆï¼‰

**é€‚ç”¨èŒƒå›´**: `otc-order`, `simple-bridge`, `stardust-appeals` ç­‰éœ€è¦æ‰¹é‡å¤„ç†çš„pallet

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```rust
// âœ… æ‰¹é‡å¤„ç†æ¡†æ¶

#[pallet::call]
impl<T: Config> Pallet<T> {
    /// æ‰¹é‡åˆ›å»ºä¾›å¥‰å“ï¼ˆGas èŠ‚çœ 60%+ï¼‰
    #[pallet::call_index(10)]
    #[pallet::weight(T::WeightInfo::create_offering().saturating_mul(offerings.len() as u64))]
    pub fn batch_create_offerings(
        origin: OriginFor<T>,
        offerings: BoundedVec<OfferingParams, ConstU32<50>>,  // æœ€å¤š50ä¸ª
    ) -> DispatchResult {
        T::AdminOrigin::ensure_origin(origin)?;
        
        let mut succeeded = 0u32;
        let mut failed = 0u32;
        
        for (idx, params) in offerings.iter().enumerate() {
            match Self::do_create_offering(params.clone()) {
                Ok(offering_id) => {
                    succeeded = succeeded.saturating_add(1);
                    Self::deposit_event(Event::OfferingCreated { 
                        offering_id, 
                        batch_index: idx as u32,
                    });
                }
                Err(e) => {
                    failed = failed.saturating_add(1);
                    Self::deposit_event(Event::OfferingCreationFailed {
                        batch_index: idx as u32,
                        error: e,
                    });
                }
            }
        }
        
        Self::deposit_event(Event::BatchComplete { succeeded, failed });
        Ok(())
    }
}

// å†…éƒ¨å‡½æ•°ï¼ˆå¯å¤ç”¨ï¼‰
impl<T: Config> Pallet<T> {
    fn do_create_offering(params: OfferingParams) -> Result<u64, DispatchError> {
        // åŸ create_offering çš„æ ¸å¿ƒé€»è¾‘
        // ...
        Ok(offering_id)
    }
}
```

**ä¼˜åŠ¿**:
- âš¡ Gas èŠ‚çœ 60%+ï¼ˆå‡å°‘å¤šæ¬¡ç­¾åéªŒè¯ï¼‰
- ğŸš€ ååé‡æå‡ 5-10x
- ğŸ’° ç”¨æˆ·æˆæœ¬é™ä½

---

### 2.2 å­˜å‚¨ä¼˜åŒ–æ–¹æ¡ˆ

#### æ–¹æ¡ˆ8: å¼•å…¥äºŒçº§ç´¢å¼•ï¼ˆè§£å†³ M-1ï¼‰

**é—®é¢˜**: `stardust-appeals` çš„æŸ¥è¯¢æ•ˆç‡ä½

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```rust
// âœ… äºŒçº§ç´¢å¼•è®¾è®¡ï¼ˆå·²åœ¨ Phase 3.4 å®ç°ï¼Œè¿›ä¸€æ­¥ä¼˜åŒ–ï¼‰

// 1. æŒ‰ç”¨æˆ·ç´¢å¼•ï¼ˆåˆ†é¡µæ”¯æŒï¼‰
#[pallet::storage]
pub type AppealsByUserPaginated<T: Config> = StorageDoubleMap<
    _,
    Blake2_128Concat, T::AccountId,      // ç”¨æˆ·
    Blake2_128Concat, u64,                // é¡µç ï¼ˆæ¯é¡µ100æ¡ï¼‰
    BoundedVec<u64, ConstU32<100>>,      // appeal_id åˆ—è¡¨
    ValueQuery,
>;

// 2. æŒ‰ç›®æ ‡å¯¹è±¡ + çŠ¶æ€å¤åˆç´¢å¼•
#[pallet::storage]
pub type AppealsByTargetAndStatus<T: Config> = StorageDoubleMap<
    _,
    Blake2_128Concat, (u8, u64),         // (domain, target)
    Blake2_128Concat, u8,                 // status
    BoundedVec<u64, ConstU32<100>>,      // appeal_id åˆ—è¡¨
    ValueQuery,
>;

// 3. æ—¶é—´èŒƒå›´ç´¢å¼•ï¼ˆç”¨äºç»Ÿè®¡ï¼‰
#[pallet::storage]
pub type AppealsByTimeRange<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    BlockNumberFor<T>,                    // å¼€å§‹åŒºå—ï¼ˆå‘ä¸‹å–æ•´åˆ°1000çš„å€æ•°ï¼‰
    BoundedVec<u64, ConstU32<1000>>,     // appeal_id åˆ—è¡¨
    ValueQuery,
>;

// æŸ¥è¯¢æ¥å£ä¼˜åŒ–
pub fn get_user_appeals_paginated(
    who: &T::AccountId,
    page: u64,
    status_filter: Option<u8>,
) -> Vec<u64> {
    let mut ids = AppealsByUserPaginated::<T>::get(who, page).to_vec();
    
    if let Some(status) = status_filter {
        ids.retain(|id| {
            Appeals::<T>::get(id).map(|a| a.status == status).unwrap_or(false)
        });
    }
    
    ids
}
```

**æ€§èƒ½æå‡**:
- âš¡ æŸ¥è¯¢é€Ÿåº¦: 100x+ æå‡
- ğŸ“Š æ”¯æŒå¤æ‚æŸ¥è¯¢ï¼ˆç”¨æˆ·+çŠ¶æ€+æ—¶é—´ï¼‰
- ğŸ” å‰ç«¯åˆ†é¡µåŠ è½½ï¼ˆå‡å°‘RPCè´Ÿè½½ï¼‰

---

#### æ–¹æ¡ˆ9: å­˜å‚¨æ¸…ç†è‡ªåŠ¨åŒ–

**é—®é¢˜**: `otc-order`, `simple-bridge` çš„æ¸…ç†é€»è¾‘ä¸å®Œå–„ï¼ˆH-2ï¼‰

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```rust
// âœ… å®Œå–„çš„è‡ªåŠ¨æ¸…ç†æ¡†æ¶

#[pallet::storage]
pub type ArchiveConfig<T: Config> = StorageValue<_, ArchiveSettings, ValueQuery>;

#[derive(Encode, Decode, Clone, PartialEq, Eq, TypeInfo, MaxEncodedLen)]
pub struct ArchiveSettings {
    pub enabled: bool,
    pub threshold_days: u32,
    pub max_per_block: u32,
    pub cleanup_interval_blocks: u32,  // ğŸ†• æ¸…ç†é—´éš”
    pub grace_period_days: u32,        // ğŸ†• å®½é™æœŸï¼ˆä» completed_at ç®—èµ·ï¼‰
}

// è®¢å•æ·»åŠ  completed_at å­—æ®µ
pub struct Order<AccountId, Balance, Moment> {
    // ... ç°æœ‰å­—æ®µ
    pub created_at: Moment,
    pub completed_at: Option<Moment>,  // ğŸ†• å®Œæˆæ—¶é—´
}

// æ”¹è¿›çš„æ¸…ç†é€»è¾‘
fn on_finalize(n: BlockNumberFor<T>) -> Weight {
    let config = ArchiveConfig::<T>::get();
    
    if !config.enabled {
        return Weight::zero();
    }
    
    // æ£€æŸ¥æ¸…ç†é—´éš”
    let last_cleanup = LastCleanupBlock::<T>::get();
    if n.saturating_sub(last_cleanup) < config.cleanup_interval_blocks.into() {
        return Weight::zero();
    }
    
    let now = <pallet_timestamp::Pallet<T>>::get();
    let threshold_ms = config.threshold_days as u64 * 24 * 3600 * 1000;
    let grace_ms = config.grace_period_days as u64 * 24 * 3600 * 1000;
    
    let mut cleaned = 0u32;
    let cursor = SwapCleanupCursor::<T>::get();
    
    for (swap_id, swap) in Swaps::<T>::iter_from(cursor) {
        if cleaned >= config.max_per_block {
            SwapCleanupCursor::<T>::put(swap_id);
            break;
        }
        
        // âœ… åŸºäº completed_at è€Œé created_at
        if let Some(completed_at) = swap.completed_at {
            let age_ms = now.saturating_sub(completed_at);
            
            // ç»ˆæ€ + è¶…è¿‡é˜ˆå€¼ + è¶…è¿‡å®½é™æœŸ
            if swap.completed && age_ms > threshold_ms + grace_ms {
                Swaps::<T>::remove(swap_id);
                cleaned = cleaned.saturating_add(1);
                Self::deposit_event(Event::SwapArchived { swap_id, age_days: age_ms / (24 * 3600 * 1000) });
            }
        }
    }
    
    LastCleanupBlock::<T>::put(n);
    Weight::from_parts(50_000u64.saturating_mul(cleaned as u64), 0)
}

// æ²»ç†æ¥å£
#[pallet::call]
impl<T: Config> Pallet<T> {
    /// æ›´æ–°å½’æ¡£é…ç½®
    pub fn set_archive_config(
        origin: OriginFor<T>,
        enabled: bool,
        threshold_days: u32,
        grace_period_days: u32,
    ) -> DispatchResult {
        T::GovernanceOrigin::ensure_origin(origin)?;
        
        ArchiveConfig::<T>::put(ArchiveSettings {
            enabled,
            threshold_days,
            max_per_block: 50,
            cleanup_interval_blocks: 100,
            grace_period_days,
        });
        
        Ok(())
    }
}
```

**ä¼˜åŠ¿**:
- âœ… åŸºäº `completed_at` æ¸…ç†ï¼Œä¸è¯¯åˆ æ´»è·ƒè®¢å•
- âœ… å®½é™æœŸæœºåˆ¶ï¼Œä¿æŠ¤æœ€è¿‘å®Œæˆè®¢å•
- âœ… æ²»ç†å¯é…ç½®ï¼Œçµæ´»è°ƒæ•´
- âœ… äº‹ä»¶è®°å½•ï¼Œä¾¿äºå®¡è®¡

---

## ğŸ” ä¸‰ã€å®‰å…¨å¢å¼ºæ–¹æ¡ˆ

### 3.1 CID åŠ å¯†éªŒè¯

#### æ–¹æ¡ˆ10: å¼ºåˆ¶ç§å¯†å†…å®¹ CID åŠ å¯†

**é—®é¢˜**: `evidence`, `market-maker` çš„ç§å¯† CID æœªéªŒè¯æ˜¯å¦åŠ å¯†

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```rust
// âœ… CID åŠ å¯†éªŒè¯æ¡†æ¶

/// CID ç±»å‹æšä¸¾
pub enum CidType {
    Public,     // å…¬å¼€å†…å®¹ï¼Œä¸åŠ å¯†
    Private,    // ç§å¯†å†…å®¹ï¼Œå¿…é¡»åŠ å¯†
    Evidence,   // è¯æ®ï¼Œå»ºè®®åŠ å¯†
}

/// CID éªŒè¯ trait
pub trait CidValidator {
    /// éªŒè¯ CID æ˜¯å¦ç¬¦åˆç±»å‹è¦æ±‚
    fn validate(cid: &[u8], cid_type: CidType) -> Result<(), CidError>;
    
    /// æ£€æŸ¥ CID æ˜¯å¦å·²åŠ å¯†
    fn is_encrypted(cid: &[u8]) -> bool;
}

pub struct DefaultCidValidator;

impl CidValidator for DefaultCidValidator {
    fn validate(cid: &[u8], cid_type: CidType) -> Result<(), CidError> {
        match cid_type {
            CidType::Public => {
                // å…¬å¼€å†…å®¹ï¼Œä»»æ„ CID
                Ok(())
            }
            CidType::Private => {
                // ç§å¯†å†…å®¹ï¼Œå¿…é¡»åŠ å¯†
                ensure!(Self::is_encrypted(cid), CidError::NotEncrypted);
                Ok(())
            }
            CidType::Evidence => {
                // è¯æ®ï¼Œå»ºè®®åŠ å¯†ä½†ä¸å¼ºåˆ¶
                if !Self::is_encrypted(cid) {
                    log::warn!("Evidence CID not encrypted: {:?}", cid);
                }
                Ok(())
            }
        }
    }
    
    fn is_encrypted(cid: &[u8]) -> bool {
        // æ£€æŸ¥åŠ å¯†å‰ç¼€
        cid.starts_with(b"enc-") ||         // è‡ªå®šä¹‰åŠ å¯†å‰ç¼€
        cid.starts_with(b"sealed-") ||      // Lit Protocol
        cid.starts_with(b"priv-")           // å…¶ä»–åŠ å¯†æ–¹æ¡ˆ
    }
}

// ä½¿ç”¨ç¤ºä¾‹
impl<T: Config> Pallet<T> {
    pub fn submit_private_evidence(
        origin: OriginFor<T>,
        encrypted_cid: BoundedVec<u8, ConstU32<256>>,
    ) -> DispatchResult {
        let who = ensure_signed(origin)?;
        
        // âœ… éªŒè¯ CID å·²åŠ å¯†
        T::CidValidator::validate(&encrypted_cid, CidType::Private)
            .map_err(|_| Error::<T>::CidNotEncrypted)?;
        
        // å­˜å‚¨
        PrivateEvidence::<T>::insert(&who, encrypted_cid);
        
        Ok(())
    }
}
```

**å‰ç«¯é…å¥—**:
```typescript
// âœ… å‰ç«¯è‡ªåŠ¨åŠ å¯† CID

import { encryptWithLit } from '@lit-protocol/sdk';

async function uploadPrivateContent(content: string) {
  // 1. ä¸Šä¼ åˆ° IPFS
  const plainCid = await ipfs.add(content);
  
  // 2. ä½¿ç”¨ Lit Protocol åŠ å¯† CID
  const encryptedCid = await encryptWithLit(
    plainCid,
    accessControlConditions, // è®¿é—®æ§åˆ¶æ¡ä»¶
    chain: 'substrate',
  );
  
  // 3. æ·»åŠ å‰ç¼€æ ‡è¯†
  return `enc-${encryptedCid}`;
}
```

**ä¼˜åŠ¿**:
- âœ… å¼ºåˆ¶åŠ å¯†ï¼Œä¿æŠ¤éšç§
- âœ… å‰ç¼€æ ‡è¯†ï¼Œä¾¿äºè¯†åˆ«
- âœ… å…¼å®¹å¤šç§åŠ å¯†æ–¹æ¡ˆ

---

### 3.2 å¢å¼ºé‡æ”¾ä¿æŠ¤

#### æ–¹æ¡ˆ11: TRON äº¤æ˜“å“ˆå¸Œæ°¸ä¹…å­˜å‚¨ï¼ˆH-3 ä¿®å¤ï¼‰

**é—®é¢˜**: `simple-bridge` çš„äº¤æ˜“å“ˆå¸Œ180å¤©åæ¸…ç†ï¼Œå­˜åœ¨é‡æ”¾é£é™©

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```rust
// âœ… æ–¹æ¡ˆA: æ°¸ä¹…å­˜å‚¨ï¼ˆæ¨èï¼‰

// ç§»é™¤ä¿ç•™æœŸé…ç½®
// type TronTxHashRetentionPeriod: Get<BlockNumberFor<Self>>;

// æ°¸ä¹…å­˜å‚¨äº¤æ˜“å“ˆå¸Œ
#[pallet::storage]
pub type UsedTronTxHashes<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    BoundedVec<u8, ConstU32<128>>,  // tron_tx_hash
    u64,                             // order_idï¼ˆä»…å­˜ IDï¼ŒèŠ‚çœç©ºé—´ï¼‰
    OptionQuery,
>;

// âœ… æ–¹æ¡ˆB: å¸ƒéš†è¿‡æ»¤å™¨ï¼ˆé«˜çº§ä¼˜åŒ–ï¼‰

use sp_std::vec::Vec;

#[pallet::storage]
pub type TronTxBloomFilter<T: Config> = StorageValue<
    _,
    BoundedVec<u8, ConstU32<1024>>,  // å¸ƒéš†è¿‡æ»¤å™¨ï¼ˆ1KBï¼‰
    ValueQuery,
>;

impl<T: Config> Pallet<T> {
    /// æ£€æŸ¥äº¤æ˜“å“ˆå¸Œæ˜¯å¦å·²ä½¿ç”¨ï¼ˆå¸ƒéš†è¿‡æ»¤å™¨ï¼‰
    fn is_tx_hash_used(tx_hash: &[u8]) -> bool {
        let filter = TronTxBloomFilter::<T>::get();
        bloom_check(&filter, tx_hash)
    }
    
    /// æ ‡è®°äº¤æ˜“å“ˆå¸Œä¸ºå·²ä½¿ç”¨
    fn mark_tx_hash_used(tx_hash: &[u8]) {
        TronTxBloomFilter::<T>::mutate(|filter| {
            bloom_insert(filter, tx_hash);
        });
        
        // åŒæ—¶å­˜å‚¨åˆ° Mapï¼ˆåŒé‡ä¿æŠ¤ï¼‰
        UsedTronTxHashes::<T>::insert(
            BoundedVec::try_from(tx_hash.to_vec()).unwrap(),
            Self::next_swap_id(),
        );
    }
}

// å¸ƒéš†è¿‡æ»¤å™¨å®ç°ï¼ˆç®€åŒ–ç‰ˆï¼‰
fn bloom_insert(filter: &mut Vec<u8>, item: &[u8]) {
    let hash1 = sp_io::hashing::twox_128(item);
    let hash2 = sp_io::hashing::blake2_128(item);
    
    for i in 0..3 {
        let idx = ((hash1[i] as usize) << 8 | hash2[i] as usize) % (filter.len() * 8);
        filter[idx / 8] |= 1 << (idx % 8);
    }
}

fn bloom_check(filter: &[u8], item: &[u8]) -> bool {
    let hash1 = sp_io::hashing::twox_128(item);
    let hash2 = sp_io::hashing::blake2_128(item);
    
    for i in 0..3 {
        let idx = ((hash1[i] as usize) << 8 | hash2[i] as usize) % (filter.len() * 8);
        if (filter[idx / 8] & (1 << (idx % 8))) == 0 {
            return false;
        }
    }
    true
}
```

**æ–¹æ¡ˆå¯¹æ¯”**:

| æ–¹æ¡ˆ | å­˜å‚¨æˆæœ¬ | æŸ¥è¯¢é€Ÿåº¦ | å‡†ç¡®ç‡ | æ¨èåº¦ |
|------|---------|---------|--------|--------|
| æ°¸ä¹… Map | é«˜ï¼ˆ32B/txï¼‰ | å¿« O(1) | 100% | â­â­â­â­â­ |
| å¸ƒéš†è¿‡æ»¤å™¨ | æä½ï¼ˆ1KBï¼‰ | æå¿« O(1) | 99.9%+ | â­â­â­â­ |
| Map + å¸ƒéš† | ä¸­ | æå¿« | 100% | â­â­â­â­â­ |

**å»ºè®®**: ä½¿ç”¨ **Map + å¸ƒéš†è¿‡æ»¤å™¨** ç»„åˆæ–¹æ¡ˆï¼Œæ—¢ä¿è¯å‡†ç¡®æ€§åˆèŠ‚çœå­˜å‚¨ã€‚

---

## ğŸ’¡ å››ã€ç”¨æˆ·ä½“éªŒä¼˜åŒ–æ–¹æ¡ˆ

### 4.1 Gas è´¹ç”¨ä¼˜åŒ–

#### æ–¹æ¡ˆ12: å…ƒäº¤æ˜“ï¼ˆMeta Transactionsï¼‰

**ç›®æ ‡**: ç”¨æˆ·æ— éœ€æŒæœ‰MEMOå³å¯ä½¿ç”¨æœåŠ¡

**æŠ€æœ¯æ–¹æ¡ˆ**:
```rust
// âœ… é›†æˆ pallet-asset-tx-payment

// 1. é…ç½®è¿è¡Œæ—¶
impl pallet_asset_tx_payment::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type Fungibles = Assets;
    type OnChargeAssetTransaction = AssetConversionAdapter<
        Balances,
        AssetConversion,
        Native,
    >;
}

// 2. æ”¯æŒç”¨ USDT æ”¯ä»˜ Gas è´¹
// ç”¨æˆ·æŒæœ‰ USDTï¼Œè‡ªåŠ¨è½¬æ¢ä¸º DUST æ”¯ä»˜ Gas

// 3. å‰ç«¯ç¤ºä¾‹
const tx = api.tx.memoOfferings.purchaseOffering(offeringId, durationWeeks);

// ç”¨æˆ·ç”¨ USDT æ”¯ä»˜ Gas
await tx.signAndSend(account, {
  assetId: USDT_ASSET_ID,  // ä½¿ç”¨ USDT æ”¯ä»˜
});
```

**ä¼˜åŠ¿**:
- âœ… é™ä½ç”¨æˆ·è¿›å…¥é—¨æ§›
- âœ… æ— éœ€è´­ä¹° DUST å³å¯ä½¿ç”¨
- âœ… æå‡ç”¨æˆ·ä½“éªŒ

---

#### æ–¹æ¡ˆ13: Gas è´¹ç”¨è¡¥è´´ï¼ˆé¦–è´­ä¼˜åŒ–ï¼‰

**ç°çŠ¶é—®é¢˜**: é¦–è´­ç”¨æˆ·éœ€è¦å…ˆè´­ä¹°MEMOæ‰èƒ½æ”¯ä»˜Gas

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```rust
// âœ… Gas è¡¥è´´æ± 

#[pallet::storage]
pub type GasSubsidyPool<T: Config> = StorageValue<_, BalanceOf<T>, ValueQuery>;

#[pallet::storage]
pub type SubsidizedUsers<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::AccountId,
    u32,  // å·²è¡¥è´´æ¬¡æ•°
    ValueQuery,
>;

impl<T: Config> Pallet<T> {
    /// é¦–è´­è‡ªåŠ¨è¡¥è´´ Gas
    pub fn first_purchase_with_subsidy(
        origin: OriginFor<T>,
        amount: BalanceOf<T>,
        referrer: Option<T::AccountId>,
    ) -> DispatchResultWithPostInfo {
        let who = ensure_signed(origin)?;
        
        // æ£€æŸ¥æ˜¯å¦é¦–è´­
        ensure!(
            !FirstPurchaseRecords::<T>::contains_key(&who),
            Error::<T>::NotFirstPurchase
        );
        
        // æ‰§è¡Œé¦–è´­
        Self::do_first_purchase(&who, amount, referrer)?;
        
        // ğŸ†• Gas è¡¥è´´ï¼ˆå‡å… 80% Gasï¼‰
        let subsidy_ratio = Perbill::from_percent(80);
        
        Ok(Some(actual_weight.mul(1 - subsidy_ratio)).into())
    }
}

// è¿è¥è€…å®šæœŸå……å€¼è¡¥è´´æ± 
pub fn refill_subsidy_pool(
    origin: OriginFor<T>,
    amount: BalanceOf<T>,
) -> DispatchResult {
    T::AdminOrigin::ensure_origin(origin)?;
    
    let pool = GasSubsidyPool::<T>::get();
    GasSubsidyPool::<T>::put(pool.saturating_add(amount));
    
    Ok(())
}
```

**ä¼˜åŠ¿**:
- âœ… é¦–è´­ç”¨æˆ· Gas å‡å… 80%
- âœ… é™ä½å…¥åœºé—¨æ§›
- âœ… æå‡è½¬åŒ–ç‡

---

### 4.2 å‰ç«¯ä¼˜åŒ–æ–¹æ¡ˆ

#### æ–¹æ¡ˆ14: é“¾ä¸‹ç´¢å¼•ï¼ˆSubsquid é›†æˆï¼‰

**é—®é¢˜**: å‰ç«¯ç›´æ¥æŸ¥è¯¢é“¾ä¸Šæ•°æ®ï¼Œé€Ÿåº¦æ…¢

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```typescript
// âœ… ä½¿ç”¨ Subsquid æ„å»ºé«˜æ€§èƒ½ç´¢å¼•

// 1. Subsquid Processorï¼ˆé“¾ä¸‹ç´¢å¼•æœåŠ¡ï¼‰
import { SubstrateBatchProcessor } from '@subsquid/substrate-processor';

const processor = new SubstrateBatchProcessor()
  .setDataSource({
    archive: 'https://stardust.archive.subsquid.io',
    chain: 'wss://rpc.stardust.network',
  })
  .addEvent('MemoAppeals.AppealSubmitted', {
    data: {
      event: { args: true },
    },
  } as const)
  .addEvent('MemoAppeals.AppealApproved', {
    data: {
      event: { args: true },
    },
  } as const);

processor.run(new TypeormDatabase(), async (ctx) => {
  for (const block of ctx.blocks) {
    for (const event of block.events) {
      if (event.name === 'MemoAppeals.AppealSubmitted') {
        // è§£æäº‹ä»¶
        const { appealId, who, domain, target } = event.args;
        
        // å­˜å…¥ PostgreSQL
        await ctx.store.save(new Appeal({
          id: appealId,
          user: who,
          domain,
          target,
          status: 'Pending',
          createdAt: new Date(block.timestamp),
        }));
      }
    }
  }
});

// 2. å‰ç«¯æŸ¥è¯¢ GraphQL APIï¼ˆæ¯” RPC å¿« 100x+ï¼‰
const { data } = await gql`
  query GetUserAppeals($user: String!, $status: String) {
    appeals(
      where: { user: $user, status: $status }
      orderBy: createdAt_DESC
      limit: 20
    ) {
      id
      domain
      target
      status
      createdAt
    }
  }
`;
```

**æ€§èƒ½å¯¹æ¯”**:

| æŸ¥è¯¢æ–¹å¼ | é€Ÿåº¦ | å¤æ‚æŸ¥è¯¢ | æ’åº/åˆ†é¡µ | æ¨èåº¦ |
|---------|------|---------|----------|--------|
| ç›´æ¥ RPC | æ…¢ï¼ˆ5-10sï¼‰ | âŒ ä¸æ”¯æŒ | âŒ å›°éš¾ | â­â­ |
| Subsquid | æå¿«ï¼ˆ50-200msï¼‰ | âœ… æ”¯æŒ | âœ… åŸç”Ÿæ”¯æŒ | â­â­â­â­â­ |

**ä¼˜åŠ¿**:
- âš¡ æŸ¥è¯¢é€Ÿåº¦æå‡ 100x+
- ğŸ“Š æ”¯æŒå¤æ‚æŸ¥è¯¢ï¼ˆJOINã€èšåˆï¼‰
- ğŸ” å…¨æ–‡æœç´¢
- ğŸ“ˆ å®æ—¶ç»Ÿè®¡

---

#### æ–¹æ¡ˆ15: é”™è¯¯ä¿¡æ¯å¢å¼º

**é—®é¢˜**: é”™è¯¯æç¤ºè¿‡äºç®€å•ï¼ˆL-6ï¼‰

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```rust
// âœ… è¯¦ç»†é”™è¯¯ä¿¡æ¯

pub enum Error<T> {
    // âŒ æ—§ç‰ˆæœ¬ï¼ˆæ¨¡ç³Šï¼‰
    // Insufficient,
    // NoLock,
    
    // âœ… æ–°ç‰ˆæœ¬ï¼ˆè¯¦ç»†ï¼‰
    InsufficientBalance,
    InsufficientEscrowBalance,
    InsufficientDeposit,
    InsufficientFirstPurchasePoolBalance,
    
    EscrowLockNotFound,
    EscrowAlreadyLocked,
    EscrowInDisputedState,
    
    DepositRecordNotFound,
    DepositAlreadyReleased,
    DepositAlreadySlashed,
    
    OrderNotFound,
    OrderAlreadyCompleted,
    OrderAlreadyCanceled,
    OrderInDisputedState,
    
    // ğŸ†• åŒ…å«ä¸Šä¸‹æ–‡çš„é”™è¯¯
    PriceDeviationTooLarge { 
        expected: u64, 
        actual: u64, 
        max_deviation_bps: u16,
    },
    
    RateLimitExceeded {
        window_blocks: u32,
        max_in_window: u32,
        current_count: u32,
    },
}

// å‰ç«¯å‹å¥½çš„é”™è¯¯ä¿¡æ¯
impl<T> From<Error<T>> for &'static str {
    fn from(error: Error<T>) -> Self {
        match error {
            Error::InsufficientBalance => "ä½™é¢ä¸è¶³ï¼Œè¯·å……å€¼åé‡è¯•",
            Error::InsufficientEscrowBalance => "æ‰˜ç®¡ä½™é¢ä¸è¶³",
            Error::RateLimitExceeded { .. } => "æ“ä½œè¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•",
            Error::PriceDeviationTooLarge { .. } => "ä»·æ ¼åç¦»è¿‡å¤§ï¼Œè¯·æ£€æŸ¥å¸‚åœºä»·æ ¼",
            // ...
        }
    }
}
```

**å‰ç«¯ç¤ºä¾‹**:
```typescript
try {
  await api.tx.otcOrder.openOrder(...).signAndSend(account);
} catch (error) {
  if (error.isModule) {
    const decoded = api.registry.findMetaError(error.asModule);
    
    // âœ… æ˜¾ç¤ºè¯¦ç»†é”™è¯¯
    if (decoded.name === 'RateLimitExceeded') {
      toast.error(
        'æ“ä½œè¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•',
        `æ‚¨åœ¨${decoded.docs.window_blocks}ä¸ªåŒºå—å†…æœ€å¤šå¯æ“ä½œ${decoded.docs.max_in_window}æ¬¡`
      );
    }
  }
}
```

---

## ğŸ¯ äº”ã€å®æ–½è·¯çº¿å›¾

### Phase 1: é«˜ä¼˜å…ˆçº§ä¿®å¤ï¼ˆ2-3å‘¨ï¼‰

**ç›®æ ‡**: ä¿®å¤3ä¸ªé«˜å±é—®é¢˜ï¼Œç¡®ä¿ä¸»ç½‘å¯ä¸Šçº¿

| ä»»åŠ¡ | å·¥ä½œé‡ | è´Ÿè´£äºº | å®Œæˆæ ‡å‡† |
|------|--------|--------|----------|
| H-1: ä¼˜åŒ– escrow on_initialize | 3å¤© | é“¾ç«¯ | Gas æ¶ˆè€—é™ä½ 95%+ |
| H-2: ä¿®å¤ otc-order æ¸…ç†é€»è¾‘ | 2å¤© | é“¾ç«¯ | åŸºäº completed_at æ¸…ç† |
| H-3: å¢å¼º TRON é‡æ”¾ä¿æŠ¤ | 3å¤© | é“¾ç«¯ | æ°¸ä¹…å­˜å‚¨æˆ–å¸ƒéš†è¿‡æ»¤å™¨ |
| é›†æˆæµ‹è¯• | 5å¤© | å…¨æ ˆ | æ‰€æœ‰åœºæ™¯é€šè¿‡ |
| æ–‡æ¡£æ›´æ–° | 2å¤© | æ–‡æ¡£ | æ›´æ–° README |

---

### Phase 2: å®˜æ–¹Palletè¿ç§»ï¼ˆ4-6å‘¨ï¼‰

**ç›®æ ‡**: ç”¨å®˜æ–¹palletæ›¿ä»£è‡ªç ”ï¼Œé™ä½ç»´æŠ¤æˆæœ¬

| ä»»åŠ¡ | å·¥ä½œé‡ | æ”¶ç›Š | é£é™© |
|------|--------|------|------|
| è¿ç§»åˆ° pallet-balances Holds API | 5å¤© | å‡å°‘500è¡Œä»£ç  | ä½ |
| é›†æˆ pallet-xcm | 2-3å‘¨ | è·¨é“¾åŠŸèƒ½ | ä¸­ |
| ä½¿ç”¨ ORML Oracle | 1å‘¨ | æ›´å¯é çš„ä»·æ ¼æº | ä½ |
| Chat è¿ç§»åˆ°é“¾ä¸‹ | 2-3å‘¨ | å­˜å‚¨æˆæœ¬é™ä½99% | ä¸­ |

---

### Phase 3: æ€§èƒ½ä¸å®‰å…¨ä¼˜åŒ–ï¼ˆ6-8å‘¨ï¼‰

**ç›®æ ‡**: æå‡ç³»ç»Ÿæ€§èƒ½å’Œå®‰å…¨æ€§

| ä»»åŠ¡ | å·¥ä½œé‡ | æ”¶ç›Š |
|------|--------|------|
| äºŒçº§ç´¢å¼•ä¼˜åŒ– | 2å‘¨ | æŸ¥è¯¢é€Ÿåº¦ 100x+ |
| æ‰¹é‡æ“ä½œæ¥å£ | 1å‘¨ | Gas èŠ‚çœ 60%+ |
| CID åŠ å¯†éªŒè¯ | 1å‘¨ | éšç§ä¿æŠ¤å¢å¼º |
| å…ƒäº¤æ˜“æ”¯æŒ | 2å‘¨ | é™ä½ç”¨æˆ·é—¨æ§› |
| Subsquid é›†æˆ | 3å‘¨ | å‰ç«¯æ€§èƒ½ 100x+ |

---

### Phase 4: ç”Ÿæ€é›†æˆï¼ˆ8-12å‘¨ï¼‰

**ç›®æ ‡**: é›†æˆ Polkadot ç”Ÿæ€ï¼Œæ‰©å¤§ç”¨æˆ·ç¾¤

| ä»»åŠ¡ | å·¥ä½œé‡ | æ”¶ç›Š |
|------|--------|------|
| XCM è·¨é“¾è½¬è´¦ | 3-4å‘¨ | è¿æ¥ Polkadot ç”Ÿæ€ |
| Asset Hub é›†æˆ | 2-3å‘¨ | å¤šèµ„äº§æ”¯æŒ |
| NFT åŒ–ä¾›å¥‰å“ | 3-4å‘¨ | å¯äº¤æ˜“ã€å¯æ”¶è— |
| è·¨é“¾ä¾›å¥‰å“å¸‚åœº | 4-6å‘¨ | åˆ›æ–°åŠŸèƒ½ |

---

## ğŸ“Š å…­ã€æˆæœ¬æ•ˆç›Šåˆ†æ

### 6.1 å¼€å‘æˆæœ¬ä¼°ç®—

| Phase | å·¥ä½œé‡ | äººåŠ›æˆæœ¬ | æ—¶é—´ |
|-------|--------|---------|------|
| Phase 1 | 15å¤© | 1äººå…¨èŒ | 3å‘¨ |
| Phase 2 | 30-40å¤© | 2äººå…¨èŒ | 6å‘¨ |
| Phase 3 | 40-50å¤© | 2äººå…¨èŒ | 8å‘¨ |
| Phase 4 | 60-80å¤© | 2-3äººå…¨èŒ | 12å‘¨ |
| **æ€»è®¡** | **145-185å¤©** | **2-3äºº** | **29å‘¨ï¼ˆ7ä¸ªæœˆï¼‰** |

---

### 6.2 æ”¶ç›Šåˆ†æ

| ä¼˜åŒ–é¡¹ | é‡åŒ–æ”¶ç›Š | è¯´æ˜ |
|--------|---------|------|
| **Gas ä¼˜åŒ–** | -60% | æ‰¹é‡æ“ä½œã€ç´¢å¼•ä¼˜åŒ– |
| **å­˜å‚¨æˆæœ¬** | -99% | Chatè¿ç§»é“¾ä¸‹ |
| **æŸ¥è¯¢é€Ÿåº¦** | +100x | Subsquidç´¢å¼• |
| **ç»´æŠ¤æˆæœ¬** | -30% | ä½¿ç”¨å®˜æ–¹pallet |
| **ç”¨æˆ·å¢é•¿** | +50% | é™ä½é—¨æ§›ã€è·¨é“¾é›†æˆ |
| **å¼€å‘æ•ˆç‡** | +40% | å‡å°‘å†—ä½™ä»£ç  |

**å¹´åº¦èŠ‚çœæˆæœ¬** (ä¿å®ˆä¼°è®¡):
- å­˜å‚¨æˆæœ¬: $10,000/å¹´ â†’ $100/å¹´
- ç»´æŠ¤æˆæœ¬: 1äººå¹´ â†’ 0.7äººå¹´
- RPCæœåŠ¡å™¨æˆæœ¬: $5,000/å¹´ â†’ $500/å¹´
- **æ€»èŠ‚çœ**: ~$15,000/å¹´

**å¹´åº¦å¢é•¿æ”¶ç›Š** (ä¿å®ˆä¼°è®¡):
- ç”¨æˆ·å¢é•¿ 50% â†’ äº¤æ˜“é‡å¢é•¿ 50%
- è·¨é“¾ç”¨æˆ·è´¡çŒ®é¢å¤– 20% äº¤æ˜“é‡
- **æ€»å¢é•¿**: ~70% äº¤æ˜“é‡

---

## âœ… ä¸ƒã€æ€»ç»“ä¸å»ºè®®

### 7.1 ç«‹å³æ‰§è¡Œï¼ˆ1ä¸ªæœˆå†…ï¼‰

1. âœ… **ä¿®å¤3ä¸ªé«˜å±é—®é¢˜**ï¼ˆH-1, H-2, H-3ï¼‰
   - ä¼˜å…ˆçº§: ğŸ”´ æœ€é«˜
   - å·¥ä½œé‡: 2å‘¨
   - é£é™©: ä½
   
2. âœ… **CID åŠ å¯†éªŒè¯**
   - ä¼˜å…ˆçº§: ğŸŸ  é«˜
   - å·¥ä½œé‡: 1å‘¨
   - é£é™©: ä½

3. âœ… **é”™è¯¯ä¿¡æ¯ä¼˜åŒ–**
   - ä¼˜å…ˆçº§: ğŸŸ¡ ä¸­
   - å·¥ä½œé‡: 3å¤©
   - é£é™©: æ— 

---

### 7.2 çŸ­æœŸç›®æ ‡ï¼ˆ3ä¸ªæœˆå†…ï¼‰

1. âœ… **è¿ç§»åˆ°å®˜æ–¹Pallet**
   - `pallet-deposits` â†’ `pallet-balances` Holds
   - `pallet-chat` â†’ Off-chain messaging
   
2. âœ… **é›†æˆSubsquidç´¢å¼•**
   - æå‡å‰ç«¯æŸ¥è¯¢é€Ÿåº¦ 100x+
   
3. âœ… **æ‰¹é‡æ“ä½œæ¥å£**
   - é™ä½ Gas æˆæœ¬ 60%+

---

### 7.3 ä¸­æœŸç›®æ ‡ï¼ˆ6ä¸ªæœˆå†…ï¼‰

1. âœ… **XCM è·¨é“¾é›†æˆ**
   - è¿æ¥ Polkadot ç”Ÿæ€
   - æ‰©å¤§ç”¨æˆ·ç¾¤
   
2. âœ… **å…ƒäº¤æ˜“æ”¯æŒ**
   - é™ä½ç”¨æˆ·é—¨æ§›
   
3. âœ… **ORML é›†æˆ**
   - å¤šå¸ç§ã€é¢„è¨€æœºã€NFT

---

### 7.4 é•¿æœŸæ„¿æ™¯ï¼ˆ12ä¸ªæœˆå†…ï¼‰

1. âœ… **è·¨é“¾ä¾›å¥‰å“å¸‚åœº**
   - Polkadot ç”Ÿæ€é¦–ä¸ªè·¨é“¾ä¾›å¥‰å“å¹³å°
   
2. âœ… **NFT åŒ–ä¾›å¥‰å“**
   - å¯äº¤æ˜“ã€å¯æ”¶è—ã€å¯ç»§æ‰¿
   
3. âœ… **DAO æ²»ç†**
   - ç¤¾åŒºé©±åŠ¨çš„å¹³å°æ²»ç†

---

## ğŸ¯ æœ€ç»ˆå»ºè®®

### æœ€ä¼˜æ–¹æ¡ˆç»„åˆï¼ˆæ€§ä»·æ¯”æœ€é«˜ï¼‰

**Phase 1ï¼ˆå¿…é¡»ï¼‰**:
- âœ… ä¿®å¤ H-1, H-2, H-3ï¼ˆ2å‘¨ï¼‰
- âœ… CID åŠ å¯†éªŒè¯ï¼ˆ1å‘¨ï¼‰
- âœ… é”™è¯¯ä¿¡æ¯ä¼˜åŒ–ï¼ˆ3å¤©ï¼‰

**Phase 2ï¼ˆå¼ºçƒˆæ¨èï¼‰**:
- âœ… è¿ç§»åˆ° pallet-balances Holdsï¼ˆ1å‘¨ï¼‰
- âœ… Chat è¿ç§»é“¾ä¸‹ï¼ˆ2-3å‘¨ï¼‰
- âœ… é›†æˆ Subsquidï¼ˆ3å‘¨ï¼‰

**Phase 3ï¼ˆæ¨èï¼‰**:
- âœ… XCM è·¨é“¾é›†æˆï¼ˆ4-6å‘¨ï¼‰
- âœ… æ‰¹é‡æ“ä½œæ¥å£ï¼ˆ1å‘¨ï¼‰
- âœ… å…ƒäº¤æ˜“æ”¯æŒï¼ˆ2å‘¨ï¼‰

**æ€»æ—¶é—´**: çº¦ 3-4 ä¸ªæœˆ  
**æ€»æŠ•å…¥**: 2-3 äººå…¨èŒ  
**é¢„æœŸæ”¶ç›Š**: Gas é™ä½ 60%ï¼ŒæŸ¥è¯¢é€Ÿåº¦æå‡ 100xï¼Œç”¨æˆ·å¢é•¿ 50%+

---

**æœ¬æ–¹æ¡ˆç»“åˆäº†æ€§èƒ½ã€å®‰å…¨ã€æˆæœ¬ã€ç”¨æˆ·ä½“éªŒç­‰å¤šä¸ªç»´åº¦ï¼Œæ˜¯å½“å‰æœ€ä¼˜çš„å‡çº§è·¯å¾„ã€‚** ğŸš€

