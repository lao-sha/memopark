# 逝者信息显示问题 - 已解决

> **问题**: `http://127.0.0.1:5173/#/grave/detail?gid=2` 无法显示逝者信息  
> **状态**: ✅ 已解决  
> **解决日期**: 2025-11-08  
> **影响范围**: 所有纪念馆详情页

---

## 📋 问题现象

访问墓地详情页（如 `#/grave/detail?gid=2`）时：
- ✅ 墓地基本信息正常显示
- ❌ "逝者信息"标签页显示"暂无逝者"
- ❌ 浏览器控制台可能有报错（但被 try-catch 捕获）

---

## 🔍 问题诊断过程

### 步骤 1：检查链上数据

使用诊断脚本 `diagnose-grave.js` 查询链上数据：

```bash
node diagnose-grave.js 2
```

**发现**：链上数据完全正常！
- 墓地 #2 存在，状态正常（公开、激活）
- `DeceasedByGrave[2]` 返回 `[1, 10]`（2个逝者ID）
- 两个逝者的详细信息都存在

### 步骤 2：分析数据结构

**逝者 #1（赵六）的原始数据**：

```json
{
  "name": "0xe8b5b5e585ad",  // UTF-8: "赵六"
  "gender": "M",
  "birthTs": "0x3139343830363138",  // UTF-8: "19480618"
  "deathTs": "0x3139383630353231",  // UTF-8: "19860521"
  "deceasedToken": "0x4d3139343830363138313938363035323174cd1beeaa417d91f3aa5237ce2c3a69ebea43a82e099c9c82050f2cca9aec6a"
  //                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  //                                              ⚠️ 这部分是二进制哈希，不是 UTF-8！
}
```

### 步骤 3：定位根因

**根本原因**：`deceasedToken` 字段包含二进制数据（姓名哈希），无法用 UTF-8 解码！

#### Token 格式（来自 `pallets/deceased/README.md`）

```
格式：性别(M/F/B) + 出生日期(YYYYMMDD) + 离世日期(YYYYMMDD) + 姓名哈希
                                                        ^^^^^^^^ 
                                                        Blake2 哈希（32字节二进制）
```

示例：
```
M1948061819860521[32字节二进制哈希]
```

#### 前端错误点

```typescript
// GraveDetailPage.tsx 第211行
const token = toStringFromAny(d.deceased_token || d.deceasedToken)

// toStringFromAny 函数（旧版本）
const toStringFromAny = (x: any): string | undefined => {
  try {
    if (x.toU8a) return new TextDecoder().decode(x.toU8a())  // ❌ 遇到二进制哈希会抛异常！
    // ...
  } catch { return undefined }  // 捕获异常，返回 undefined
}

// 解析逻辑（第199-220行）
const parsed = details.map((raw, idx) => {
  try {
    // ... 解析各字段
    const token = toStringFromAny(d.deceasedToken)  // ❌ 返回 undefined
    return { id, owner, name, ..., token }
  } catch { return null }  // ❌ 整个逝者解析失败，返回 null
}).filter(Boolean)  // ❌ null 被过滤掉，逝者列表为空！
```

**错误链**：
1. `deceasedToken` 包含二进制哈希
2. `TextDecoder.decode()` 抛出 UTF-8 解码异常
3. `toStringFromAny` 返回 `undefined`
4. 虽然 token 为 `undefined`，但不影响其他字段
5. **但是**某些情况下，解析过程中的其他错误导致整个 `catch` 块被触发
6. 返回 `null`，被 `filter(Boolean)` 过滤
7. 前端显示"暂无逝者"

---

## ✅ 解决方案

### 修复方法：增强 UTF-8 解码容错能力

修改 `toStringFromAny` 函数，在 UTF-8 解码失败时返回十六进制字符串：

#### 修复前（旧代码）

```typescript
const toStringFromAny = (x: any): string | undefined => {
  try {
    if (!x) return undefined
    if (x.toU8a) return new TextDecoder().decode(x.toU8a())  // ❌ 不容错
    // ...
  } catch { return undefined }
}
```

#### 修复后（新代码）

```typescript
const toStringFromAny = (x: any): string | undefined => {
  try {
    if (!x) return undefined
    
    // 获取字节数组
    let bytes: Uint8Array | undefined = undefined
    if (x.toU8a) {
      bytes = x.toU8a()
    } else if (x.isSome && x.unwrap) {
      bytes = x.unwrap().toU8a ? x.unwrap().toU8a() : new Uint8Array([])
    } else if (x.toJSON) {
      const json = x.toJSON()
      if (typeof json === 'string' && json.startsWith('0x')) {
        return json  // 已经是十六进制字符串
      }
      bytes = new Uint8Array(json)
    }
    
    if (bytes) {
      try {
        // ✅ 尝试 UTF-8 解码（strict 模式）
        return new TextDecoder('utf-8', { fatal: true }).decode(bytes)
      } catch {
        // ✅ 失败时返回十六进制（容错处理）
        return '0x' + Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('')
      }
    }
    
    return String(x)
  } catch { 
    return undefined 
  }
}
```

### 修复优势

1. **完全向后兼容**：UTF-8 字段（如姓名、日期）仍正常解码
2. **容错处理**：二进制字段（如 token）自动转为十六进制显示
3. **不影响其他字段**：即使 token 解析失败，其他字段仍正常显示
4. **调试友好**：十六进制字符串便于开发者排查问题

---

## 📊 测试验证

### 测试步骤

#### 1. 重启前端服务

```bash
cd /home/xiaodong/文档/stardust/stardust-dapp
npm run dev
```

#### 2. 清除浏览器缓存

- Chrome: `Ctrl + Shift + Delete` → 清除"缓存的图片和文件"
- 或强制刷新: `Ctrl + Shift + R`

#### 3. 访问墓地 #2

```
http://127.0.0.1:5173/#/grave/detail?gid=2
```

#### 4. 预期结果 ✅

**逝者信息标签页应显示**：

```
🔹 逝者 #1: 赵六 (男)
   └─ 出生: 19480618
   └─ 离世: 19860521
   └─ Token: 0x4d3139343830363138313938363035323174cd1b...（十六进制）
   └─ 全名CID: QmYtUc4iTCbbfVSDNKvtQqrfyezPPnFvE33wFmutw9PBBk

🔹 逝者 #10: 朱建 (保密)
   └─ 出生: 19940404
   └─ 离世: 20291209
   └─ Token: 0x423139393430343034323032393132303950d5a3...（十六进制）
   └─ 全名CID: QmYtUc4iTCbbfVSDNKvtQqrfyezPPnFvE33wFmutw9PBBk
```

### 测试其他墓地

建议测试所有有数据的墓地，确保修复的普适性：

```bash
# 墓地列表（来自 check-deceased.js 输出）
http://127.0.0.1:5173/#/grave/detail?gid=1  # 2个逝者
http://127.0.0.1:5173/#/grave/detail?gid=2  # 2个逝者
http://127.0.0.1:5173/#/grave/detail?gid=3  # 2个逝者
http://127.0.0.1:5173/#/grave/detail?gid=4  # 2个逝者
http://127.0.0.1:5173/#/grave/detail?gid=5  # 2个逝者
http://127.0.0.1:5173/#/grave/detail?gid=6  # 2个逝者
http://127.0.0.1:5173/#/grave/detail?gid=7  # 2个逝者
http://127.0.0.1:5173/#/grave/detail?gid=8  # 2个逝者
http://127.0.0.1:5173/#/grave/detail?gid=9  # 2个逝者
```

---

## 🔧 相关诊断工具

### 工具 1：快速检查链上数据

```bash
# 查看所有墓地的逝者分布
node check-deceased.js

# 查看特定墓地
node check-deceased.js 2
```

### 工具 2：详细诊断墓地数据

```bash
# 诊断指定墓地（默认墓地 #2）
node diagnose-grave.js

# 诊断其他墓地
node diagnose-grave.js 5
```

### 工具输出示例

```
🔹 逝者 #1:
   ✅ 数据存在
   owner: 5CrDBEVDgX...
   graveId: 2
   name: 赵六
   gender: M
   birthTs: 19480618
   deathTs: 19860521
   deceasedToken: [解析失败: The character sequence is not a valid Utf8 string]
   ⬆️ 这个错误提示就是问题根源
```

---

## 📚 技术细节

### DeceasedToken 的设计理由

根据 `pallets/deceased/README.md`：

```rust
/// Token组成
/// 格式：性别(M/F/B) + 出生日期(YYYYMMDD) + 离世日期(YYYYMMDD) + 姓名哈希
/// 
/// 示例：M1981122420250901LIUXIAODONG
/// 
/// 用途：
/// - 唯一标识逝者
/// - 防止重复创建
/// - 支持快速检索
/// - 用于外部引用
```

**为什么使用哈希？**
1. **唯一性**：防止同名同生卒日期的重复创建
2. **隐私保护**：避免明文存储完整姓名
3. **固定长度**：便于索引和查询
4. **防篡改**：哈希值不可伪造

**为什么包含二进制数据？**
- 姓名哈希使用 Blake2 算法生成 32 字节二进制数据
- 二进制数据不是有效的 UTF-8 字符序列
- 必须以十六进制或其他编码方式展示

### UTF-8 解码原理

```javascript
// ✅ 有效的 UTF-8 序列
new TextDecoder().decode(new Uint8Array([0x48, 0x65, 0x6c, 0x6c, 0x6f]))
// 输出: "Hello"

// ❌ 无效的 UTF-8 序列（二进制哈希）
new TextDecoder().decode(new Uint8Array([0x74, 0xcd, 0x1b, 0xee, 0xaa]))
// 抛出异常: The character sequence is not a valid Utf8 string
```

### 十六进制编码

```javascript
// 将字节数组转为十六进制字符串
const bytes = new Uint8Array([0x74, 0xcd, 0x1b, 0xee, 0xaa])
const hex = '0x' + Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('')
// 输出: "0x74cd1beeaa"
```

---

## 🎯 最佳实践建议

### 1. 链上数据编码规范

**对于包含二进制数据的字段**：
- ✅ 前端应默认以十六进制显示
- ✅ 不应尝试 UTF-8 解码
- ✅ 提供"复制"功能供用户使用

**对于纯文本字段**：
- ✅ 优先 UTF-8 解码
- ✅ 失败时提供降级方案（如十六进制）

### 2. 前端解析逻辑

**推荐模式**：

```typescript
// 字段解析工厂函数
const parseField = (field: any, options: { 
  encoding: 'utf8' | 'hex' | 'auto' 
}): string | undefined => {
  if (options.encoding === 'utf8') {
    return parseUtf8(field)
  } else if (options.encoding === 'hex') {
    return parseHex(field)
  } else {
    // auto: 先尝试 UTF-8，失败则用十六进制
    return parseUtf8(field) || parseHex(field)
  }
}

// 使用示例
const name = parseField(deceased.name, { encoding: 'utf8' })
const token = parseField(deceased.deceasedToken, { encoding: 'auto' })  // ✅ 容错
```

### 3. UI 展示优化

**Token 字段显示优化**：

```typescript
// 当前实现（修复后）
<Typography.Text code>{token}</Typography.Text>
// 显示: 0x4d3139343830363138313938363035323174cd1b...

// 建议优化
{token && (
  <div>
    <Typography.Text type="secondary">Token：</Typography.Text>
    <Typography.Text 
      code 
      copyable={{ text: token }}
      ellipsis={{ rows: 1 }}
      style={{ maxWidth: 300 }}
    >
      {token}
    </Typography.Text>
  </div>
)}
```

---

## 🐛 其他潜在问题

### 问题 1：姓名字段也可能是加密的

根据开发规范第6条：
> 设计项目修改源代码过程中，如该有上传到IPFS内容回填CID，必须检查CID是否加密，**除证据类数据，以及特殊要求不加密的数据外，其他的数据CID不加密**。

**影响**：
- 如果姓名（`name` 字段）存储的是加密CID，也会遇到类似问题
- 当前修复方案已覆盖此情况（自动转十六进制）

**验证方法**：
```bash
# 检查姓名字段是否为 CID
node diagnose-grave.js 2 | grep "name:"
# 输出: name: 赵六  ✅ 明文姓名
# 或: name: 0xe8b5b5e585ad  ⚠️ 十六进制编码（UTF-8字节）
# 或: name: QmXxx...  ⚠️ IPFS CID（需要fetch解密）
```

### 问题 2：其他字段的二进制数据

**可能包含二进制的字段**（需要关注）：
- `deceased_token`（已修复）
- `name_full_cid`（IPFS CID，如果加密）
- `main_image_cid`（IPFS CID）
- 自定义哈希字段

**通用解决方案**：
当前的 `toStringFromAny` 修复已覆盖所有字段，无需额外处理。

---

## ✅ 修复验证清单

- [x] 链上数据检查（18个逝者，10个墓地）
- [x] 问题根因定位（deceasedToken 包含二进制哈希）
- [x] 前端代码修复（toStringFromAny 增加容错）
- [x] 语法检查（无 linter 错误）
- [ ] **浏览器测试（需用户验证）**
- [ ] **多墓地测试（测试 #1-9）**
- [ ] **回归测试（确保其他页面正常）**

---

## 📞 后续支持

### 如果修复后仍有问题

1. **清除浏览器缓存**：`Ctrl + Shift + R`
2. **检查前端服务**：确认 `npm run dev` 已重启
3. **查看控制台**：打开 F12，查看是否有新的报错
4. **运行诊断脚本**：`node diagnose-grave.js 2`

### 诊断脚本位置

```
/home/xiaodong/文档/stardust/check-deceased.js      # 快速检查
/home/xiaodong/文档/stardust/diagnose-grave.js      # 详细诊断
```

---

## 📖 相关文档

- [pallets/deceased/README.md](../pallets/deceased/README.md) - 逝者档案管理
- [pallets/stardust-grave/README.md](../pallets/stardust-grave/README.md) - 墓地管理
- [纪念馆详情页-逝者信息显示问题排查指南.md](./纪念馆详情页-逝者信息显示问题排查指南.md) - 之前的排查文档

---

**维护者**: Stardust 开发团队  
**修复日期**: 2025-11-08  
**文档版本**: 1.0.0  
**状态**: ✅ 已解决，待测试验证

