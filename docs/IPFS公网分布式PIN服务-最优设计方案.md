# IPFSå…¬ç½‘ + å¤šèŠ‚ç‚¹åˆ†å¸ƒå¼PINæœåŠ¡ - æœ€ä¼˜è®¾è®¡æ–¹æ¡ˆ

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¶é—´**: 2025-10-26  
> **ä½œè€…**: Stardustå¼€å‘å›¢é˜Ÿ  
> **çŠ¶æ€**: âœ… æœ€ä¼˜æ–¹æ¡ˆè®¾è®¡

---

## ğŸ“‹ æ–¹æ¡ˆæ¦‚è¿°

### æ ¸å¿ƒæ¶æ„

**æ–¹æ¡ˆå®šä¹‰**ï¼šä½¿ç”¨å…¬å…±IPFSç½‘ç»œå­˜å‚¨æ•°æ®ï¼Œç”±å¤šä¸ªStardust SubstrateèŠ‚ç‚¹æä¾›åˆ†å¸ƒå¼PINæœåŠ¡ï¼Œç¡®ä¿æ•°æ®æŒä¹…æ€§å’Œé«˜å¯ç”¨æ€§ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          IPFSå…¬ç½‘ + å¤šèŠ‚ç‚¹åˆ†å¸ƒå¼PINæ¶æ„ï¼ˆæœ€ä¼˜æ–¹æ¡ˆï¼‰              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  Layer 1: SubstrateåŒºå—é“¾é›†ç¾¤                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  èŠ‚ç‚¹ç±»å‹åˆ’åˆ†ï¼ˆæ™ºèƒ½è§’è‰²åˆ†é…ï¼‰                             â”‚  â”‚
â”‚  â”‚                                                            â”‚  â”‚
â”‚  â”‚  ğŸ”¹ æ ¸å¿ƒPINèŠ‚ç‚¹ï¼ˆ3ä¸ªï¼‰                                     â”‚  â”‚
â”‚  â”‚     â”œâ”€ SubstrateéªŒè¯è€…                                    â”‚  â”‚
â”‚  â”‚     â”œâ”€ IPFS Daemonï¼ˆè¿æ¥å…¬ç½‘ï¼‰                            â”‚  â”‚
â”‚  â”‚     â”œâ”€ å¤§å®¹é‡å­˜å‚¨ï¼ˆ10TBï¼‰                                 â”‚  â”‚
â”‚  â”‚     â””â”€ é«˜ä¼˜å…ˆçº§PINï¼ˆCriticalæ•°æ®100%ï¼‰                    â”‚  â”‚
â”‚  â”‚                                                            â”‚  â”‚
â”‚  â”‚  ğŸ”¸ è¾…åŠ©PINèŠ‚ç‚¹ï¼ˆ2-3ä¸ªï¼‰                                   â”‚  â”‚
â”‚  â”‚     â”œâ”€ Substrateå…¨èŠ‚ç‚¹                                    â”‚  â”‚
â”‚  â”‚     â”œâ”€ IPFS Daemonï¼ˆè¿æ¥å…¬ç½‘ï¼‰                            â”‚  â”‚
â”‚  â”‚     â”œâ”€ ä¸­ç­‰å®¹é‡å­˜å‚¨ï¼ˆ5TBï¼‰                                â”‚  â”‚
â”‚  â”‚     â””â”€ ä¸­ä¼˜å…ˆçº§PINï¼ˆStandardæ•°æ®ï¼‰                        â”‚  â”‚
â”‚  â”‚                                                            â”‚  â”‚
â”‚  â”‚  ğŸ”¹ è½»é‡PINèŠ‚ç‚¹ï¼ˆå¯é€‰ï¼ŒNä¸ªï¼‰                               â”‚  â”‚
â”‚  â”‚     â”œâ”€ Substrateè½»èŠ‚ç‚¹                                    â”‚  â”‚
â”‚  â”‚     â”œâ”€ IPFS Daemonï¼ˆè¿æ¥å…¬ç½‘ï¼‰                            â”‚  â”‚
â”‚  â”‚     â”œâ”€ å°å®¹é‡å­˜å‚¨ï¼ˆ1TBï¼‰                                  â”‚  â”‚
â”‚  â”‚     â””â”€ ä½ä¼˜å…ˆçº§PINï¼ˆTemporaryæ•°æ®ï¼‰                       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                          â†“                                       â”‚
â”‚  Layer 2: æ™ºèƒ½PINåˆ†é…å±‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  PINåˆ†é…ç­–ç•¥ï¼ˆé“¾ä¸Šå…±è¯†ï¼‰                                  â”‚  â”‚
â”‚  â”‚  â”œâ”€ åŸºäºPinTieræ™ºèƒ½åˆ†é…                                   â”‚  â”‚
â”‚  â”‚  â”œâ”€ èŠ‚ç‚¹å®¹é‡æ„ŸçŸ¥                                          â”‚  â”‚
â”‚  â”‚  â”œâ”€ åœ°ç†ä½ç½®è€ƒè™‘ï¼ˆå¯é€‰ï¼‰                                  â”‚  â”‚
â”‚  â”‚  â””â”€ è‡ªåŠ¨è´Ÿè½½å‡è¡¡                                          â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                          â†“                                       â”‚
â”‚  Layer 3: å…¬å…±IPFSç½‘ç»œ                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  å…¨çƒIPFSèŠ‚ç‚¹                                             â”‚  â”‚
â”‚  â”‚  â”œâ”€ DHTè‡ªåŠ¨è·¯ç”±                                           â”‚  â”‚
â”‚  â”‚  â”œâ”€ P2Pæ•°æ®ä¼ è¾“                                           â”‚  â”‚
â”‚  â”‚  â”œâ”€ StardustèŠ‚ç‚¹ä¼˜å…ˆäº’è”                                  â”‚  â”‚
â”‚  â”‚  â””â”€ å…¬å…±Gatewayè®¿é—®                                       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                          â†“                                       â”‚
â”‚  Layer 4: å¥åº·ç›‘æ§å’Œè‡ªåŠ¨ä¿®å¤                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  OCWè‡ªåŠ¨åŒ–ä»»åŠ¡                                            â”‚  â”‚
â”‚  â”‚  â”œâ”€ å®šæœŸå¥åº·æ£€æŸ¥ï¼ˆæ¯10åˆ†é’Ÿï¼‰                              â”‚  â”‚
â”‚  â”‚  â”œâ”€ å‰¯æœ¬æ•°éªŒè¯                                            â”‚  â”‚
â”‚  â”‚  â”œâ”€ è‡ªåŠ¨æ•…éšœè½¬ç§»                                          â”‚  â”‚
â”‚  â”‚  â””â”€ é“¾ä¸ŠçŠ¶æ€è®°å½•                                          â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ ¸å¿ƒç‰¹å¾**ï¼š
- âœ… å¤šèŠ‚ç‚¹åˆ†å¸ƒå¼PINï¼ˆé«˜å¯ç”¨æ€§ï¼‰
- âœ… æ™ºèƒ½PINåˆ†é…ï¼ˆåŸºäºPinTierå’ŒèŠ‚ç‚¹å®¹é‡ï¼‰
- âœ… è‡ªåŠ¨è´Ÿè½½å‡è¡¡ï¼ˆé¿å…å•èŠ‚ç‚¹è¿‡è½½ï¼‰
- âœ… å¥åº·ç›‘æ§å’Œè‡ªåŠ¨ä¿®å¤ï¼ˆOCWé©±åŠ¨ï¼‰
- âœ… é“¾ä¸Šå…±è¯†å†³ç­–ï¼ˆå»ä¸­å¿ƒåŒ–ï¼‰

---

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### 1. èŠ‚ç‚¹è§’è‰²åˆ’åˆ†

#### èŠ‚ç‚¹ç±»å‹å®šä¹‰

**æ ¸å¿ƒPINèŠ‚ç‚¹ï¼ˆCore PIN Nodesï¼‰**ï¼š
```
è§’è‰²ï¼šä¸»åŠ›PINèŠ‚ç‚¹
æ•°é‡ï¼š3ä¸ªï¼ˆæœ€å°ï¼Œæ¨è3-5ä¸ªï¼‰
èŒè´£ï¼š
â”œâ”€ å­˜å‚¨æ‰€æœ‰Criticalçº§åˆ«CIDï¼ˆ100%ï¼‰
â”œâ”€ å­˜å‚¨70%çš„Standardçº§åˆ«CID
â”œâ”€ é«˜ä¼˜å…ˆçº§å¥åº·æ£€æŸ¥
â””â”€ ä½œä¸ºå¼•å¯¼èŠ‚ç‚¹ï¼ˆBootstrap Nodeï¼‰

ç¡¬ä»¶é…ç½®ï¼š
â”œâ”€ CPU: 8æ ¸
â”œâ”€ RAM: 32GB
â”œâ”€ å­˜å‚¨: 500GB SSDï¼ˆSubstrateï¼‰+ 10TB HDDï¼ˆIPFSï¼‰
â”œâ”€ å¸¦å®½: 1Gbps
â””â”€ æˆæœ¬: ~$3,500/èŠ‚ç‚¹

Substrateè§’è‰²ï¼š
â”œâ”€ éªŒè¯è€…ï¼ˆValidatorï¼‰æˆ–å…¨èŠ‚ç‚¹ï¼ˆFull Nodeï¼‰
â”œâ”€ å¯ç”¨OCW
â””â”€ é«˜å¯ç”¨æ€§ï¼ˆ99.9%+ï¼‰

IPFSé…ç½®ï¼š
â”œâ”€ è¿æ¥å…¬å…±IPFSç½‘ç»œ
â”œâ”€ é…ç½®Peeringï¼ˆä¸å…¶ä»–StardustèŠ‚ç‚¹ï¼‰
â”œâ”€ å­˜å‚¨é™åˆ¶ï¼š10TB
â””â”€ å¸¦å®½é™åˆ¶ï¼šé€‚åº¦ï¼ˆé¿å…ä¸ºå…¬å…±èŠ‚ç‚¹æä¾›è¿‡å¤šæœåŠ¡ï¼‰
```

**è¾…åŠ©PINèŠ‚ç‚¹ï¼ˆAuxiliary PIN Nodesï¼‰**ï¼š
```
è§’è‰²ï¼šè¾…åŠ©PINèŠ‚ç‚¹
æ•°é‡ï¼š2-3ä¸ª
èŒè´£ï¼š
â”œâ”€ å­˜å‚¨50%çš„Criticalçº§åˆ«CIDï¼ˆå¤‡ä»½ï¼‰
â”œâ”€ å­˜å‚¨70%çš„Standardçº§åˆ«CID
â”œâ”€ å­˜å‚¨éƒ¨åˆ†Temporaryçº§åˆ«CID
â””â”€ ä¸­ä¼˜å…ˆçº§å¥åº·æ£€æŸ¥

ç¡¬ä»¶é…ç½®ï¼š
â”œâ”€ CPU: 4-8æ ¸
â”œâ”€ RAM: 16-32GB
â”œâ”€ å­˜å‚¨: 200GB SSDï¼ˆSubstrateï¼‰+ 5TB HDDï¼ˆIPFSï¼‰
â”œâ”€ å¸¦å®½: 500Mbps-1Gbps
â””â”€ æˆæœ¬: ~$2,000/èŠ‚ç‚¹

Substrateè§’è‰²ï¼š
â”œâ”€ å…¨èŠ‚ç‚¹ï¼ˆFull Nodeï¼‰
â”œâ”€ å¯ç”¨OCW
â””â”€ é«˜å¯ç”¨æ€§ï¼ˆ99%+ï¼‰

IPFSé…ç½®ï¼š
â”œâ”€ è¿æ¥å…¬å…±IPFSç½‘ç»œ
â”œâ”€ é…ç½®Peering
â”œâ”€ å­˜å‚¨é™åˆ¶ï¼š5TB
â””â”€ å¸¦å®½é™åˆ¶ï¼šé€‚åº¦
```

**è½»é‡PINèŠ‚ç‚¹ï¼ˆLight PIN Nodesï¼Œå¯é€‰ï¼‰**ï¼š
```
è§’è‰²ï¼šç¤¾åŒºè´¡çŒ®èŠ‚ç‚¹æˆ–ä¸´æ—¶æ•°æ®èŠ‚ç‚¹
æ•°é‡ï¼šå¯é€‰ï¼ˆ0-Nä¸ªï¼‰
èŒè´£ï¼š
â”œâ”€ å­˜å‚¨Temporaryçº§åˆ«CID
â”œâ”€ å­˜å‚¨å…¬å¼€çš„éæ•æ„Ÿæ•°æ®
â””â”€ ä½ä¼˜å…ˆçº§å¥åº·æ£€æŸ¥

ç¡¬ä»¶é…ç½®ï¼š
â”œâ”€ CPU: 2-4æ ¸
â”œâ”€ RAM: 8-16GB
â”œâ”€ å­˜å‚¨: 100GB SSDï¼ˆSubstrateï¼‰+ 1TB HDDï¼ˆIPFSï¼‰
â”œâ”€ å¸¦å®½: 100Mbps-500Mbps
â””â”€ æˆæœ¬: ~$800/èŠ‚ç‚¹

Substrateè§’è‰²ï¼š
â”œâ”€ è½»èŠ‚ç‚¹ï¼ˆLight Nodeï¼‰æˆ–å…¨èŠ‚ç‚¹
â”œâ”€ å¯ç”¨OCW
â””â”€ å¯ç”¨æ€§ï¼ˆ95%+ï¼‰

IPFSé…ç½®ï¼š
â”œâ”€ è¿æ¥å…¬å…±IPFSç½‘ç»œ
â”œâ”€ é…ç½®Peering
â”œâ”€ å­˜å‚¨é™åˆ¶ï¼š1TB
â””â”€ å¸¦å®½é™åˆ¶ï¼šä¸¥æ ¼ï¼ˆé¿å…è¿‡åº¦æ¶ˆè€—ï¼‰
```

---

### 2. æ™ºèƒ½PINåˆ†é…ç­–ç•¥

#### PINåˆ†é…ç®—æ³•ï¼ˆé“¾ä¸Šå…±è¯†ï¼‰

**æ ¸å¿ƒé€»è¾‘**ï¼šæ ¹æ®PinTierã€èŠ‚ç‚¹å®¹é‡ã€å½“å‰è´Ÿè½½æ™ºèƒ½åˆ†é…CIDåˆ°èŠ‚ç‚¹ã€‚

```rust
// pallets/stardust-ipfs/src/lib.rs

/// å‡½æ•°çº§è¯¦ç»†ä¸­æ–‡æ³¨é‡Šï¼šæ™ºèƒ½PINåˆ†é…ç®—æ³•ï¼ˆå¤šèŠ‚ç‚¹åˆ†å¸ƒå¼ï¼‰
impl<T: Config> Pallet<T> {
    pub fn smart_pin_allocation(
        cid_hash: T::Hash,
        tier: PinTier,
        estimated_size: u64,
    ) -> Result<BoundedVec<T::AccountId, ConstU32<16>>, Error<T>> {
        // è·å–æ‰€æœ‰æ´»è·ƒçš„PINèŠ‚ç‚¹
        let all_nodes = Self::get_active_pin_nodes()?;
        
        // æ ¹æ®PinTierç¡®å®šç›®æ ‡å‰¯æœ¬æ•°
        let target_replicas = match tier {
            PinTier::Critical => 5, // Criticalæ•°æ®ï¼š5å‰¯æœ¬ï¼ˆæœ€é«˜å†—ä½™ï¼‰
            PinTier::Standard => 3, // Standardæ•°æ®ï¼š3å‰¯æœ¬ï¼ˆæ ‡å‡†å†—ä½™ï¼‰
            PinTier::Temporary => 2, // Temporaryæ•°æ®ï¼š2å‰¯æœ¬ï¼ˆæœ€ä½å†—ä½™ï¼‰
        };
        
        // èŠ‚ç‚¹åˆ†ç±»
        let core_nodes = Self::filter_nodes_by_type(&all_nodes, NodeType::Core);
        let auxiliary_nodes = Self::filter_nodes_by_type(&all_nodes, NodeType::Auxiliary);
        let light_nodes = Self::filter_nodes_by_type(&all_nodes, NodeType::Light);
        
        // æ™ºèƒ½é€‰æ‹©èŠ‚ç‚¹
        let mut selected_nodes = BoundedVec::default();
        
        match tier {
            PinTier::Critical => {
                // Criticalæ•°æ®ï¼šä¼˜å…ˆé€‰æ‹©æ‰€æœ‰CoreèŠ‚ç‚¹
                for node in core_nodes.iter() {
                    if Self::node_has_capacity(node, estimated_size)? {
                        let _ = selected_nodes.try_push(node.clone());
                    }
                }
                
                // å¦‚æœCoreèŠ‚ç‚¹ä¸è¶³5ä¸ªï¼Œä»AuxiliaryèŠ‚ç‚¹è¡¥å……
                if selected_nodes.len() < target_replicas as usize {
                    for node in auxiliary_nodes.iter() {
                        if selected_nodes.len() >= target_replicas as usize {
                            break;
                        }
                        if Self::node_has_capacity(node, estimated_size)? {
                            let _ = selected_nodes.try_push(node.clone());
                        }
                    }
                }
            },
            PinTier::Standard => {
                // Standardæ•°æ®ï¼šæ··åˆé€‰æ‹©Coreå’ŒAuxiliaryèŠ‚ç‚¹
                // ç­–ç•¥ï¼š2ä¸ªCore + 1ä¸ªAuxiliaryï¼ˆæˆ–1ä¸ªCore + 2ä¸ªAuxiliaryï¼‰
                
                // å…ˆé€‰æ‹©2ä¸ªCoreèŠ‚ç‚¹ï¼ˆè´Ÿè½½æœ€ä½çš„ï¼‰
                let best_core_nodes = Self::select_nodes_by_load(&core_nodes, 2, estimated_size)?;
                for node in best_core_nodes {
                    let _ = selected_nodes.try_push(node);
                }
                
                // å†é€‰æ‹©1ä¸ªAuxiliaryèŠ‚ç‚¹
                let best_aux_nodes = Self::select_nodes_by_load(&auxiliary_nodes, 1, estimated_size)?;
                for node in best_aux_nodes {
                    let _ = selected_nodes.try_push(node);
                }
            },
            PinTier::Temporary => {
                // Temporaryæ•°æ®ï¼šä¼˜å…ˆé€‰æ‹©Auxiliaryæˆ–LightèŠ‚ç‚¹
                // ç­–ç•¥ï¼š1ä¸ªAuxiliary + 1ä¸ªLightï¼ˆæˆ–2ä¸ªAuxiliaryï¼‰
                
                let best_aux_nodes = Self::select_nodes_by_load(&auxiliary_nodes, 1, estimated_size)?;
                for node in best_aux_nodes {
                    let _ = selected_nodes.try_push(node);
                }
                
                if !light_nodes.is_empty() {
                    let best_light_nodes = Self::select_nodes_by_load(&light_nodes, 1, estimated_size)?;
                    for node in best_light_nodes {
                        let _ = selected_nodes.try_push(node);
                    }
                } else {
                    // å¦‚æœæ²¡æœ‰LightèŠ‚ç‚¹ï¼Œä»Auxiliaryè¡¥å……
                    let best_aux_nodes_2 = Self::select_nodes_by_load(&auxiliary_nodes, 1, estimated_size)?;
                    for node in best_aux_nodes_2 {
                        let _ = selected_nodes.try_push(node);
                    }
                }
            },
        }
        
        // ç¡®ä¿è‡³å°‘æœ‰ç›®æ ‡å‰¯æœ¬æ•°
        ensure!(
            selected_nodes.len() >= target_replicas as usize,
            Error::<T>::InsufficientPinNodes
        );
        
        // è®°å½•PINåˆ†é…ï¼ˆé“¾ä¸Šï¼‰
        PinAssignments::<T>::insert(&cid_hash, selected_nodes.clone());
        
        // å‘é€PINåˆ†é…äº‹ä»¶
        Self::deposit_event(Event::PinAllocated {
            cid_hash,
            tier,
            assigned_nodes: selected_nodes.clone(),
            target_replicas,
        });
        
        Ok(selected_nodes)
    }
    
    /// å‡½æ•°çº§è¯¦ç»†ä¸­æ–‡æ³¨é‡Šï¼šæ ¹æ®è´Ÿè½½é€‰æ‹©æœ€ä¼˜èŠ‚ç‚¹
    fn select_nodes_by_load(
        nodes: &Vec<T::AccountId>,
        count: usize,
        estimated_size: u64,
    ) -> Result<Vec<T::AccountId>, Error<T>> {
        let mut node_scores: Vec<(T::AccountId, u32)> = Vec::new();
        
        for node in nodes {
            // è®¡ç®—èŠ‚ç‚¹è¯„åˆ†ï¼ˆè¶Šä½è¶Šå¥½ï¼‰
            let score = Self::calculate_node_score(node, estimated_size)?;
            node_scores.push((node.clone(), score));
        }
        
        // æŒ‰è¯„åˆ†æ’åºï¼ˆå‡åºï¼‰
        node_scores.sort_by(|a, b| a.1.cmp(&b.1));
        
        // é€‰æ‹©å‰Nä¸ªèŠ‚ç‚¹
        let selected: Vec<T::AccountId> = node_scores
            .iter()
            .take(count)
            .map(|(node, _)| node.clone())
            .collect();
        
        Ok(selected)
    }
    
    /// å‡½æ•°çº§è¯¦ç»†ä¸­æ–‡æ³¨é‡Šï¼šè®¡ç®—èŠ‚ç‚¹è¯„åˆ†ï¼ˆç»¼åˆå®¹é‡ã€è´Ÿè½½ã€å¥åº·åº¦ï¼‰
    fn calculate_node_score(
        node: &T::AccountId,
        estimated_size: u64,
    ) -> Result<u32, Error<T>> {
        let info = NodeInfo::<T>::get(node).ok_or(Error::<T>::NodeNotFound)?;
        let stats = NodePinStats::<T>::get(node);
        
        // å®¹é‡ä½¿ç”¨ç‡ï¼ˆ0-100ï¼‰
        let capacity_usage = Self::calculate_capacity_usage(node);
        
        // å½“å‰PINæ•°é‡
        let current_pins = stats.total_pins;
        
        // å¥åº·è¯„åˆ†ï¼ˆ0-100ï¼Œè¶Šé«˜è¶Šå¥½ï¼‰
        let health_score = stats.health_score;
        
        // ç»¼åˆè¯„åˆ†ï¼šå®¹é‡ä½¿ç”¨ç‡ï¼ˆ40%æƒé‡ï¼‰+ PINæ•°é‡ï¼ˆ30%æƒé‡ï¼‰+ å¥åº·åº¦ï¼ˆ30%æƒé‡ï¼‰
        // å®¹é‡ä½¿ç”¨ç‡è¶Šä½è¶Šå¥½ï¼ŒPINæ•°é‡è¶Šå°‘è¶Šå¥½ï¼Œå¥åº·åº¦è¶Šé«˜è¶Šå¥½
        let score = (capacity_usage * 40 / 100)
            + (current_pins * 30 / 1000) // å‡è®¾æœ€å¤§1000ä¸ªPIN
            + ((100 - health_score) * 30 / 100); // å¥åº·åº¦è½¬ä¸ºæƒ©ç½šé¡¹
        
        Ok(score)
    }
    
    /// å‡½æ•°çº§è¯¦ç»†ä¸­æ–‡æ³¨é‡Šï¼šæ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦æœ‰è¶³å¤Ÿå®¹é‡
    fn node_has_capacity(
        node: &T::AccountId,
        estimated_size: u64,
    ) -> Result<bool, Error<T>> {
        let info = NodeInfo::<T>::get(node).ok_or(Error::<T>::NodeNotFound)?;
        let capacity_usage = Self::calculate_capacity_usage(node);
        
        // å¦‚æœå®¹é‡ä½¿ç”¨ç‡ > 85%ï¼Œè®¤ä¸ºå®¹é‡ä¸è¶³
        if capacity_usage > 85 {
            return Ok(false);
        }
        
        // ä¼°ç®—æ·»åŠ æ–°CIDåçš„ä½¿ç”¨ç‡
        let current_used_gib = (info.capacity_gib as u64 * capacity_usage as u64) / 100;
        let new_used_gib = current_used_gib + (estimated_size / (1024 * 1024 * 1024));
        let new_usage = (new_used_gib * 100) / info.capacity_gib as u64;
        
        // å¦‚æœæ·»åŠ åä½¿ç”¨ç‡ > 90%ï¼Œè®¤ä¸ºå®¹é‡ä¸è¶³
        Ok(new_usage <= 90)
    }
}

/// æ–°å¢å­˜å‚¨ï¼šèŠ‚ç‚¹ç±»å‹
#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug, TypeInfo, MaxEncodedLen)]
pub enum NodeType {
    Core,       // æ ¸å¿ƒPINèŠ‚ç‚¹
    Auxiliary,  // è¾…åŠ©PINèŠ‚ç‚¹
    Light,      // è½»é‡PINèŠ‚ç‚¹
}

/// æ–°å¢å­˜å‚¨ï¼šèŠ‚ç‚¹ä¿¡æ¯æ‰©å±•
#[pallet::storage]
#[pallet::getter(fn node_info)]
pub type NodeInfo<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::AccountId,
    NodeInfoExt<T>,
    OptionQuery,
>;

#[derive(Encode, Decode, Clone, PartialEq, Eq, TypeInfo, MaxEncodedLen)]
pub struct NodeInfoExt<T: Config> {
    pub node_type: NodeType,
    pub capacity_gib: u32,
    pub status: u8, // 0=Active, 1=Suspended
    pub registered_at: BlockNumberFor<T>,
    pub ipfs_peer_id: BoundedVec<u8, ConstU32<128>>,
}

/// æ–°å¢å­˜å‚¨ï¼šèŠ‚ç‚¹PINç»Ÿè®¡
#[pallet::storage]
#[pallet::getter(fn node_pin_stats)]
pub type NodePinStats<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::AccountId,
    NodePinStatistics<BlockNumberFor<T>>,
    ValueQuery,
>;

#[derive(Encode, Decode, Clone, PartialEq, Eq, TypeInfo, MaxEncodedLen, Default)]
pub struct NodePinStatistics<BlockNumber> {
    pub total_pins: u32,
    pub healthy_pins: u32,
    pub failed_pins: u32,
    pub last_health_check: BlockNumber,
    pub health_score: u8, // 0-100
}

/// æ–°å¢å­˜å‚¨ï¼šPINåˆ†é…è®°å½•
#[pallet::storage]
#[pallet::getter(fn pin_assignments)]
pub type PinAssignments<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::Hash, // CID Hash
    BoundedVec<T::AccountId, ConstU32<16>>, // åˆ†é…åˆ°çš„èŠ‚ç‚¹åˆ—è¡¨
    OptionQuery,
>;

/// æ–°å¢äº‹ä»¶
#[pallet::event]
pub enum Event<T: Config> {
    // ... å·²æœ‰äº‹ä»¶ ...
    
    /// PINåˆ†é…å®Œæˆ
    PinAllocated {
        cid_hash: T::Hash,
        tier: PinTier,
        assigned_nodes: BoundedVec<T::AccountId, ConstU32<16>>,
        target_replicas: u32,
    },
    
    /// èŠ‚ç‚¹è´Ÿè½½è­¦å‘Š
    NodeLoadWarning {
        node: T::AccountId,
        capacity_usage: u8,
        current_pins: u32,
    },
    
    /// PINé‡æ–°åˆ†é…ï¼ˆæ•…éšœè½¬ç§»ï¼‰
    PinReallocated {
        cid_hash: T::Hash,
        from_node: T::AccountId,
        to_node: T::AccountId,
        reason: BoundedVec<u8, ConstU32<128>>,
    },
}

/// æ–°å¢é”™è¯¯
#[pallet::error]
pub enum Error<T> {
    // ... å·²æœ‰é”™è¯¯ ...
    
    /// å‡½æ•°çº§è¯¦ç»†ä¸­æ–‡æ³¨é‡Šï¼šå¯ç”¨PINèŠ‚ç‚¹ä¸è¶³
    InsufficientPinNodes,
    
    /// å‡½æ•°çº§è¯¦ç»†ä¸­æ–‡æ³¨é‡Šï¼šèŠ‚ç‚¹æœªæ‰¾åˆ°
    NodeNotFound,
    
    /// å‡½æ•°çº§è¯¦ç»†ä¸­æ–‡æ³¨é‡Šï¼šèŠ‚ç‚¹å®¹é‡ä¸è¶³
    NodeCapacityInsufficient,
}
```

---

### 3. å‰¯æœ¬åˆ†å¸ƒç­–ç•¥

#### æœ€ä¼˜å‰¯æœ¬é…ç½®

**æŒ‰PinTieré…ç½®å‰¯æœ¬æ•°**ï¼š

| PinTier | ç›®æ ‡å‰¯æœ¬æ•° | èŠ‚ç‚¹åˆ†å¸ƒç­–ç•¥ | æ•°æ®ç‰¹å¾ |
|---------|-----------|-------------|---------|
| **Critical** | 5å‰¯æœ¬ | 3ä¸ªCore + 2ä¸ªAuxiliary | è¯æ®ã€æ¡£æ¡ˆ |
| **Standard** | 3å‰¯æœ¬ | 2ä¸ªCore + 1ä¸ªAuxiliary | ç…§ç‰‡ã€å¢“ç¢‘ |
| **Temporary** | 2å‰¯æœ¬ | 1ä¸ªAuxiliary + 1ä¸ªLight | ä¸´æ—¶æ•°æ® |

**åœ°ç†åˆ†å¸ƒç­–ç•¥ï¼ˆå¯é€‰ï¼‰**ï¼š
```
å¦‚æœèŠ‚ç‚¹åˆ†å¸ƒåœ¨ä¸åŒåœ°åŒºï¼š
â”œâ”€ Criticalæ•°æ®ï¼šè‡³å°‘2ä¸ªä¸åŒåœ°åŒº
â”œâ”€ Standardæ•°æ®ï¼šè‡³å°‘2ä¸ªä¸åŒåœ°åŒº
â””â”€ Temporaryæ•°æ®ï¼šå¯ä»¥åœ¨åŒä¸€åœ°åŒº

å®ç°ï¼š
#[derive(Encode, Decode, Clone, PartialEq, Eq, TypeInfo, MaxEncodedLen)]
pub enum Region {
    AsiaPacific,
    Europe,
    NorthAmerica,
    SouthAmerica,
}

// åœ¨NodeInfoExtä¸­æ·»åŠ regionå­—æ®µ
pub struct NodeInfoExt<T: Config> {
    // ... å·²æœ‰å­—æ®µ ...
    pub region: Option<Region>,
}

// PINåˆ†é…æ—¶è€ƒè™‘åœ°ç†åˆ†å¸ƒ
fn select_nodes_with_geo_diversity(
    nodes: &Vec<T::AccountId>,
    count: usize,
    tier: PinTier,
) -> Result<Vec<T::AccountId>, Error<T>> {
    // å¦‚æœæ˜¯Criticalæ•°æ®ï¼Œç¡®ä¿è‡³å°‘2ä¸ªä¸åŒåœ°åŒº
    if tier == PinTier::Critical {
        // å®ç°åœ°ç†åˆ†å¸ƒé€»è¾‘
    }
    // ...
}
```

**å‰¯æœ¬ç›‘æ§é˜ˆå€¼**ï¼š
```
è‡ªåŠ¨ä¿®å¤è§¦å‘æ¡ä»¶ï¼š
â”œâ”€ Criticalæ•°æ®ï¼šå‰¯æœ¬æ•° < 4ï¼ˆä½äº80%ï¼‰ â†’ ç«‹å³ä¿®å¤
â”œâ”€ Standardæ•°æ®ï¼šå‰¯æœ¬æ•° < 2ï¼ˆä½äº66%ï¼‰ â†’ 24å°æ—¶å†…ä¿®å¤
â””â”€ Temporaryæ•°æ®ï¼šå‰¯æœ¬æ•° < 1ï¼ˆä½äº50%ï¼‰ â†’ 7å¤©å†…ä¿®å¤æˆ–åˆ é™¤
```

---

### 4. åˆ†å¸ƒå¼å¥åº·æ£€æŸ¥

#### OCWå¥åº·æ£€æŸ¥æœºåˆ¶

**å¤šèŠ‚ç‚¹å¹¶è¡Œå¥åº·æ£€æŸ¥**ï¼š

```rust
impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
    fn offchain_worker(block_number: BlockNumberFor<T>) {
        log::info!("OCW: Distributed health check at block {:?}", block_number);
        
        // æ¯ä¸ªèŠ‚ç‚¹çš„OCWç‹¬ç«‹å·¥ä½œ
        let local_node = Self::get_local_node_account();
        
        // è·å–å½“å‰èŠ‚ç‚¹è´Ÿè´£æ£€æŸ¥çš„CIDåˆ—è¡¨
        let cids_to_check = Self::get_cids_for_health_check(&local_node, 20);
        
        for (cid_hash, cid) in cids_to_check {
            // æ£€æŸ¥æœ¬åœ°PINçŠ¶æ€
            match Self::check_local_ipfs_pin(&cid) {
                Ok(true) => {
                    // PINå¥åº·ï¼Œæ›´æ–°é“¾ä¸ŠçŠ¶æ€
                    let call = Call::report_pin_healthy {
                        cid_hash,
                        node: local_node.clone(),
                    };
                    let _ = SubmitTransaction::<T, Call<T>>::submit_unsigned_transaction(call.into());
                },
                Ok(false) => {
                    // PINä¸¢å¤±ï¼ŒæŠ¥å‘Šå¹¶è§¦å‘ä¿®å¤
                    log::warn!("PIN lost on local node: {:?}", cid_hash);
                    
                    let call = Call::report_pin_lost {
                        cid_hash,
                        node: local_node.clone(),
                    };
                    let _ = SubmitTransaction::<T, Call<T>>::submit_unsigned_transaction(call.into());
                    
                    // å°è¯•ä»å…¶ä»–èŠ‚ç‚¹é‡æ–°è·å–
                    let _ = Self::pin_to_local_ipfs(&cid);
                },
                Err(e) => {
                    log::error!("Health check error: {:?}", e);
                }
            }
        }
    }
}

impl<T: Config> Pallet<T> {
    /// å‡½æ•°çº§è¯¦ç»†ä¸­æ–‡æ³¨é‡Šï¼šè·å–å½“å‰èŠ‚ç‚¹è´Ÿè´£æ£€æŸ¥çš„CIDåˆ—è¡¨
    fn get_cids_for_health_check(
        node: &T::AccountId,
        limit: u32,
    ) -> Vec<(T::Hash, Vec<u8>)> {
        let mut result = Vec::new();
        
        // éå†æ‰€æœ‰PINåˆ†é…
        for (cid_hash, assigned_nodes) in PinAssignments::<T>::iter() {
            // å¦‚æœå½“å‰èŠ‚ç‚¹åœ¨åˆ†é…åˆ—è¡¨ä¸­
            if assigned_nodes.contains(node) {
                // è·å–CID
                if let Some(cid) = CidRegistry::<T>::get(&cid_hash) {
                    result.push((cid_hash, cid));
                    
                    if result.len() >= limit as usize {
                        break;
                    }
                }
            }
        }
        
        result
    }
    
    /// å‡½æ•°çº§è¯¦ç»†ä¸­æ–‡æ³¨é‡Šï¼šæŠ¥å‘ŠPINå¥åº·ï¼ˆæ— ç­¾åäº¤æ˜“ï¼‰
    #[pallet::call_index(30)]
    #[pallet::weight(T::WeightInfo::report_pin_healthy())]
    pub fn report_pin_healthy(
        origin: OriginFor<T>,
        cid_hash: T::Hash,
        node: T::AccountId,
    ) -> DispatchResult {
        ensure_none(origin)?;
        
        // æ›´æ–°èŠ‚ç‚¹ç»Ÿè®¡
        NodePinStats::<T>::mutate(&node, |stats| {
            stats.healthy_pins = stats.healthy_pins.saturating_add(1);
            stats.last_health_check = <frame_system::Pallet<T>>::block_number();
            stats.health_score = Self::recalculate_health_score(&node);
        });
        
        // æ›´æ–°CIDå¥åº·çŠ¶æ€
        CidHealthStatus::<T>::insert(&cid_hash, HealthStatus::Healthy);
        
        Self::deposit_event(Event::PinHealthReported {
            cid_hash,
            node,
            status: HealthStatus::Healthy,
        });
        
        Ok(())
    }
    
    /// å‡½æ•°çº§è¯¦ç»†ä¸­æ–‡æ³¨é‡Šï¼šæŠ¥å‘ŠPINä¸¢å¤±ï¼ˆæ— ç­¾åäº¤æ˜“ï¼‰
    #[pallet::call_index(31)]
    #[pallet::weight(T::WeightInfo::report_pin_lost())]
    pub fn report_pin_lost(
        origin: OriginFor<T>,
        cid_hash: T::Hash,
        node: T::AccountId,
    ) -> DispatchResult {
        ensure_none(origin)?;
        
        // æ›´æ–°èŠ‚ç‚¹ç»Ÿè®¡
        NodePinStats::<T>::mutate(&node, |stats| {
            stats.failed_pins = stats.failed_pins.saturating_add(1);
            stats.last_health_check = <frame_system::Pallet<T>>::block_number();
            stats.health_score = Self::recalculate_health_score(&node);
        });
        
        // æ£€æŸ¥å‰¯æœ¬æ•°
        let current_replicas = Self::count_healthy_replicas(&cid_hash)?;
        let tier = CidTier::<T>::get(&cid_hash).unwrap_or(PinTier::Standard);
        let target_replicas = Self::get_target_replicas(&tier);
        
        // å¦‚æœå‰¯æœ¬æ•°ä½äºé˜ˆå€¼ï¼Œè§¦å‘è‡ªåŠ¨ä¿®å¤
        if current_replicas < (target_replicas * 80 / 100) {
            // è§¦å‘æ•…éšœè½¬ç§»ï¼šé‡æ–°åˆ†é…åˆ°æ–°èŠ‚ç‚¹
            Self::trigger_failover(&cid_hash, &node)?;
        }
        
        Self::deposit_event(Event::PinHealthReported {
            cid_hash,
            node,
            status: HealthStatus::Failed,
        });
        
        Ok(())
    }
    
    /// å‡½æ•°çº§è¯¦ç»†ä¸­æ–‡æ³¨é‡Šï¼šè§¦å‘æ•…éšœè½¬ç§»ï¼ˆé‡æ–°åˆ†é…PINåˆ°æ–°èŠ‚ç‚¹ï¼‰
    fn trigger_failover(
        cid_hash: &T::Hash,
        failed_node: &T::AccountId,
    ) -> DispatchResult {
        // è·å–å½“å‰åˆ†é…
        let mut assigned_nodes = PinAssignments::<T>::get(cid_hash)
            .ok_or(Error::<T>::PinNotFound)?;
        
        // ç§»é™¤å¤±è´¥èŠ‚ç‚¹
        assigned_nodes.retain(|node| node != failed_node);
        
        // é€‰æ‹©æ–°èŠ‚ç‚¹
        let tier = CidTier::<T>::get(cid_hash).unwrap_or(PinTier::Standard);
        let all_nodes = Self::get_active_pin_nodes()?;
        
        // æ’é™¤å·²åˆ†é…çš„èŠ‚ç‚¹
        let available_nodes: Vec<T::AccountId> = all_nodes
            .iter()
            .filter(|node| !assigned_nodes.contains(node))
            .cloned()
            .collect();
        
        // é€‰æ‹©1ä¸ªæ–°èŠ‚ç‚¹
        let new_nodes = Self::select_nodes_by_load(&available_nodes, 1, 0)?;
        
        if let Some(new_node) = new_nodes.first() {
            // æ·»åŠ åˆ°åˆ†é…åˆ—è¡¨
            assigned_nodes.try_push(new_node.clone())
                .map_err(|_| Error::<T>::BadParams)?;
            
            PinAssignments::<T>::insert(cid_hash, assigned_nodes);
            
            // å‘é€é‡æ–°åˆ†é…äº‹ä»¶
            Self::deposit_event(Event::PinReallocated {
                cid_hash: *cid_hash,
                from_node: failed_node.clone(),
                to_node: new_node.clone(),
                reason: BoundedVec::truncate_from(b"Pin lost, failover triggered".to_vec()),
            });
            
            // è§¦å‘æ–°èŠ‚ç‚¹çš„OCWå»PIN
            // ï¼ˆæ–°èŠ‚ç‚¹çš„OCWä¼šåœ¨ä¸‹ä¸€ä¸ªåŒºå—æ£€æµ‹åˆ°æ–°åˆ†é…å¹¶æ‰§è¡ŒPINï¼‰
        }
        
        Ok(())
    }
    
    /// å‡½æ•°çº§è¯¦ç»†ä¸­æ–‡æ³¨é‡Šï¼šç»Ÿè®¡å¥åº·å‰¯æœ¬æ•°
    fn count_healthy_replicas(cid_hash: &T::Hash) -> Result<u32, Error<T>> {
        let assigned_nodes = PinAssignments::<T>::get(cid_hash)
            .ok_or(Error::<T>::PinNotFound)?;
        
        let mut healthy_count = 0u32;
        
        for node in assigned_nodes.iter() {
            let stats = NodePinStats::<T>::get(node);
            
            // å¦‚æœèŠ‚ç‚¹å¥åº·åº¦ > 50ï¼Œè®¤ä¸ºå‰¯æœ¬å¥åº·
            if stats.health_score > 50 {
                healthy_count += 1;
            }
        }
        
        Ok(healthy_count)
    }
    
    /// å‡½æ•°çº§è¯¦ç»†ä¸­æ–‡æ³¨é‡Šï¼šè·å–ç›®æ ‡å‰¯æœ¬æ•°
    fn get_target_replicas(tier: &PinTier) -> u32 {
        match tier {
            PinTier::Critical => 5,
            PinTier::Standard => 3,
            PinTier::Temporary => 2,
        }
    }
}

/// æ–°å¢å­˜å‚¨ï¼šCIDå¥åº·çŠ¶æ€
#[pallet::storage]
pub type CidHealthStatus<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::Hash,
    HealthStatus,
    ValueQuery,
>;

/// æ–°å¢äº‹ä»¶
#[pallet::event]
pub enum Event<T: Config> {
    // ... å·²æœ‰äº‹ä»¶ ...
    
    /// PINå¥åº·çŠ¶æ€æŠ¥å‘Š
    PinHealthReported {
        cid_hash: T::Hash,
        node: T::AccountId,
        status: HealthStatus,
    },
}
```

**å¥åº·æ£€æŸ¥é¢‘ç‡**ï¼š
```
Criticalæ•°æ®ï¼šæ¯10åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡ï¼ˆ100ä¸ªåŒºå—ï¼‰
Standardæ•°æ®ï¼šæ¯1å°æ—¶æ£€æŸ¥ä¸€æ¬¡ï¼ˆ600ä¸ªåŒºå—ï¼‰
Temporaryæ•°æ®ï¼šæ¯6å°æ—¶æ£€æŸ¥ä¸€æ¬¡ï¼ˆ3600ä¸ªåŒºå—ï¼‰
```

---

### 5. è´Ÿè½½å‡è¡¡å’Œæ‰©å®¹

#### åŠ¨æ€è´Ÿè½½å‡è¡¡

**è´Ÿè½½ç›‘æ§**ï¼š
```rust
impl<T: Config> Pallet<T> {
    /// å‡½æ•°çº§è¯¦ç»†ä¸­æ–‡æ³¨é‡Šï¼šç›‘æ§èŠ‚ç‚¹è´Ÿè½½å¹¶è§¦å‘å‘Šè­¦
    pub fn monitor_node_load() {
        for (node, stats) in NodePinStats::<T>::iter() {
            let capacity_usage = Self::calculate_capacity_usage(&node);
            
            // å®¹é‡ä½¿ç”¨ç‡ > 80%ï¼Œå‘å‡ºè­¦å‘Š
            if capacity_usage > 80 {
                Self::deposit_event(Event::NodeLoadWarning {
                    node: node.clone(),
                    capacity_usage,
                    current_pins: stats.total_pins,
                });
                
                // æ ‡è®°èŠ‚ç‚¹ä¸º"é«˜è´Ÿè½½"ï¼Œåç»­PINåˆ†é…é¿å…æ­¤èŠ‚ç‚¹
                NodeLoadStatus::<T>::insert(&node, LoadStatus::High);
            } else if capacity_usage > 60 {
                NodeLoadStatus::<T>::insert(&node, LoadStatus::Medium);
            } else {
                NodeLoadStatus::<T>::insert(&node, LoadStatus::Low);
            }
        }
    }
}

#[derive(Encode, Decode, Clone, PartialEq, Eq, TypeInfo, MaxEncodedLen)]
pub enum LoadStatus {
    Low,    // < 60%
    Medium, // 60-80%
    High,   // > 80%
}

#[pallet::storage]
pub type NodeLoadStatus<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::AccountId,
    LoadStatus,
    ValueQuery,
>;
```

**è‡ªåŠ¨æ‰©å®¹ç­–ç•¥**ï¼š
```
æ‰©å®¹è§¦å‘æ¡ä»¶ï¼š
â”œâ”€ æ‰€æœ‰CoreèŠ‚ç‚¹å®¹é‡ > 80%
â”œâ”€ æ‰€æœ‰AuxiliaryèŠ‚ç‚¹å®¹é‡ > 70%
â””â”€ æŒç»­7å¤©

æ‰©å®¹è¡ŒåŠ¨ï¼š
â”œâ”€ é€šçŸ¥æ²»ç†å§”å‘˜ä¼š
â”œâ”€ æ·»åŠ æ–°çš„Auxiliaryæˆ–LightèŠ‚ç‚¹
â”œâ”€ é‡æ–°å¹³è¡¡PINåˆ†é…
â””â”€ é“¾ä¸Šè®°å½•æ‰©å®¹äº‹ä»¶
```

---

## ğŸ’° æˆæœ¬åˆ†æ

### èŠ‚ç‚¹é…ç½®å’Œæˆæœ¬

**åˆå§‹é…ç½®ï¼ˆMVPï¼‰**ï¼š

| èŠ‚ç‚¹ç±»å‹ | æ•°é‡ | å•èŠ‚ç‚¹æˆæœ¬ | å°è®¡ | è¯´æ˜ |
|---------|------|-----------|------|------|
| **Core PIN** | 3 | $3,500 | $10,500 | æ ¸å¿ƒèŠ‚ç‚¹ï¼Œé«˜å¯ç”¨ |
| **Auxiliary PIN** | 2 | $2,000 | $4,000 | è¾…åŠ©èŠ‚ç‚¹ |
| **Light PIN** | 0 | $800 | $0 | æš‚ä¸éƒ¨ç½² |
| **ç¡¬ä»¶æ€»è®¡** | 5 | - | **$14,500** | ä¸€æ¬¡æ€§ |

**å¹´è¿è¥æˆæœ¬**ï¼š

| é¡¹ç›® | æœˆæˆæœ¬ | å¹´æˆæœ¬ | è¯´æ˜ |
|------|--------|--------|------|
| **æ‰˜ç®¡è´¹ç”¨** | $750 | $9,000 | 5èŠ‚ç‚¹ Ã— $150/æœˆ |
| **å¸¦å®½è´¹ç”¨** | $500 | $6,000 | 5èŠ‚ç‚¹ Ã— $100/æœˆ |
| **ç”µè´¹** | $250 | $3,000 | 5èŠ‚ç‚¹ Ã— $50/æœˆ |
| **è¿ç»´äººåŠ›** | $1,000 | $12,000 | 1äººå…¼èŒ |
| **æ€»è®¡** | $2,500 | **$30,000** | å¹´è¿è¥æˆæœ¬ |

**5å¹´TCOï¼ˆæ€»æ‹¥æœ‰æˆæœ¬ï¼‰**ï¼š

| å¹´ä»½ | ç¡¬ä»¶ | è¿è¥ | å°è®¡ | ç´¯è®¡ |
|------|------|------|------|------|
| Year 1 | $14,500 | $30,000 | $44,500 | $44,500 |
| Year 2 | $0 | $30,000 | $30,000 | $74,500 |
| Year 3 | $14,500ï¼ˆæ›´æ–°ï¼‰ | $30,000 | $44,500 | $119,000 |
| Year 4 | $0 | $30,000 | $30,000 | $149,000 |
| Year 5 | $0 | $30,000 | $30,000 | $179,000 |

**5å¹´æ€»æˆæœ¬ï¼š$179,000**

**å¯¹æ¯”å…¶ä»–æ–¹æ¡ˆ**ï¼š

| æ–¹æ¡ˆ | 5å¹´æˆæœ¬ | æ•°æ®éšç§ | æ•°æ®æŒä¹…æ€§ | æ¨èåº¦ |
|------|---------|---------|-----------|--------|
| ç§æœ‰IPFS Cluster | $195,000 | âœ… ç§å¯† | âœ… å¯æ§ | â­â­â­â­â­ |
| çº¯å…¬ç½‘+ç¬¬ä¸‰æ–¹PIN | $86,000 | ğŸ”´ å…¬å¼€ | ğŸ”´ ä¸å¯æ§ | â­â­ |
| **å…¬ç½‘+å¤šèŠ‚ç‚¹PINï¼ˆæœ¬æ–¹æ¡ˆï¼‰** | **$179,000** | ğŸ”´ å…¬å¼€ | âœ… å¯æ§ | â­â­â­ |

**æˆæœ¬ä¼˜åŠ¿**ï¼š
- æ¯”ç§æœ‰ç½‘ç»œèŠ‚çœ $16,000ï¼ˆ8%ï¼‰
- æ¯”çº¯å…¬ç½‘+ç¬¬ä¸‰æ–¹PINè´µ $93,000ï¼ˆä½†æ•°æ®æŒä¹…æ€§å¯æ§ï¼‰

---

## ğŸ“‹ å®æ–½æ­¥éª¤

### é˜¶æ®µ1ï¼šåŸºç¡€æ¶æ„éƒ¨ç½²ï¼ˆWeek 1-2ï¼‰

**ä»»åŠ¡æ¸…å•**ï¼š
```
âœ… 1. ç¡¬ä»¶å‡†å¤‡
â”œâ”€ é‡‡è´­3å°CoreèŠ‚ç‚¹æœåŠ¡å™¨
â”œâ”€ é‡‡è´­2å°AuxiliaryèŠ‚ç‚¹æœåŠ¡å™¨
â””â”€ é…ç½®ç½‘ç»œå’Œå­˜å‚¨

âœ… 2. è½¯ä»¶å®‰è£…
â”œâ”€ å®‰è£…Ubuntu 22.04
â”œâ”€ å®‰è£…SubstrateèŠ‚ç‚¹
â”œâ”€ å®‰è£…IPFS Kubo v0.25.0
â””â”€ é…ç½®systemdæœåŠ¡

âœ… 3. IPFSç½‘ç»œé…ç½®
â”œâ”€ è¿æ¥åˆ°å…¬å…±IPFSç½‘ç»œ
â”œâ”€ é…ç½®Peeringï¼ˆèŠ‚ç‚¹é—´ä¼˜å…ˆè¿æ¥ï¼‰
â”œâ”€ æµ‹è¯•DHTè·¯ç”±
â””â”€ éªŒè¯æ•°æ®åŒæ­¥

âœ… 4. èŠ‚ç‚¹æ³¨å†Œ
â”œâ”€ æ³¨å†Œ3ä¸ªCoreèŠ‚ç‚¹ï¼ˆé“¾ä¸Šï¼‰
â”œâ”€ æ³¨å†Œ2ä¸ªAuxiliaryèŠ‚ç‚¹ï¼ˆé“¾ä¸Šï¼‰
â””â”€ åˆ†é…èŠ‚ç‚¹ç±»å‹å’Œå®¹é‡
```

---

### é˜¶æ®µ2ï¼šæ™ºèƒ½PINåˆ†é…å®æ–½ï¼ˆWeek 3-4ï¼‰

**ä»»åŠ¡æ¸…å•**ï¼š
```
âœ… 1. Palletä»£ç å¼€å‘
â”œâ”€ å®ç°æ™ºèƒ½PINåˆ†é…ç®—æ³•
â”œâ”€ å®ç°èŠ‚ç‚¹è¯„åˆ†æœºåˆ¶
â”œâ”€ å®ç°è´Ÿè½½å‡è¡¡é€»è¾‘
â””â”€ å•å…ƒæµ‹è¯•

âœ… 2. OCWé›†æˆ
â”œâ”€ å®ç°æœ¬åœ°IPFS APIè°ƒç”¨
â”œâ”€ å®ç°å¥åº·æ£€æŸ¥é€»è¾‘
â”œâ”€ å®ç°æ•…éšœè½¬ç§»é€»è¾‘
â””â”€ æ— ç­¾åäº¤æ˜“æäº¤

âœ… 3. é“¾ä¸Šæµ‹è¯•
â”œâ”€ éƒ¨ç½²åˆ°æµ‹è¯•ç½‘
â”œâ”€ æµ‹è¯•PINåˆ†é…
â”œâ”€ æµ‹è¯•å¥åº·æ£€æŸ¥
â””â”€ æµ‹è¯•æ•…éšœè½¬ç§»
```

---

### é˜¶æ®µ3ï¼šå¥åº·ç›‘æ§å’Œè‡ªåŠ¨ä¿®å¤ï¼ˆWeek 5-6ï¼‰

**ä»»åŠ¡æ¸…å•**ï¼š
```
âœ… 1. å¥åº·æ£€æŸ¥æœºåˆ¶
â”œâ”€ å®ç°åˆ†å¸ƒå¼å¥åº·æ£€æŸ¥
â”œâ”€ å®ç°å‰¯æœ¬æ•°ç›‘æ§
â”œâ”€ å®ç°è‡ªåŠ¨ä¿®å¤é€»è¾‘
â””â”€ æµ‹è¯•æ•…éšœåœºæ™¯

âœ… 2. å‘Šè­¦ç³»ç»Ÿ
â”œâ”€ å®ç°è´Ÿè½½å‘Šè­¦
â”œâ”€ å®ç°å¥åº·åº¦å‘Šè­¦
â”œâ”€ å®ç°å®¹é‡å‘Šè­¦
â””â”€ é›†æˆé€šçŸ¥æ¸ é“ï¼ˆEmail/Slackï¼‰

âœ… 3. ç›‘æ§Dashboard
â”œâ”€ å®ç°èŠ‚ç‚¹çŠ¶æ€ç›‘æ§é¡µé¢
â”œâ”€ å®ç°PINåˆ†é…å¯è§†åŒ–
â”œâ”€ å®ç°å¥åº·åº¦è¶‹åŠ¿å›¾
â””â”€ å®ç°å‘Šè­¦æ—¥å¿—
```

---

### é˜¶æ®µ4ï¼šç”Ÿäº§ç¯å¢ƒéƒ¨ç½²ï¼ˆWeek 7-8ï¼‰

**ä»»åŠ¡æ¸…å•**ï¼š
```
âœ… 1. ç”Ÿäº§ç¯å¢ƒå‡†å¤‡
â”œâ”€ é…ç½®é˜²ç«å¢™è§„åˆ™
â”œâ”€ é…ç½®TLSè¯ä¹¦
â”œâ”€ é…ç½®å¤‡ä»½ç­–ç•¥
â””â”€ é…ç½®ç›‘æ§å‘Šè­¦

âœ… 2. æ•°æ®è¿ç§»ï¼ˆå¦‚æœ‰ï¼‰
â”œâ”€ ä»æ—§ç³»ç»Ÿå¯¼å‡ºCIDåˆ—è¡¨
â”œâ”€ æ‰¹é‡Pinåˆ°æ–°ç³»ç»Ÿ
â”œâ”€ éªŒè¯æ•°æ®å®Œæ•´æ€§
â””â”€ åˆ‡æ¢æµé‡

âœ… 3. è¿è¥åŸ¹è®­
â”œâ”€ èŠ‚ç‚¹è¿ç»´æ‰‹å†Œ
â”œâ”€ æ•…éšœæ’æŸ¥æŒ‡å—
â”œâ”€ æ‰©å®¹æ“ä½œæ‰‹å†Œ
â””â”€ åº”æ€¥å“åº”æµç¨‹
```

---

## ğŸ¯ æœ€ä¼˜æ–¹æ¡ˆç‰¹æ€§æ€»ç»“

### æ ¸å¿ƒä¼˜åŠ¿

1. **é«˜å¯ç”¨æ€§**ï¼šâ­â­â­â­â­
   - å¤šèŠ‚ç‚¹åˆ†å¸ƒå¼PINï¼ˆ5å‰¯æœ¬Criticalæ•°æ®ï¼‰
   - è‡ªåŠ¨æ•…éšœè½¬ç§»
   - å•èŠ‚ç‚¹æ•…éšœä¸å½±å“æœåŠ¡

2. **æ•°æ®æŒä¹…æ€§**ï¼šâ­â­â­â­â­
   - 100%é¡¹ç›®æ–¹æ§åˆ¶
   - ä¸ä¾èµ–ç¬¬ä¸‰æ–¹PINæœåŠ¡
   - é“¾ä¸Šå…±è¯†ä¿è¯åˆ†é…ç­–ç•¥

3. **æ™ºèƒ½è´Ÿè½½å‡è¡¡**ï¼šâ­â­â­â­â­
   - åŸºäºå®¹é‡ã€è´Ÿè½½ã€å¥åº·åº¦çš„æ™ºèƒ½åˆ†é…
   - è‡ªåŠ¨é¿å…è¿‡è½½èŠ‚ç‚¹
   - æ”¯æŒåŠ¨æ€æ‰©å®¹

4. **æˆæœ¬ä¼˜åŒ–**ï¼šâ­â­â­â­
   - æ¯”ç§æœ‰ç½‘ç»œèŠ‚çœ8%
   - åˆ†å±‚å­˜å‚¨ï¼ˆæŒ‰PinTierä¼˜åŒ–ï¼‰
   - è½»é‡èŠ‚ç‚¹å¯é€‰ï¼ˆç¤¾åŒºè´¡çŒ®ï¼‰

5. **ç›‘æ§å’Œè‡ªåŠ¨åŒ–**ï¼šâ­â­â­â­â­
   - åˆ†å¸ƒå¼å¥åº·æ£€æŸ¥
   - è‡ªåŠ¨ä¿®å¤å’Œæ•…éšœè½¬ç§»
   - å®æ—¶å‘Šè­¦

### æ ¸å¿ƒåŠ£åŠ¿

1. **æ•°æ®éšç§é£é™©**ï¼šğŸ”´ğŸ”´ğŸ”´
   - æ•°æ®ä¾ç„¶å…¬å¼€ï¼ˆå…¬å…±IPFSç‰¹æ€§ï¼‰
   - æ— æ³•çœŸæ­£ä¿æŠ¤æ•æ„Ÿæ•°æ®
   - æ³•å¾‹åˆè§„é£é™©

2. **è¿ç»´å¤æ‚åº¦**ï¼šğŸŸ¡
   - éœ€è¦ç®¡ç†å¤šä¸ªèŠ‚ç‚¹
   - éœ€è¦ç›‘æ§å’Œç»´æŠ¤IPFSç½‘ç»œ
   - éœ€è¦åº”æ€¥å“åº”æœºåˆ¶

---

## ğŸ’¡ æœ€ç»ˆå»ºè®®

### é€‚ç”¨åœºæ™¯

âœ… **æ¨èä½œä¸ºæ··åˆæ¶æ„çš„ä¸€éƒ¨åˆ†**ï¼š
```
åŒIPFSæ··åˆæ¶æ„ï¼ˆæœ€ä¼˜æ–¹æ¡ˆï¼‰ï¼š

IPFS Daemon 1ï¼ˆç§æœ‰ç½‘ç»œï¼‰- 70%æ•°æ®
â”œâ”€ è¯æ®ã€æ¡£æ¡ˆã€ç…§ç‰‡
â”œâ”€ Swarm Keyéš”ç¦»
â”œâ”€ ç¡®ä¿éšç§å’Œåˆè§„
â””â”€ æ¯ä¸ªèŠ‚ç‚¹è¿è¡Œ

IPFS Daemon 2ï¼ˆå…¬å…±ç½‘ç»œï¼‰- 30%æ•°æ®
â”œâ”€ å…¬å‘Šã€å‰ç«¯èµ„æº
â”œâ”€ ç”¨æˆ·æˆæƒå…¬å¼€çš„ä¾›å¥‰å“
â”œâ”€ ä½¿ç”¨æœ¬æ–¹æ¡ˆï¼ˆå…¬ç½‘+å¤šèŠ‚ç‚¹PINï¼‰
â””â”€ æ™ºèƒ½åˆ†é…å’Œè´Ÿè½½å‡è¡¡
```

### å®æ–½è·¯çº¿

**é˜¶æ®µ1ï¼ˆ0-3ä¸ªæœˆï¼‰**ï¼š100%ç§æœ‰IPFS
- ç¡®ä¿æ•°æ®å®‰å…¨å’Œåˆè§„

**é˜¶æ®µ2ï¼ˆ3-6ä¸ªæœˆï¼‰**ï¼š90%ç§æœ‰ + 10%å…¬ç½‘
- å…¬å‘Šå’Œå‰ç«¯èµ„æºä½¿ç”¨æœ¬æ–¹æ¡ˆ

**é˜¶æ®µ3ï¼ˆ6-12ä¸ªæœˆï¼‰**ï¼š70%ç§æœ‰ + 30%å…¬ç½‘
- ç”¨æˆ·æˆæƒå…¬å¼€çš„ä¾›å¥‰å“ä½¿ç”¨æœ¬æ–¹æ¡ˆ

---

<div align="center">

## ğŸ¯ æ ¸å¿ƒç»“è®º

### æŠ€æœ¯å¯è¡Œæ€§ï¼šâ­â­â­â­â­ï¼ˆå®Œå…¨å¯è¡Œï¼‰
**æ™ºèƒ½PINåˆ†é…ã€è‡ªåŠ¨è´Ÿè½½å‡è¡¡ã€åˆ†å¸ƒå¼å¥åº·æ£€æŸ¥ï¼ŒæŠ€æœ¯æ¶æ„æˆç†Ÿ**

### ä¸šåŠ¡åˆç†æ€§ï¼šâ­â­â­ï¼ˆæœ‰é‡å¤§é—®é¢˜ï¼‰
**æ•°æ®éšç§é£é™©è‡´å‘½ï¼Œä»…é€‚åˆå…¬å¼€æ•°æ®ï¼ˆ30%ï¼‰**

---

### âœ… æœ€ä¼˜æ–¹æ¡ˆï¼šåŒIPFSæ··åˆæ¶æ„

**70%ç§æœ‰IPFS** + **30%å…¬ç½‘åˆ†å¸ƒå¼PINï¼ˆæœ¬æ–¹æ¡ˆï¼‰**

**ä¼˜åŠ¿**ï¼š
- âœ… æ•æ„Ÿæ•°æ®100%ç§æœ‰ï¼ˆéšç§ä¿æŠ¤ï¼‰
- âœ… å…¬å¼€æ•°æ®é«˜å¯ç”¨æ€§ï¼ˆ5å‰¯æœ¬ï¼‰
- âœ… æ™ºèƒ½è´Ÿè½½å‡è¡¡ï¼ˆè‡ªåŠ¨ä¼˜åŒ–ï¼‰
- âœ… æ•°æ®æŒä¹…æ€§100%å¯æ§ï¼ˆä¸ä¾èµ–ç¬¬ä¸‰æ–¹ï¼‰
- âœ… æˆæœ¬èŠ‚çœ8%ï¼ˆæ¯”çº¯ç§æœ‰ï¼‰

**æˆæœ¬**ï¼š~$179,000/5å¹´

---

**æ ¸å¿ƒåŸåˆ™**ï¼š
- **éšç§ä¼˜å…ˆ**ï¼šæ•æ„Ÿæ•°æ®æ°¸è¿œç§æœ‰
- **æ™ºèƒ½åˆ†é…**ï¼šæŒ‰PinTierå’ŒèŠ‚ç‚¹å®¹é‡åŠ¨æ€åˆ†é…
- **è‡ªåŠ¨åŒ–**ï¼šå¥åº·æ£€æŸ¥å’Œæ•…éšœè½¬ç§»è‡ªåŠ¨åŒ–
- **å¯æ‰©å±•**ï¼šæ”¯æŒåŠ¨æ€æ·»åŠ èŠ‚ç‚¹

</div>

