# 供奉与亲友团关系设计分析文档

**创建日期**：2025-11-09
**文档版本**：v1.0
**问题**：供奉的目标是Grave（墓位），但AutoJoinedFriend加入的是Deceased（逝者）的亲友团，这个设计是否合理？

---

## 一、核心问题分析

### 1.1 表面矛盾

- **供奉接口**：`offer(grave_id, ...)` - 参数是墓位ID
- **亲友团加入**：`FriendsOf<(DeceasedId, AccountId)>` - 亲友团关联到逝者
- **事件**：`AutoJoinedFriend { deceased_id, who }` - 自动加入逝者亲友团

**直觉疑问**：为什么供奉墓位，却加入逝者的亲友团？

### 1.2 实际逻辑

**关键代码**：`runtime/src/configs/mod.rs:1187-1214`

```rust
// 供奉到墓位时，自动将供奉者加入墓位关联的所有逝者的亲友团
if target.0 == 0 {  // domain=0 是 Grave
    let grave_id: u64 = target.1;

    // 🔑 关键步骤：查询该墓位关联的所有逝者
    if let Some(deceased_ids) = pallet_deceased::DeceasedByGrave::<Runtime>::get(grave_id) {
        for deceased_id in deceased_ids {
            // 检查是否已是亲友团成员
            if !pallet_deceased::FriendsOf::<Runtime>::contains_key(deceased_id, who) {
                // 插入到该逝者的亲友团
                pallet_deceased::FriendsOf::<Runtime>::insert(deceased_id, who, friend_record);
                // 更新计数
                pallet_deceased::FriendCount::<Runtime>::insert(deceased_id, count + 1);
                // 发送事件
                pallet_deceased::Pallet::<Runtime>::deposit_event(
                    pallet_deceased::Event::AutoJoinedFriend { deceased_id, who }
                );
            }
        }
    }
}
```

**核心逻辑**：
1. 用户供奉 Grave #123
2. 系统查询 Grave #123 关联的所有逝者（如：[Deceased #1, Deceased #2]）
3. 将供奉者**批量加入**到每个逝者的亲友团
4. 为每个加入操作发送 `AutoJoinedFriend` 事件

---

## 二、设计合理性分析

### 2.1 为什么供奉目标是Grave？

#### ✅ 业务合理性

1. **现实场景对应**
   - 现实中，人们去墓地扫墓，供奉的是"墓碑"
   - 墓碑是一个物理实体，可能安葬多人（合葬）
   - 用户直觉：我去某个墓位供奉

2. **前端体验友好**
   - 用户在墓位详情页点击"供奉"按钮
   - 传入 `grave_id` 参数更直观
   - 无需用户选择供奉墓位中的哪个逝者

3. **合葬场景简化**
   - 一个墓位可能安葬多个逝者（夫妻、家族墓）
   - 如果供奉目标是Deceased，用户需要多次操作
   - 供奉墓位 = 一次性供奉所有逝者

#### 业务映射

```
用户操作：供奉墓位
↓
真实意图：纪念安葬在此的所有逝者
↓
系统行为：加入所有逝者的亲友团
```

### 2.2 为什么加入的是Deceased的亲友团？

#### ✅ 数据结构合理性

根据前文《亲友团成员归属方案设计文档》的结论：
- 亲友团关联到Deceased（逝者），不是Grave（墓位）
- 原因：
  1. 符合现实认知（逝者的亲友）
  2. 数据稳定性（逝者迁移时关系跟随）
  3. 合葬场景（每个逝者独立亲友团）

#### ✅ 供奉语义合理性

**供奉的真实含义**：
- 用户供奉墓位，实际是在纪念逝者
- 供奉行为表达了对逝者的纪念和尊重
- 供奉者应该成为逝者的亲友，而不是墓位的访客

**逻辑推导**：
```
供奉墓位 → 表达对逝者的纪念 → 成为逝者的亲友
```

### 2.3 自动加入机制的合理性

#### ✅ 经济门槛

- 供奉需要支付 DUST 代币（最低金额）
- 防止恶意刷亲友团
- 供奉 = 真实的纪念行为 = 有资格成为亲友

#### ✅ 用户体验

- 无需手动申请加入亲友团
- 供奉后自动建立纪念关系
- 简化操作流程

#### ✅ 业务联动

- 供奉是15级推荐分佣的触发点（affiliate系统）
- 加入亲友团可以收到逝者相关的通知
- 形成闭环：供奉 → 亲友 → 持续关注 → 再次供奉

---

## 三、设计方案对比

### 方案A（当前方案）：供奉Grave → 加入所有Deceased亲友团

**优点**：
- ✅ 前端体验友好（一次供奉，自动关联）
- ✅ 合葬场景友好（自动加入所有逝者）
- ✅ 语义合理（供奉墓位实际是纪念逝者）
- ✅ 经济门槛防刷（需要支付MEMO）

**缺点**：
- ⚠️  用户无法选择只供奉墓位中的某个逝者
- ⚠️  合葬墓位会批量加入多个亲友团

### 方案B（备选）：供奉Deceased → 加入该Deceased亲友团

**优点**：
- ✅ 精确控制（用户指定供奉哪个逝者）
- ✅ 数据关系清晰（1:1对应）

**缺点**：
- ❌ 前端体验复杂（墓位详情页需要选择逝者）
- ❌ 合葬场景繁琐（需要多次供奉）
- ❌ API破坏式变更（当前已实施方案A）

### 方案C（折中）：供奉时可选择Grave或Deceased

**优点**：
- ✅ 灵活性最高
- ✅ 兼容两种场景

**缺点**：
- ❌ 系统复杂度增加
- ❌ 前端需要两套UI逻辑
- ❌ 用户选择困难（多数用户不理解区别）

---

## 四、典型场景分析

### 场景1：单人墓位

```
Grave #1
└─ Deceased #10（张三）
```

**用户行为**：供奉 Grave #1

**系统行为**：
1. 查询 Grave #1 的逝者列表 → [Deceased #10]
2. 将供奉者加入 Deceased #10 的亲友团
3. 发送事件：`AutoJoinedFriend { deceased_id: 10, who: 供奉者 }`

**结果**：供奉者成为张三的亲友

**合理性**：✅ 完全合理，符合直觉

---

### 场景2：夫妻合葬墓位

```
Grave #2
├─ Deceased #20（李四，丈夫）
└─ Deceased #21（王五，妻子）
```

**用户行为**：供奉 Grave #2

**系统行为**：
1. 查询 Grave #2 的逝者列表 → [Deceased #20, Deceased #21]
2. 将供奉者加入 Deceased #20 的亲友团
3. 将供奉者加入 Deceased #21 的亲友团
4. 发送事件：
   - `AutoJoinedFriend { deceased_id: 20, who: 供奉者 }`
   - `AutoJoinedFriend { deceased_id: 21, who: 供奉者 }`

**结果**：供奉者同时成为李四和王五的亲友

**合理性分析**：

#### ✅ 合理之处
1. **现实场景对应**：现实中供奉合葬墓，确实是同时纪念两人
2. **用户体验简化**：一次操作，完成对两人的纪念
3. **关系建立自然**：如果用户供奉了合葬墓，说明对两人都有纪念之情

#### ⚠️  潜在问题
1. **用户可能只想纪念其中一人**
   - 例如：供奉者是丈夫的朋友，但不认识妻子
   - 却被自动加入妻子的亲友团

2. **亲友团计数膨胀**
   - 合葬墓位供奉量大时，每个逝者的亲友团都会快速增长
   - 可能导致真实亲友被海量供奉者淹没

#### 💡 建议优化方案

**方案2.1：前端选择供奉对象**

在墓位详情页显示所有逝者，用户可选择供奉哪个：

```tsx
<GraveDetailPage graveId={2}>
  <div>合葬逝者：</div>
  <DeceasedCard deceased={李四}>
    <Button onClick={() => offer(grave_id, deceased_id: 20)}>
      供奉李四
    </Button>
  </DeceasedCard>
  <DeceasedCard deceased={王五}>
    <Button onClick={() => offer(grave_id, deceased_id: 21)}>
      供奉王五
    </Button>
  </DeceasedCard>
  <Button onClick={() => offer(grave_id)}>
    供奉整个墓位（所有逝者）
  </Button>
</GraveDetailPage>
```

**方案2.2：链上新增指定逝者供奉**

```rust
// 新增接口：供奉墓位中的指定逝者
#[pallet::call_index(16)]
pub fn offer_to_deceased(
    origin: OriginFor<T>,
    grave_id: u64,
    deceased_id: u64,  // 新增：指定逝者
    kind_code: u8,
    // ...
) -> DispatchResult
```

**方案2.3：保持当前设计，文档明确说明**

在前端提示用户：
```
供奉此墓位将自动成为以下逝者的亲友：
- 李四（丈夫）
- 王五（妻子）

确认供奉？ [是] [否]
```

---

### 场景3：家族墓（多人合葬）

```
Grave #3（张氏家族墓）
├─ Deceased #30（爷爷）
├─ Deceased #31（奶奶）
├─ Deceased #32（父亲）
└─ Deceased #33（母亲）
```

**用户行为**：供奉 Grave #3

**系统行为**：将供奉者加入4个逝者的亲友团

**合理性分析**：

#### ✅ 合理之处
- 家族墓供奉通常是纪念整个家族
- 自动加入所有逝者符合业务语义

#### ⚠️  潜在问题
- 供奉者可能只认识其中一代人
- 被加入4个亲友团，可能不符合真实关系

#### 💡 建议
- 对于大型合葬墓（>3人），强烈建议实施**方案2.1**或**方案2.2**
- 允许用户选择供奉特定逝者

---

## 五、技术实现细节

### 5.1 当前实现流程

```
1. 前端调用：api.tx.memorial.offer(grave_id, ...)
   ↓
2. Memorial Pallet：扣费、记录供奉
   ↓
3. 触发回调：T::OnOfferingCommitted::on_offering(target=(0, grave_id), ...)
   ↓
4. MemorialOfferingHook::on_offering()
   ↓
5. 查询：DeceasedByGrave::get(grave_id) → [deceased_ids]
   ↓
6. 遍历所有逝者，逐个加入亲友团：
   for deceased_id in deceased_ids {
       FriendsOf::insert(deceased_id, who, friend_record);
       FriendCount::insert(deceased_id, count + 1);
       emit AutoJoinedFriend { deceased_id, who };
   }
```

### 5.2 关键数据结构

**Grave → Deceased 索引**：
```rust
// pallets/deceased/src/lib.rs
pub type DeceasedByGrave<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::GraveId,
    Vec<T::DeceasedId>,  // ⚠️  关键：一个墓位可以有多个逝者
    OptionQuery,
>;
```

**Deceased → Friends 索引**：
```rust
pub type FriendsOf<T: Config> = StorageDoubleMap<
    _,
    Blake2_128Concat, T::DeceasedId,  // 第一维：逝者ID
    Blake2_128Concat, T::AccountId,   // 第二维：账户地址
    FriendRecord<T>,
>;
```

### 5.3 事件系统

```rust
// pallets/deceased/src/lib.rs:712-715
AutoJoinedFriend {
    deceased_id: T::DeceasedId,
    who: T::AccountId,
},
```

**事件特点**：
- 每个逝者加入都会触发独立事件
- 合葬墓位会触发多个事件
- 前端可以监听此事件更新亲友列表

---

## 六、优化建议

### 6.1 短期优化（低成本）

#### 1. 文档完善

在前端显示明确提示：

```tsx
{deceased_count > 1 && (
  <Alert type="info">
    此墓位安葬了 {deceased_count} 位逝者，
    供奉后您将自动成为所有逝者的亲友。
  </Alert>
)}
```

#### 2. 前端选择供奉对象（推荐）

在墓位详情页提供逝者列表，允许用户选择：

```tsx
<Select placeholder="选择供奉对象">
  <Option value="all">供奉整个墓位（所有逝者）</Option>
  {deceased_list.map(d => (
    <Option value={d.id}>仅供奉 {d.name}</Option>
  ))}
</Select>
```

**实现方式**：
- 前端选择逝者后，仍然调用 `offer(grave_id, ...)`
- 在 `media` 参数中附加逝者筛选信息（hack方式）
- 或者新增 `offer_to_deceased(grave_id, deceased_id, ...)` 接口

### 6.2 中期优化（适度改动）

#### 新增精确供奉接口

```rust
#[pallet::call_index(16)]
pub fn offer_to_deceased(
    origin: OriginFor<T>,
    grave_id: u64,
    deceased_id: u64,  // 指定逝者
    kind_code: u8,
    media: Vec<BoundedVec<u8, T::MaxCidLen>>,
    duration: Option<u32>,
) -> DispatchResult {
    let who = ensure_signed(origin)?;

    // 验证逝者确实在该墓位中
    let deceased_ids = pallet_deceased::DeceasedByGrave::<T>::get(grave_id)
        .ok_or(Error::<T>::GraveNotFound)?;
    ensure!(
        deceased_ids.contains(&deceased_id),
        Error::<T>::DeceasedNotInGrave
    );

    // 构建target：仍然使用Grave domain
    let target = (0u8, grave_id);

    // ... 原有供奉逻辑 ...

    // 回调时传递指定的deceased_id
    T::OnOfferingCommitted::on_offering_to_specific_deceased(
        target,
        deceased_id,  // 明确指定
        kind_code,
        &who,
        amount,
        duration_weeks,
    );

    Ok(())
}
```

**优点**：
- 用户可以精确控制
- 不破坏现有逻辑
- 两种接口并存

**缺点**：
- 增加系统复杂度
- 前端需要判断使用哪个接口

### 6.3 长期优化（未来扩展）

#### 亲友团分级

```rust
pub enum FriendSource {
    ManualJoin,      // 手动申请加入
    OfferingAuto,    // 供奉自动加入
    Invited,         // 被邀请加入
}

pub struct FriendRecord<T: Config> {
    pub role: FriendRole,
    pub source: FriendSource,  // 新增：加入来源
    pub since: BlockNumberFor<T>,
    pub note: BoundedVec<u8, T::StringLimit>,
}
```

**前端展示**：
```
亲友团（共156人）
├─ 核心亲友（5人）
├─ 手动加入（20人）
└─ 供奉者（131人）  ← 可折叠显示
```

**优点**：
- 区分真实亲友和供奉者
- 防止供奉者淹没真实关系
- 更符合实际业务需求

---

## 七、结论

### 7.1 当前设计的合理性评价

#### ✅ 合理之处（80分）

1. **业务语义清晰**
   - 供奉墓位 = 纪念逝者 ✅
   - 纪念逝者 = 成为亲友 ✅
   - 合葬墓位 = 同时纪念多人 ✅

2. **用户体验友好**
   - 一次供奉，自动建立关系 ✅
   - 无需手动申请加入亲友团 ✅
   - 操作简单直观 ✅

3. **技术实现合理**
   - 通过索引查询关联逝者 ✅
   - 批量插入亲友关系 ✅
   - 事件系统完整 ✅

4. **经济门槛有效**
   - 防止恶意刷亲友团 ✅
   - 供奉行为有真实成本 ✅

#### ⚠️  潜在问题（20分扣除）

1. **合葬场景的精细度不足**
   - 无法选择只供奉某个逝者 (-10分)
   - 大型家族墓会批量加入多个亲友团 (-5分)

2. **亲友团混合问题**
   - 真实亲友和供奉者混在一起 (-5分)
   - 供奉量大时，真实关系被淹没

### 7.2 最终建议

#### 立即实施（P0）

1. **文档完善**
   - 在README中明确说明供奉逻辑
   - 在前端显示合葬提示

#### 短期实施（P1）

2. **前端优化**
   - 墓位详情页显示所有逝者列表
   - 允许用户选择供奉对象（单个/全部）
   - 提示"供奉整个墓位将成为X位逝者的亲友"

#### 中期优化（P2）

3. **新增精确供奉接口**
   - `offer_to_deceased(grave_id, deceased_id, ...)`
   - 兼容现有 `offer(grave_id, ...)`

#### 长期优化（P3）

4. **亲友团分级展示**
   - 区分核心亲友、手动加入、供奉者
   - 前端可折叠/筛选显示

---

## 八、答案总结

### 问题：供奉Grave但加入Deceased亲友团，是否合理？

**答案：✅ 整体合理，但有优化空间**

**合理性理由**：
1. 供奉墓位的真实语义是纪念逝者
2. 墓位是容器，逝者是内容，纪念行为指向内容
3. 合葬场景下，供奉墓位 = 同时纪念所有逝者
4. 自动加入机制简化用户操作
5. 经济门槛防止恶意刷亲友

**优化建议**：
1. 前端提示用户供奉墓位会加入哪些逝者的亲友团
2. 允许用户选择供奉墓位中的特定逝者（推荐）
3. 未来可以通过亲友来源标识区分真实亲友和供奉者

**设计决策依据**：
- 单人墓位：100%合理
- 夫妻合葬：80%合理（多数情况符合直觉）
- 家族墓：60%合理（建议允许选择特定逝者）

---

**文档作者**：Claude
**审阅建议**：产品团队 + 开发团队
**实施状态**：✅ 当前方案已在链上实施，建议前端优化用户选择体验
