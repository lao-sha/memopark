# 买家信用 - 冷却期与解禁机制说明

**日期**: 2025-10-21  
**模块**: `pallet-buyer-credit`  
**主题**: 冷却期概念澄清 + 解禁逻辑分析

---

## 一、当前冷却期机制

### 1.1 冷却期时长规则

```rust
fn calculate_cooldown_period(buyer: &T::AccountId) -> BlockNumberFor<T> {
    let recent_defaults = Self::count_recent_defaults(buyer, 30);  // 统计30天内违约次数
    
    let cooldown_days: u32 = match recent_defaults {
        0 => 0,      // 无违约：无冷却期
        1 => 1,      // 1次违约：冷却1天
        2 => 3,      // 2次违约：冷却3天
        3 => 7,      // 3次违约：冷却7天
        4 => 14,     // 4次违约：冷却14天
        _ => 30,     // 5+次违约：冷却30天
    };
    
    T::BlocksPerDay::get().saturating_mul(cooldown_days.into())
}
```

**关键点**：
- 冷却期基于 **30天内** 的违约次数计算
- 冷却期是 **累积递增** 的

---

### 1.2 永久封禁机制

```rust
pub fn penalize_default(buyer: &T::AccountId) {
    // 统计 7天内 的连续违约次数
    let consecutive_defaults = Self::count_recent_defaults(buyer, 7);
    
    BuyerCredit::<T>::mutate(buyer, |credit| {
        // ... 惩罚逻辑 ...
        
        // 🔴 7天内连续违约 ≥ 3次，直接封禁
        if consecutive_defaults >= 3 {
            credit.risk_score = 1000; // 设置为最高风险分，永久封禁
            
            Self::deposit_event(Event::UserBanned {
                account: buyer.clone(),
                reason: b"7 days consecutive 3 defaults".to_vec().try_into().unwrap_or_default(),
            });
        }
    });
}
```

**关键点**：
- 永久封禁基于 **7天内** 的连续违约次数（≥3次）
- 永久封禁设置 `risk_score = 1000`

---

## 二、概念澄清

### 2.1 "临时、长期、超长"的准确定义

| 分类 | 冷却期时长 | 违约次数（30天内） | 是否永久封禁 | 能否解禁 |
|------|-----------|-------------------|-------------|---------|
| **无冷却** | 0天 | 0次 | ❌ 否 | - |
| **临时封禁** | 1天 | 1次 | ❌ 否 | ✅ **1天后自动解除** |
| **短期封禁** | 3天 | 2次 | ❌ 否 | ✅ **3天后自动解除** |
| **中期封禁** | 7天 | 3次 | ⚠️ **取决于7天内是否≥3次** | ✅ **7天后自动解除（如未永久封禁）** |
| **长期封禁** | 14天 | 4次 | ⚠️ **取决于7天内是否≥3次** | ✅ **14天后自动解除（如未永久封禁）** |
| **超长封禁** | 30天 | 5+次 | ⚠️ **取决于7天内是否≥3次** | ✅ **30天后自动解除（如未永久封禁）** |
| **永久封禁** | - | - | ✅ **是（7天内≥3次）** | ❌ **无法自动解除** |

---

### 2.2 两种封禁机制的区别

#### 封禁类型 A：冷却期封禁（临时）

**特征**：
- ✅ **可自动解除**
- ✅ 基于最后一次违约的时间计算
- ✅ 冷却期结束后，用户可继续下单

**检查逻辑**：
```rust
// 在 check_buyer_limit 函数中
if credit.default_count > 0 {
    let cooldown_blocks = Self::calculate_cooldown_period(buyer);
    if !cooldown_blocks.is_zero() {
        let current_block = <frame_system::Pallet<T>>::block_number();
        let last_default_block = DefaultHistory::<T>::get(buyer)
            .last()
            .copied()
            .unwrap_or(Zero::zero());
        let required_block = last_default_block.saturating_add(cooldown_blocks);
        
        // 检查是否已过冷却期
        ensure!(current_block >= required_block, Error::<T>::InDefaultCooldown);
    }
}
```

**解禁条件**：
```
当前区块号 >= 最后违约区块号 + 冷却期区块数
```

**示例**：
- 用户在第 10000 区块违约（第1次）
- 冷却期：1天 = 14400 区块（假设每区块6秒）
- 解禁区块：10000 + 14400 = 24400
- **第 24400 区块后，用户可继续下单**

---

#### 封禁类型 B：永久封禁（风险分封禁）

**特征**：
- ❌ **无法自动解除**
- ❌ 风险分 = 1000（> 800）
- ❌ 无时间限制，永久生效

**检查逻辑**：
```rust
// 在 check_buyer_limit 函数中（优先级更高）
// 检查信用分（风险分 > 800 禁止交易）
ensure!(credit.risk_score <= 800, Error::<T>::CreditScoreTooLow);
```

**触发条件**：
```
7天内连续违约 ≥ 3次 → risk_score = 1000
```

**解禁条件**：
- 🔴 **当前无自动解禁机制**
- 可选方案：
  1. 治理手动解封（需要实现 Root extrinsic）
  2. 风险分恢复机制（后文详述）

---

## 三、关键疑问解答

### 疑问 1：30天后是否可以解禁？

**答案**：**取决于封禁类型**

#### 场景 A：仅冷却期封禁（未触发永久封禁）

**示例**：用户在30天内违约5次，但**不是在7天内连续3次**

- 第1天：违约1次
- 第8天：违约1次
- 第15天：违约1次
- 第22天：违约1次
- 第29天：违约1次

**结果**：
- ✅ 冷却期：30天（5次违约）
- ✅ 风险分：400 + 30×5 = 550（未超过800）
- ✅ **30天后可以自动解除冷却期**
- ✅ 用户可继续下单

---

#### 场景 B：触发永久封禁

**示例**：用户在7天内连续违约3次

- 第1天：违约1次
- 第3天：违约1次
- 第5天：违约1次（第3次）

**结果**：
- 🔴 风险分：1000（永久封禁）
- 🔴 冷却期：7天（但实际无效，因为风险分已封禁）
- 🔴 **7天后冷却期结束，但风险分仍为1000**
- ❌ **30天后、60天后、永远都无法自动解除**

---

### 疑问 2："临时、长期、超长"的命名是否准确？

**当前命名问题**：
- ⚠️ "临时封禁（7天）"实际上可能是 **永久封禁**（如果7天内违约≥3次）
- ⚠️ "长期封禁（14天）"也可能是 **永久封禁**
- ⚠️ "超长封禁（30天）"也可能是 **永久封禁**

**建议修正命名**：

| 冷却期 | 原命名 | **建议命名** | 说明 |
|--------|--------|-------------|------|
| 1天 | 临时封禁 | **轻微冷却** | 明确是冷却期，非封禁 |
| 3天 | - | **短期冷却** | - |
| 7天 | 临时封禁 | **中期冷却** | - |
| 14天 | 长期封禁 | **长期冷却** | 强调是冷却期 |
| 30天 | 超长封禁 | **超长冷却** | 强调是冷却期 |
| 永久 | - | **永久封禁** | 风险分=1000，无法自动解除 |

---

## 四、当前机制的逻辑梳理

### 4.1 双重检查机制

用户每次下单时，会依次通过两层检查：

#### 检查 1：风险分检查（优先级最高）

```rust
// 检查信用分（风险分 > 800 禁止交易）
ensure!(credit.risk_score <= 800, Error::<T>::CreditScoreTooLow);
```

**结果**：
- 如果 `risk_score > 800`（如永久封禁=1000）
- ❌ **立即拒绝，不再检查冷却期**

---

#### 检查 2：冷却期检查（次优先级）

```rust
// 检查违约冷却期
if credit.default_count > 0 {
    let cooldown_blocks = Self::calculate_cooldown_period(buyer);
    // ...
    ensure!(current_block >= required_block, Error::<T>::InDefaultCooldown);
}
```

**结果**：
- 如果在冷却期内
- ❌ **拒绝，返回 InDefaultCooldown**
- 如果冷却期已过
- ✅ **允许下单**

---

### 4.2 完整流程图

```
用户尝试下单
    ↓
风险分检查（risk_score <= 800?）
    ├─ 否（> 800）→ ❌ 返回 CreditScoreTooLow（永久封禁，无法解除）
    └─ 是（<= 800）→ 继续
           ↓
冷却期检查（是否有违约记录?）
    ├─ 否（default_count = 0）→ ✅ 允许下单
    └─ 是（default_count > 0）→ 计算冷却期
           ↓
当前区块 >= 解封区块?
    ├─ 否（仍在冷却期）→ ❌ 返回 InDefaultCooldown（临时封禁，可自动解除）
    └─ 是（冷却期已过）→ ✅ 允许下单
```

---

## 五、存在的问题与改进建议

### 问题 1：永久封禁无恢复机制

**当前状态**：
- 用户一旦触发永久封禁（风险分=1000）
- ❌ **无法通过任何方式恢复**
- ❌ 即使等待30天、60天、1年都无法解除

**影响**：
- ⚠️ 对于正常用户偶尔失误（如网络问题连续超时）过于严厉
- ⚠️ 无法给予用户改过自新的机会

---

### 问题 2：冷却期和永久封禁的边界模糊

**示例**：
- 用户在30天内违约3次，但不在7天内
- 冷却期：7天
- 风险分：400 + 30 + 60 + 120 = 610（未永久封禁）
- **7天后可解除**

**对比**：
- 用户在7天内违约3次
- 冷却期：7天
- 风险分：1000（永久封禁）
- **7天后仍无法解除**

**问题**：
- ⚠️ 相同的"7天冷却期"，一个可解除，一个永久封禁
- ⚠️ 用户难以理解规则

---

## 六、改进方案

### 方案 A：风险分自然衰减机制（推荐）

**核心思路**：
- 风险分随时间自然下降
- 即使触发永久封禁（risk_score=1000），经过足够长时间也能恢复

**实施方案**：

#### 1. 风险分衰减规则

```rust
/// 函数级中文注释：计算风险分衰减
/// 
/// # 衰减规则
/// - 每30天未违约，风险分降低 50分
/// - 最低不低于初始风险分
fn calculate_risk_decay(buyer: &T::AccountId) -> u16 {
    let credit = BuyerCredit::<T>::get(buyer);
    
    // 如果没有违约记录，不衰减
    if credit.default_count == 0 {
        return 0;
    }
    
    let current_block = <frame_system::Pallet<T>>::block_number();
    let last_default_block = DefaultHistory::<T>::get(buyer)
        .last()
        .copied()
        .unwrap_or(Zero::zero());
    
    let blocks_since_last_default = current_block.saturating_sub(last_default_block);
    let blocks_per_30_days = T::BlocksPerDay::get().saturating_mul(30u32.into());
    
    // 计算经过了多少个30天周期
    let decay_cycles = blocks_since_last_default / blocks_per_30_days;
    
    // 每个周期衰减50分
    let decay_amount = decay_cycles.saturated_into::<u16>().saturating_mul(50);
    
    decay_amount
}

/// 函数级中文注释：检查买家限额（含风险分衰减）
pub fn check_buyer_limit(buyer: &T::AccountId, amount_usdt: u64) -> Result<(), Error<T>> {
    let mut credit = BuyerCredit::<T>::get(buyer);
    
    // 🆕 应用风险分衰减
    let decay_amount = Self::calculate_risk_decay(buyer);
    if decay_amount > 0 {
        let initial_risk = Self::calculate_initial_risk_score(buyer);
        credit.risk_score = credit.risk_score
            .saturating_sub(decay_amount)
            .max(initial_risk);  // 最低不低于初始风险分
    }
    
    // 检查信用分（风险分 > 800 禁止交易）
    ensure!(credit.risk_score <= 800, Error::<T>::CreditScoreTooLow);
    
    // ... 其他检查逻辑
}
```

#### 2. 效果示例

**场景**：用户在7天内连续违约3次，触发永久封禁

| 时间 | 风险分 | 衰减量 | 解封状态 |
|------|--------|--------|---------|
| **违约后第1天** | 1000 | 0 | ❌ 封禁 |
| **30天后** | 950 | 50 | ❌ 封禁（> 800） |
| **60天后** | 900 | 100 | ❌ 封禁（> 800） |
| **90天后** | 850 | 150 | ❌ 封禁（> 800） |
| **120天后** | 800 | 200 | ✅ **自动解封**（= 800） |
| **150天后** | 750 | 250 | ✅ 已解封 |

**结论**：
- ✅ 永久封禁变为"长期封禁"（120天）
- ✅ 给予用户改过自新的机会
- ✅ 保持强威慑力（4个月冷却期）

---

### 方案 B：治理手动解封（备选）

**核心思路**：
- 永久封禁无自动解除
- 治理可投票决定是否解封特定用户

**实施方案**：

```rust
/// 函数级中文注释：治理解封用户
#[pallet::call_index(10)]
#[pallet::weight(T::WeightInfo::unban_user())]
pub fn unban_user(
    origin: OriginFor<T>,
    who: T::AccountId,
    new_risk_score: u16,
) -> DispatchResult {
    ensure_root(origin)?;
    
    BuyerCredit::<T>::mutate(&who, |credit| {
        credit.risk_score = new_risk_score;
    });
    
    Self::deposit_event(Event::UserUnbanned {
        account: who,
        new_risk_score,
    });
    
    Ok(())
}
```

**优点**：
- ✅ 实施简单（~30行代码）
- ✅ 保持治理权威性

**缺点**：
- ⚠️ 需要人工干预
- ⚠️ 治理成本高
- ⚠️ 无法自动化

---

### 方案 C：混合机制（最优）

**核心思路**：
- 结合方案 A（风险分自然衰减）
- 结合方案 B（治理手动解封）

**规则**：
1. **自然衰减**：每30天降低50分
2. **最低阈值**：风险分最低不低于初始分（如400分）
3. **加速恢复**：治理可投票将风险分重置为800（边缘状态）或更低

**效果对比**：

| 场景 | 方案 A（仅衰减） | 方案 B（仅治理） | **方案 C（混合）** |
|------|----------------|-----------------|------------------|
| 永久封禁（1000分） | 120天后自动解除 | 需治理投票 | **120天后自动解除，或治理提前解封** |
| 高风险用户（850分） | 30天后自动解除 | 需治理投票 | **30天后自动解除，或治理提前解封** |
| 治理灵活性 | 低 | 高 | **最高** |

---

## 七、实施建议

### 立即实施（高优先级）

✅ **方案 A：风险分自然衰减机制**
- 代码修改量：中等（~80行）
- 效果：显著（永久封禁变为长期封禁）
- 优先级：🔴 高

### 后续优化（中优先级）

✅ **方案 B：治理手动解封**
- 代码修改量：小（~30行）
- 效果：中等（提供紧急解封通道）
- 优先级：🟡 中

### 文档更新（高优先级）

✅ **修正"临时、长期、超长"命名**
- 将"封禁"改为"冷却"
- 明确区分"冷却期封禁"和"永久封禁"
- 在 README.md 中增加流程图

---

## 八、总结

### 当前机制

| 特性 | 状态 |
|------|------|
| 冷却期封禁 | ✅ 可自动解除 |
| 永久封禁（风险分=1000） | ❌ **无法自动解除** |
| 30天后解禁 | ⚠️ **取决于是否触发永久封禁** |

### 关键结论

1. ✅ **仅冷却期封禁**：30天后（或7天、14天）可自动解除
2. ❌ **永久封禁**：30天后、60天后、永远都无法自动解除
3. ⚠️ **命名问题**："临时、长期、超长"应改为"轻微、短期、中期、长期、超长冷却"
4. 🔴 **亟需改进**：实施风险分自然衰减机制，给予用户恢复机会

### 推荐行动

1. **立即实施**：风险分自然衰减机制（每30天降50分）
2. **文档修正**：修正"临时/长期/超长封禁"命名为"冷却"
3. **后续优化**：增加治理手动解封接口

---

**报告生成时间**: 2025-10-21  
**核心问题**: ✅ **已澄清**  
**改进建议**: ✅ **已提供**  
**优先级**: 🔴 **高（建议立即实施风险分衰减）**

