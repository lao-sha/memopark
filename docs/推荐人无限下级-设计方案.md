# 推荐人无限下级数量支持 - 设计方案

## 一、需求背景

当前 `pallet-stardust-referrals` 限制每个推荐人最多拥有 **100,000** 个直接下级，通过 `BoundedVec` 实现。

**现有问题：**
1. 下级数量达到上限时返回错误信息不准确（复用了 `Error::Paused`）
2. 限制了推荐系统的扩展性
3. 无法支持超级推荐人（如官方账户、KOL账户）

**新需求：**
- 每个推荐人可以拥有**无限多个**直接下级
- 避免状态膨胀
- 保持系统性能

---

## 二、现状分析

### 当前存储结构

```rust
/// 正向索引：被推荐人 → 推荐人（一对一）
pub type SponsorOf<T: Config> = StorageMap<
    _, Blake2_128Concat, T::AccountId, T::AccountId
>;

/// 反向索引：推荐人 → 下级列表（一对多，有上限）
pub type ReferralsOf<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::AccountId,
    BoundedVec<T::AccountId, MaxReferralsPerAccount>,  // ⚠️ 上限 100,000
    ValueQuery,
>;
```

### 存储成本分析

假设推荐人拥有 N 个下级：

| 下级数量 N | SponsorOf 成本 | ReferralsOf 成本 | 总成本 |
|-----------|----------------|------------------|--------|
| 1,000 | ~32 KB | ~32 KB | ~64 KB |
| 10,000 | ~320 KB | ~320 KB | ~640 KB |
| 100,000 | ~3.2 MB | ~3.2 MB | ~6.4 MB |
| **1,000,000** | ~32 MB | **~32 MB (单条存储项!)** | ~64 MB |

**问题：** 当某个推荐人拥有百万级下级时，单个 `ReferralsOf` 存储项会达到 **32 MB**，严重影响链性能！

---

## 三、设计方案对比

### 方案A：移除反向索引 ⭐ **推荐**

#### 核心设计
```rust
// ✅ 保留正向索引
pub type SponsorOf<T: Config> = StorageMap<
    _, Blake2_128Concat, T::AccountId, T::AccountId
>;

// ❌ 移除反向索引
// pub type ReferralsOf<T: Config> = ...;

// ✅ 新增：记录绑定区块（用于链下索引构建时间窗口）
pub type BoundAt<T: Config> = StorageMap<
    _, Blake2_128Concat, T::AccountId, BlockNumberFor<T>
>;
```

#### 优点
- ✅ **真正的无限下级支持**（无状态膨胀风险）
- ✅ **存储成本最优**（每个推荐关系只存储一次）
- ✅ **链上逻辑简化**（移除 `try_push` 相关复杂度）
- ✅ **性能稳定**（不受推荐人下级数量影响）

#### 缺点
- ❌ 无法在链上直接查询"某推荐人的所有下级"
- ❌ 需要链下索引支持（Subsquid/The Graph）

#### 链下索引方案
```typescript
// Subsquid 索引示例
const referralBindings = await ctx.store.find(ReferralBinding, {
  where: { sponsor: sponsorAccount },
  order: { blockNumber: 'DESC' }
});
```

---

### 方案B：改用 Vec 存储 ⚠️ **不推荐**

#### 核心设计
```rust
// 将 BoundedVec 改为 Vec
pub type ReferralsOf<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::AccountId,
    Vec<T::AccountId>,  // ⚠️ 无上限
    ValueQuery,
>;
```

#### 优点
- ✅ 可以直接在链上查询下级

#### 缺点
- ❌ **严重的状态膨胀风险**
- ❌ **单个存储项可能达到数十MB**
- ❌ **影响区块链整体性能**
- ❌ **读写成本随下级数量线性增长**
- ❌ **可能成为 DoS 攻击向量**（恶意绑定大量下级）

---

### 方案C：混合方案（分页存储）

#### 核心设计
```rust
/// 推荐人的下级列表（分页存储，每页最多 1000 个）
pub type ReferralsOfPage<T: Config> = StorageDoubleMap<
    _,
    Blake2_128Concat, T::AccountId,  // 推荐人
    Blake2_128Concat, u32,            // 页码
    BoundedVec<T::AccountId, ConstU32<1000>>,  // 每页最多 1000 个
    ValueQuery,
>;

/// 推荐人的下级总数
pub type ReferralsCount<T: Config> = StorageMap<
    _, Blake2_128Concat, T::AccountId, u32, ValueQuery
>;
```

#### 优点
- ✅ 支持无限下级
- ✅ 单个存储项大小可控
- ✅ 可以分页查询

#### 缺点
- ❌ 链上逻辑复杂（需要管理分页）
- ❌ 仍然存在状态膨胀（只是分散了）
- ❌ 查询所有下级需要多次读取

---

## 四、推荐实施方案：方案A

### 实施步骤

#### 1. 修改存储结构
```rust
// pallets/stardust-referrals/src/lib.rs

#[pallet::storage]
pub type SponsorOf<T: Config> = StorageMap<
    _, Blake2_128Concat, T::AccountId, T::AccountId
>;

#[pallet::storage]
pub type BoundAt<T: Config> = StorageMap<
    _, Blake2_128Concat, T::AccountId, BlockNumberFor<T>
>;

// ❌ 移除 ReferralsOf
// #[pallet::storage]
// pub type ReferralsOf<T: Config> = ...;
```

#### 2. 简化 Config
```rust
#[pallet::config]
pub trait Config: frame_system::Config {
    type RuntimeEvent: ...;
    type MaxHops: Get<u32>;  // 保留（用于防环遍历）
    // ❌ 移除 MaxReferralsPerAccount
    type MembershipProvider: super::MembershipProvider<Self::AccountId>;
}
```

#### 3. 简化 `bind_sponsor` 逻辑
```rust
pub fn bind_sponsor(origin: OriginFor<T>, sponsor: T::AccountId) -> DispatchResult {
    let who = ensure_signed(origin)?;
    ensure!(!Self::paused(), Error::<T>::Paused);
    ensure!(who != sponsor, Error::<T>::SelfSponsor);
    ensure!(!SponsorOf::<T>::contains_key(&who), Error::<T>::AlreadyBound);

    // 环检测
    let mut cursor = Some(sponsor.clone());
    let mut hops: u32 = 0;
    while let Some(cur) = cursor {
        ensure!(cur != who, Error::<T>::CycleDetected);
        if hops >= T::MaxHops::get() {
            break;
        }
        cursor = SponsorOf::<T>::get(&cur);
        hops = hops.saturating_add(1);
    }

    // 绑定关系
    SponsorOf::<T>::insert(&who, &sponsor);
    BoundAt::<T>::insert(&who, <frame_system::Pallet<T>>::block_number());
    
    // ❌ 移除反向索引维护
    // ReferralsOf::<T>::try_mutate(&sponsor, |v| { ... })?;
    
    Self::deposit_event(Event::SponsorBound { who, sponsor });
    Ok(())
}
```

#### 4. 更新 ReferralProvider trait
```rust
pub trait ReferralProvider<AccountId> {
    fn sponsor_of(who: &AccountId) -> Option<AccountId>;
    fn ancestors(who: &AccountId, max_hops: u32) -> alloc::vec::Vec<AccountId>;
    fn is_banned(who: &AccountId) -> bool;
    
    // ❌ 移除直接查询下级的方法
    // fn referrals_of(who: &AccountId) -> Vec<AccountId>;
    
    // 其他方法保持不变...
}
```

#### 5. 更新 Runtime 配置
```rust
// runtime/src/configs/mod.rs

parameter_types! {
    pub const RefMaxHops: u32 = 10;
    // ❌ 移除 RefMaxChildren
}

impl pallet_memo_referrals::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type MaxHops = RefMaxHops;
    // ❌ 移除 MaxReferralsPerAccount
    type MembershipProvider = PalletMembership;
}
```

---

## 五、链下索引方案（Subsquid）

### 数据模型
```typescript
// stardust-squid/schema.graphql

type ReferralBinding @entity {
  id: ID!
  referee: String! @index
  sponsor: String! @index
  blockNumber: Int! @index
  timestamp: DateTime!
}

type ReferralStats @entity {
  id: ID!  # sponsor account
  totalReferrals: Int!
  activeReferrals: Int!
  updatedAt: DateTime!
}
```

### 查询示例
```graphql
# 查询某推荐人的所有下级
query GetReferrals($sponsor: String!) {
  referralBindings(
    where: { sponsor: $sponsor }
    orderBy: blockNumber_DESC
  ) {
    referee
    blockNumber
    timestamp
  }
}

# 查询推荐人统计
query GetReferralStats($sponsor: String!) {
  referralStats(id: $sponsor) {
    totalReferrals
    activeReferrals
  }
}
```

---

## 六、迁移计划

### Phase 1: 链上改造
1. ✅ 修改 `pallet-stardust-referrals` 存储结构
2. ✅ 移除 `ReferralsOf` 相关逻辑
3. ✅ 更新 Runtime 配置
4. ✅ 编译测试

### Phase 2: 链下索引
1. 设计 Subsquid schema
2. 实现事件监听与索引
3. 提供 GraphQL API

### Phase 3: 前端适配
1. 修改前端查询逻辑（从链下索引获取下级列表）
2. 保留链上查询 `sponsor_of`（被推荐人→推荐人）

---

## 七、风险评估

| 风险项 | 影响 | 缓解措施 |
|-------|------|---------|
| 链下索引服务故障 | 中 | 前端降级显示"暂时无法查询下级" |
| 历史数据迁移 | 低 | 现有 `SponsorOf` 数据无需迁移 |
| 前端兼容性 | 中 | 分阶段发布，保留向后兼容 |

---

## 八、总结

**推荐方案A的核心优势：**
1. ✅ **真正的无限下级支持**（无状态膨胀）
2. ✅ **存储成本最优**（每个关系只存储一次）
3. ✅ **链上性能稳定**（O(1) 绑定操作）
4. ✅ **符合区块链设计最佳实践**（链上存储核心数据，链下索引查询数据）

**实施建议：**
- 优先级：P0（核心功能优化）
- 工作量：2-3天
  - 链上改造：1天
  - 链下索引：1-2天
- 依赖：Subsquid 基础设施

