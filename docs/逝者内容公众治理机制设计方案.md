# 逝者内容公众治理机制设计方案

## 执行摘要

本方案设计了一套完整的**逝者媒体、文本档案、作品信息的公众增删改申请与投诉治理机制**。该机制允许公众对逝者相关内容进行申请修改，同时通过押金制度和投诉机制保障内容质量和系统安全。

### 核心机制

1. **公众申请机制**：任何人可申请对逝者媒体、文本、作品进行增、修改、删操作
2. **押金制度**：发起人需支付押金，公示期内接受公众监督
3. **投诉机制**：公示期内可投诉，投诉成功/失败有明确的押金分配规则
4. **委员会治理**：委员会负责审核申请和处理投诉

### 押金分配规则

- **投诉成功**：罚没发起人押金，80%转给投诉人，20%转给委员会成员
- **投诉失败**：罚没投诉人押金，80%转给上传人（原内容所有者），20%转给委员会成员

---

## 1. 可行性分析

### 1.1 技术可行性 ⭐⭐⭐⭐⭐ (5/5)

#### 优势

1. **现有基础设施完善**
   - ✅ `pallet-stardust-appeals` 已实现完整的申诉治理框架
   - ✅ `pallet-deceased` 已支持媒体、文本、作品管理
   - ✅ 押金管理使用 `pallet-balances` Holds API
   - ✅ 委员会治理机制已建立

2. **技术实现路径清晰**
   ```rust
   // 现有申诉系统可直接扩展
   Domain 3: 逝者文本 (Deceased Text)
   Domain 4: 逝者媒体 (Deceased Media)
   Domain 7: 作品 (Works)
   
   // 新增申请类型
   Action 10: 申请添加内容
   Action 11: 申请修改内容
   Action 12: 申请删除内容
   ```

3. **存储和查询能力充足**
   - 支持多维度索引（按用户、按目标、按状态）
   - 支持分页查询和批量处理
   - 事件系统完善，便于前端监听

#### 技术挑战

1. **公示期调度机制**
   - 需要实现定时任务（可使用 `pallet-scheduler`）
   - 公示期结束自动处理或退回押金

2. **押金分配逻辑**
   - 需要实现精确的押金分割（80%/20%）
   - 委员会成员奖励需要公平分配算法

3. **并发申请处理**
   - 同一内容可能同时有多个申请
   - 需要优先级和冲突解决机制

**结论**：技术实现完全可行，主要工作量在业务逻辑实现和测试验证。

### 1.2 经济可行性 ⭐⭐⭐⭐⚬ (4/5)

#### 成本分析

**开发成本**：
- 新增申请接口：2周开发 + 1周测试
- 投诉机制扩展：1周开发 + 1周测试
- 押金分配逻辑：1周开发 + 1周测试
- **总计**：约6-8周，成本可控

**运营成本**：
- 押金资金池：由用户押金自给自足
- 委员会奖励：从罚没押金中提取20%
- 系统维护：与现有系统共享基础设施

#### 收益分析

**直接收益**：
- 提高内容质量：公众监督机制
- 减少恶意内容：押金门槛过滤
- 增强社区参与：奖励机制激励

**间接收益**：
- 提升平台公信力
- 降低人工审核成本
- 建立去中心化治理典范

**风险**：
- 初期可能押金池不足（需要启动资金）
- 委员会成员激励可能不足（20%可能偏低）

**结论**：经济上可行，建议初期设置合理的押金标准，确保系统可持续运行。

### 1.3 治理可行性 ⭐⭐⭐⭐⚬ (4/5)

#### 优势

1. **激励机制明确**
   - 投诉成功获得80%押金，激励公众监督
   - 委员会获得20%奖励，激励积极参与
   - 申请失败押金被罚没，防止恶意申请

2. **流程透明**
   - 公示期机制确保公众有足够时间审查
   - 投诉和申请都有明确的处理流程
   - 所有操作链上可查，不可篡改

3. **权力制衡**
   - 公众可以申请修改
   - 公众可以投诉申请
   - 委员会负责最终裁决
   - 多重监督机制

#### 挑战

1. **委员会公正性**
   - 需要防止委员会成员串通
   - 需要建立轮换和问责机制
   - 需要处理利益冲突

2. **投诉质量**
   - 可能有人恶意投诉（但会被罚没押金）
   - 需要建立投诉质量评估机制

3. **公示期时长**
   - 太短：公众来不及审查
   - 太长：影响用户体验和资金占用

**结论**：治理机制设计合理，但需要在实际运营中不断优化参数。

### 1.4 法律合规性 ⭐⭐⭐⚬⚬ (3/5)

#### 合规考虑

1. **内容修改权**
   - 逝者内容修改涉及隐私权和著作权
   - 需要明确修改权限和范围
   - 建议设置"仅限事实性错误修正"

2. **押金性质**
   - 押金属于保证金性质
   - 罚没需要明确法律依据
   - 建议在用户协议中明确说明

3. **委员会责任**
   - 委员会决策可能涉及法律责任
   - 需要明确免责条款
   - 建议购买责任保险

**结论**：需要法律顾问审查，确保符合当地法律法规。

---

## 2. 合理性分析

### 2.1 机制设计合理性

#### ✅ 合理的设计

1. **押金制度**
   - **合理性**：防止恶意申请，提高申请质量
   - **押金标准**：建议根据内容类型和影响力动态调整
   - **建议**：10-100 DUST，根据内容重要性调整

2. **公示期机制**
   - **合理性**：给公众足够时间审查和投诉
   - **时长建议**：7-14天（50400-100800块，按6秒/块计算）
   - **考虑因素**：内容重要性、修改幅度、社区活跃度

3. **投诉机制**
   - **合理性**：公众监督，防止不当修改
   - **投诉押金**：建议与申请押金相同或略低
   - **投诉期限**：仅限公示期内

4. **押金分配规则**
   - **80%给投诉人/上传人**：合理，主要奖励给直接相关方
   - **20%给委员会**：合理，激励委员会参与治理
   - **建议**：可根据实际情况调整比例（如70%/30%或85%/15%）

#### ⚠️ 需要优化的设计

1. **申请类型限制**
   - **问题**：完全开放可能导致滥用
   - **建议**：
     - 添加内容：需要提供充分理由和证据
     - 修改内容：仅限事实性错误修正
     - 删除内容：需要更高押金和更严格审核

2. **投诉门槛**
   - **问题**：投诉押金可能过高，阻碍合法投诉
   - **建议**：
     - 高信誉用户享受押金折扣
     - 公示期投诉可降低押金要求
     - 建立投诉质量评估机制

3. **委员会奖励分配**
   - **问题**：20%如何公平分配给委员会成员
   - **建议**：
     - 按参与度分配（审核次数、质量评分）
     - 设置最低工作量要求
     - 防止搭便车行为

### 2.2 经济模型合理性

#### 押金标准合理性

| 内容类型 | 操作类型 | 建议押金 | 理由 |
|---------|---------|---------|------|
| **文本档案** | 添加 | 20 DUST | 中等风险，需要验证真实性 |
| **文本档案** | 修改 | 30 DUST | 修改风险较高，需要更多押金 |
| **文本档案** | 删除 | 50 DUST | 删除不可逆，需要高押金 |
| **媒体内容** | 添加 | 30 DUST | 媒体文件较大，验证成本高 |
| **媒体内容** | 修改 | 40 DUST | 修改媒体需要重新上传 |
| **媒体内容** | 删除 | 60 DUST | 删除媒体影响较大 |
| **作品信息** | 添加 | 25 DUST | 作品信息需要验证版权 |
| **作品信息** | 修改 | 35 DUST | 修改作品信息需要谨慎 |
| **作品信息** | 删除 | 80 DUST | 删除作品影响最大 |

#### 押金分配合理性

**场景1：投诉成功（申请不当）**
```
发起人押金：100 DUST
分配：
- 投诉人：80 DUST（80%）✅ 合理，激励监督
- 委员会：20 DUST（20%）✅ 合理，激励治理
```

**场景2：投诉失败（申请合理）**
```
投诉人押金：100 DUST
分配：
- 上传人（原所有者）：80 DUST（80%）✅ 合理，补偿损失
- 委员会：20 DUST（20%）✅ 合理，激励治理
```

**合理性评估**：
- ✅ 80%/20% 比例合理，主要奖励给直接相关方
- ✅ 委员会奖励适中，既能激励又不会过度
- ⚠️ 建议根据实际情况动态调整（如70%/30%或85%/15%）

### 2.3 流程设计合理性

#### 申请流程

```
1. 用户提交申请
   ↓
2. 锁定押金
   ↓
3. 进入公示期（7-14天）
   ↓
4. 公示期内可投诉
   ↓
5. 公示期结束：
   - 无投诉 → 委员会审核 → 批准/驳回
   - 有投诉 → 先处理投诉 → 再审核申请
```

**合理性评估**：
- ✅ 流程清晰，逻辑合理
- ✅ 公示期给公众足够时间审查
- ⚠️ 建议：公示期内的投诉应优先处理

#### 投诉处理流程

```
1. 投诉人提交投诉（公示期内）
   ↓
2. 锁定投诉押金
   ↓
3. 委员会审核投诉
   ↓
4. 投诉结果：
   - 成功 → 罚没申请押金，分配奖励
   - 失败 → 罚没投诉押金，分配奖励
```

**合理性评估**：
- ✅ 投诉机制完善，有明确的结果处理
- ✅ 押金分配规则清晰
- ⚠️ 建议：建立投诉质量评估，防止恶意投诉

---

## 3. 详细设计方案

### 3.1 申请类型定义

```rust
/// 公众申请操作类型
pub mod public_request_actions {
    /// 操作10：申请添加内容
    pub const ACTION_ADD_CONTENT: u8 = 10;
    
    /// 操作11：申请修改内容
    pub const ACTION_MODIFY_CONTENT: u8 = 11;
    
    /// 操作12：申请删除内容
    pub const ACTION_DELETE_CONTENT: u8 = 12;
}

/// 申请目标域
pub mod request_domains {
    /// 域3：逝者文本档案
    pub const DOMAIN_DECEASED_TEXT: u8 = 3;
    
    /// 域4：逝者媒体内容
    pub const DOMAIN_DECEASED_MEDIA: u8 = 4;
    
    /// 域7：作品信息
    pub const DOMAIN_WORKS: u8 = 7;
}
```

### 3.2 申请数据结构

```rust
/// 公众申请记录
#[derive(Encode, Decode, Clone, PartialEq, Eq, TypeInfo, MaxEncodedLen)]
pub struct PublicRequest<T: Config> {
    /// 申请人账户
    pub applicant: T::AccountId,
    
    /// 目标域（3=文本，4=媒体，7=作品）
    pub domain: u8,
    
    /// 目标ID（text_id, media_id, work_id）
    pub target_id: u64,
    
    /// 所属逝者ID（用于关联查询）
    pub deceased_id: u64,
    
    /// 操作类型（10=添加，11=修改，12=删除）
    pub action: u8,
    
    /// 申请理由CID
    pub reason_cid: BoundedVec<u8, ConstU32<128>>,
    
    /// 证据材料CID列表
    pub evidence_cids: BoundedVec<BoundedVec<u8, ConstU32<128>>, ConstU32<10>>,
    
    /// 新内容CID（添加/修改时使用）
    pub new_content_cid: Option<BoundedVec<u8, ConstU32<128>>>,
    
    /// 押金金额
    pub deposit_amount: BalanceOf<T>,
    
    /// 申请状态（0=已提交，1=公示中，2=已批准，3=已驳回，4=已执行，5=已撤回）
    pub status: u8,
    
    /// 公示期开始时间（区块号）
    pub notice_start: BlockNumberFor<T>,
    
    /// 公示期结束时间（区块号）
    pub notice_end: BlockNumberFor<T>,
    
    /// 投诉数量
    pub complaint_count: u32,
    
    /// 提交时间
    pub submitted_at: BlockNumberFor<T>,
    
    /// 批准/驳回时间
    pub reviewed_at: Option<BlockNumberFor<T>>,
    
    /// 执行时间
    pub executed_at: Option<BlockNumberFor<T>>,
}
```

### 3.3 投诉数据结构

```rust
/// 投诉记录
#[derive(Encode, Decode, Clone, PartialEq, Eq, TypeInfo, MaxEncodedLen)]
pub struct Complaint<T: Config> {
    /// 投诉人账户
    pub complainant: T::AccountId,
    
    /// 关联的申请ID
    pub request_id: u64,
    
    /// 投诉理由CID
    pub reason_cid: BoundedVec<u8, ConstU32<128>>,
    
    /// 证据材料CID列表
    pub evidence_cids: BoundedVec<BoundedVec<u8, ConstU32<128>>, ConstU32<10>>,
    
    /// 投诉押金金额
    pub deposit_amount: BalanceOf<T>,
    
    /// 投诉状态（0=已提交，1=审核中，2=投诉成功，3=投诉失败）
    pub status: u8,
    
    /// 提交时间
    pub submitted_at: BlockNumberFor<T>,
    
    /// 审核时间
    pub reviewed_at: Option<BlockNumberFor<T>>,
}
```

### 3.4 核心接口设计

#### 3.4.1 提交申请接口

```rust
/// 提交公众申请
#[pallet::call_index(60)]
#[pallet::weight(T::WeightInfo::submit_public_request())]
pub fn submit_public_request(
    origin: OriginFor<T>,
    /// 目标域（3=文本，4=媒体，7=作品）
    domain: u8,
    /// 目标ID（添加时为0，修改/删除时为目标ID）
    target_id: u64,
    /// 所属逝者ID
    deceased_id: u64,
    /// 操作类型（10=添加，11=修改，12=删除）
    action: u8,
    /// 申请理由CID
    reason_cid: BoundedVec<u8, ConstU32<128>>,
    /// 证据材料CID列表
    evidence_cids: BoundedVec<BoundedVec<u8, ConstU32<128>>, ConstU32<10>>,
    /// 新内容CID（添加/修改时必填）
    new_content_cid: Option<BoundedVec<u8, ConstU32<128>>>,
) -> DispatchResult {
    let applicant = ensure_signed(origin)?;
    let now = <frame_system::Pallet<T>>::block_number();
    
    // 1. 验证参数
    ensure!(
        domain == 3 || domain == 4 || domain == 7,
        Error::<T>::InvalidDomain
    );
    ensure!(
        action >= 10 && action <= 12,
        Error::<T>::InvalidAction
    );
    ensure!(!reason_cid.is_empty(), Error::<T>::ReasonRequired);
    ensure!(!evidence_cids.is_empty(), Error::<T>::EvidenceRequired);
    
    // 2. 验证目标内容（修改/删除时需要）
    if action != 10 { // 非添加操作
        ensure!(target_id > 0, Error::<T>::TargetNotFound);
        // 验证目标内容存在
        Self::verify_target_exists(domain, target_id)?;
    }
    
    // 3. 计算押金
    let deposit_amount = Self::calculate_request_deposit(
        domain,
        action,
        target_id,
        &applicant,
    )?;
    
    // 4. 锁定押金
    T::Fungible::hold(
        &T::RuntimeHoldReason::from(HoldReason::PublicRequest),
        &applicant,
        deposit_amount,
    )?;
    
    // 5. 计算公示期
    let notice_period = T::PublicRequestNoticePeriod::get();
    let notice_start = now;
    let notice_end = now + notice_period;
    
    // 6. 创建申请记录
    let request_id = NextRequestId::<T>::mutate(|id| {
        let current = *id;
        *id = id.saturating_add(1);
        current
    });
    
    let request = PublicRequest {
        applicant: applicant.clone(),
        domain,
        target_id,
        deceased_id,
        action,
        reason_cid,
        evidence_cids,
        new_content_cid,
        deposit_amount,
        status: 1, // 公示中
        notice_start,
        notice_end,
        complaint_count: 0,
        submitted_at: now,
        reviewed_at: None,
        executed_at: None,
    };
    
    PublicRequests::<T>::insert(request_id, request);
    
    // 7. 更新索引
    Self::index_by_applicant(&applicant, request_id);
    Self::index_by_target(domain, target_id, request_id);
    Self::index_by_status(1, request_id); // 公示中
    
    // 8. 调度公示期结束处理
    T::Scheduler::schedule(
        notice_end,
        Some((request_id, ScheduledTaskType::ProcessPublicRequest)),
        DispatchTime::At(notice_end),
        || Self::process_public_request_after_notice(request_id),
    )?;
    
    Self::deposit_event(Event::PublicRequestSubmitted {
        request_id,
        applicant,
        domain,
        target_id,
        deceased_id,
        action,
        deposit: deposit_amount,
        notice_end,
    });
    
    Ok(())
}
```

#### 3.4.2 提交投诉接口

```rust
/// 提交投诉（仅限公示期内）
#[pallet::call_index(61)]
#[pallet::weight(T::WeightInfo::submit_complaint())]
pub fn submit_complaint(
    origin: OriginFor<T>,
    /// 申请ID
    request_id: u64,
    /// 投诉理由CID
    reason_cid: BoundedVec<u8, ConstU32<128>>,
    /// 证据材料CID列表
    evidence_cids: BoundedVec<BoundedVec<u8, ConstU32<128>>, ConstU32<10>>,
) -> DispatchResult {
    let complainant = ensure_signed(origin)?;
    let now = <frame_system::Pallet<T>>::block_number();
    
    // 1. 验证申请存在且处于公示期
    let request = PublicRequests::<T>::get(request_id)
        .ok_or(Error::<T>::RequestNotFound)?;
    
    ensure!(
        request.status == 1, // 公示中
        Error::<T>::RequestNotInNoticePeriod
    );
    
    ensure!(
        now <= request.notice_end,
        Error::<T>::NoticePeriodExpired
    );
    
    // 2. 验证不能投诉自己的申请
    ensure!(
        request.applicant != complainant,
        Error::<T>::CannotComplainOwnRequest
    );
    
    // 3. 验证参数
    ensure!(!reason_cid.is_empty(), Error::<T>::ReasonRequired);
    ensure!(!evidence_cids.is_empty(), Error::<T>::EvidenceRequired);
    
    // 4. 计算投诉押金（建议与申请押金相同或略低）
    let deposit_amount = Self::calculate_complaint_deposit(
        request.deposit_amount,
        &complainant,
    )?;
    
    // 5. 锁定投诉押金
    T::Fungible::hold(
        &T::RuntimeHoldReason::from(HoldReason::Complaint),
        &complainant,
        deposit_amount,
    )?;
    
    // 6. 创建投诉记录
    let complaint_id = NextComplaintId::<T>::mutate(|id| {
        let current = *id;
        *id = id.saturating_add(1);
        current
    });
    
    let complaint = Complaint {
        complainant: complainant.clone(),
        request_id,
        reason_cid,
        evidence_cids,
        deposit_amount,
        status: 0, // 已提交
        submitted_at: now,
        reviewed_at: None,
    };
    
    Complaints::<T>::insert(complaint_id, complaint);
    
    // 7. 更新申请记录
    PublicRequests::<T>::mutate(request_id, |req| {
        if let Some(r) = req {
            r.complaint_count += 1;
            // 有投诉时，取消自动处理，等待投诉处理完成
            // 注意：这里需要取消之前调度的任务
        }
    });
    
    // 8. 更新索引
    Self::index_complaint_by_request(request_id, complaint_id);
    Self::index_complaint_by_complainant(&complainant, complaint_id);
    
    Self::deposit_event(Event::ComplaintSubmitted {
        complaint_id,
        request_id,
        complainant,
        deposit: deposit_amount,
    });
    
    Ok(())
}
```

#### 3.4.3 委员会审核投诉接口

```rust
/// 委员会审核投诉
#[pallet::call_index(62)]
#[pallet::weight(T::WeightInfo::review_complaint())]
pub fn review_complaint(
    origin: OriginFor<T>,
    /// 投诉ID
    complaint_id: u64,
    /// 审核结果（true=投诉成功，false=投诉失败）
    approved: bool,
    /// 审核理由
    reasoning: BoundedVec<u8, ConstU32<256>>,
) -> DispatchResult {
    // 1. 验证权限
    T::GovernanceOrigin::ensure_origin(origin)?;
    
    let now = <frame_system::Pallet<T>>::block_number();
    
    // 2. 获取投诉记录
    let mut complaint = Complaints::<T>::get(complaint_id)
        .ok_or(Error::<T>::ComplaintNotFound)?;
    
    ensure!(
        complaint.status == 0, // 已提交
        Error::<T>::ComplaintAlreadyReviewed
    );
    
    // 3. 获取关联的申请记录
    let mut request = PublicRequests::<T>::get(complaint.request_id)
        .ok_or(Error::<T>::RequestNotFound)?;
    
    // 4. 处理投诉结果
    if approved {
        // 投诉成功：罚没申请押金，分配奖励
        Self::handle_complaint_success(
            &request,
            &complaint,
            now,
        )?;
        complaint.status = 2; // 投诉成功
        request.status = 3; // 申请驳回
    } else {
        // 投诉失败：罚没投诉押金，分配奖励
        Self::handle_complaint_failure(
            &request,
            &complaint,
            now,
        )?;
        complaint.status = 3; // 投诉失败
        // 申请继续进入审核流程
    }
    
    complaint.reviewed_at = Some(now);
    request.reviewed_at = Some(now);
    
    // 5. 更新存储
    Complaints::<T>::insert(complaint_id, complaint);
    PublicRequests::<T>::insert(complaint.request_id, request);
    
    Self::deposit_event(Event::ComplaintReviewed {
        complaint_id,
        request_id: complaint.request_id,
        approved,
    });
    
    Ok(())
}
```

#### 3.4.4 押金分配函数

```rust
/// 处理投诉成功（罚没申请押金）
fn handle_complaint_success<T: Config>(
    request: &PublicRequest<T>,
    complaint: &Complaint<T>,
    now: BlockNumberFor<T>,
) -> DispatchResult {
    let deposit_amount = request.deposit_amount;
    
    // 1. 计算分配金额
    let complainant_reward = Self::calculate_reward(
        deposit_amount,
        T::ComplainantRewardBps::get(), // 8000 = 80%
    )?;
    
    let committee_reward = deposit_amount
        .saturating_sub(complainant_reward); // 20%
    
    // 2. 罚没申请押金并分配
    // 2.1 转给投诉人（80%）
    T::Fungible::transfer_on_hold(
        &T::RuntimeHoldReason::from(HoldReason::PublicRequest),
        &request.applicant,
        &complaint.complainant,
        complainant_reward,
        Precision::BestEffort,
        Restriction::Free,
        Fortitude::Force,
    )?;
    
    // 2.2 转给委员会（20%）
    Self::distribute_committee_reward(
        committee_reward,
        request.request_id,
        "complaint_success",
    )?;
    
    // 3. 释放剩余押金（如果有）
    let remaining = deposit_amount
        .saturating_sub(complainant_reward)
        .saturating_sub(committee_reward);
    
    if !remaining.is_zero() {
        T::Fungible::release(
            &T::RuntimeHoldReason::from(HoldReason::PublicRequest),
            &request.applicant,
            remaining,
            Precision::Exact,
        )?;
    }
    
    // 4. 释放投诉押金（投诉成功，退回投诉押金）
    T::Fungible::release(
        &T::RuntimeHoldReason::from(HoldReason::Complaint),
        &complaint.complainant,
        complaint.deposit_amount,
        Precision::Exact,
    )?;
    
    Self::deposit_event(Event::ComplaintSuccessRewardDistributed {
        request_id: request.request_id,
        complainant: complaint.complainant.clone(),
        complainant_reward,
        committee_reward,
    });
    
    Ok(())
}

/// 处理投诉失败（罚没投诉押金）
fn handle_complaint_failure<T: Config>(
    request: &PublicRequest<T>,
    complaint: &Complaint<T>,
    now: BlockNumberFor<T>,
) -> DispatchResult {
    let deposit_amount = complaint.deposit_amount;
    
    // 1. 获取原内容所有者（上传人）
    let original_owner = Self::get_content_owner(
        request.domain,
        request.target_id,
    )?;
    
    // 2. 计算分配金额
    let owner_reward = Self::calculate_reward(
        deposit_amount,
        T::OwnerRewardBps::get(), // 8000 = 80%
    )?;
    
    let committee_reward = deposit_amount
        .saturating_sub(owner_reward); // 20%
    
    // 3. 罚没投诉押金并分配
    // 3.1 转给原内容所有者（80%）
    T::Fungible::transfer_on_hold(
        &T::RuntimeHoldReason::from(HoldReason::Complaint),
        &complaint.complainant,
        &original_owner,
        owner_reward,
        Precision::BestEffort,
        Restriction::Free,
        Fortitude::Force,
    )?;
    
    // 3.2 转给委员会（20%）
    Self::distribute_committee_reward(
        committee_reward,
        request.request_id,
        "complaint_failure",
    )?;
    
    // 4. 释放剩余押金（如果有）
    let remaining = deposit_amount
        .saturating_sub(owner_reward)
        .saturating_sub(committee_reward);
    
    if !remaining.is_zero() {
        T::Fungible::release(
            &T::RuntimeHoldReason::from(HoldReason::Complaint),
            &complaint.complainant,
            remaining,
            Precision::Exact,
        )?;
    }
    
    Self::deposit_event(Event::ComplaintFailureRewardDistributed {
        request_id: request.request_id,
        owner: original_owner,
        owner_reward,
        committee_reward,
    });
    
    Ok(())
}

/// 分配委员会奖励
fn distribute_committee_reward<T: Config>(
    total_reward: BalanceOf<T>,
    request_id: u64,
    reason: &str,
) -> DispatchResult {
    // 1. 获取参与审核的委员会成员
    let reviewers = Self::get_request_reviewers(request_id)?;
    
    if reviewers.is_empty() {
        // 如果没有审核者，转入国库
        T::Fungible::transfer(
            &T::TreasuryAccount::get(),
            &T::TreasuryAccount::get(),
            total_reward,
            frame_support::traits::tokens::Preservation::Preserve,
        )?;
        return Ok(());
    }
    
    // 2. 按参与度分配奖励
    let total_weight: u32 = reviewers.iter()
        .map(|(_, weight)| *weight)
        .sum();
    
    if total_weight == 0 {
        // 平均分配
        let per_member = total_reward / (reviewers.len() as u32).into();
        for (member, _) in reviewers {
            T::Fungible::transfer(
                &T::TreasuryAccount::get(),
                &member,
                per_member,
                frame_support::traits::tokens::Preservation::Preserve,
            )?;
        }
    } else {
        // 按权重分配
        for (member, weight) in reviewers {
            let member_share = Perbill::from_rational(weight, total_weight);
            let member_reward = member_share.mul_floor(total_reward);
            
            T::Fungible::transfer(
                &T::TreasuryAccount::get(),
                &member,
                member_reward,
                frame_support::traits::tokens::Preservation::Preserve,
            )?;
        }
    }
    
    Ok(())
}
```

### 3.5 配置参数

```rust
pub trait Config: frame_system::Config {
    // ... 其他配置 ...
    
    /// 公众申请公示期（区块数）
    #[pallet::constant]
    type PublicRequestNoticePeriod: Get<BlockNumberFor<Self>>;
    
    /// 投诉人奖励比例（bps，8000 = 80%）
    #[pallet::constant]
    type ComplainantRewardBps: Get<u16>;
    
    /// 原内容所有者奖励比例（bps，8000 = 80%）
    #[pallet::constant]
    type OwnerRewardBps: Get<u16>;
    
    /// 委员会奖励比例（bps，2000 = 20%）
    #[pallet::constant]
    type CommitteeRewardBps: Get<u16>;
    
    /// 基础申请押金
    #[pallet::constant]
    type BaseRequestDeposit: Get<BalanceOf<Self>>;
    
    /// 投诉押金倍数（相对于申请押金）
    #[pallet::constant]
    type ComplaintDepositMultiplier: Get<u16>; // 1000 = 1.0x
}
```

### 3.6 Runtime配置示例

```rust
impl pallet_public_governance::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type Fungible = Balances;
    type RuntimeHoldReason = RuntimeHoldReason;
    
    // 公示期：7天（50400块，按6秒/块）
    type PublicRequestNoticePeriod = ConstU32<50400>;
    
    // 奖励比例
    type ComplainantRewardBps = ConstU16<8000>; // 80%
    type OwnerRewardBps = ConstU16<8000>;       // 80%
    type CommitteeRewardBps = ConstU16<2000>;   // 20%
    
    // 押金配置
    type BaseRequestDeposit = ConstU128<{ 20 * DUST }>; // 20 DUST
    type ComplaintDepositMultiplier = ConstU16<1000>;   // 1.0x
    
    // 服务提供者
    type ContentOwnerProvider = DeceasedPallet;
    type GovernanceOrigin = EnsureRootOrHalfCouncil;
    type Scheduler = Scheduler;
    
    // 权重
    type WeightInfo = pallet_public_governance::weights::WeightInfo;
}
```

---

## 4. 实施计划

### 4.1 开发阶段

#### 第一阶段：核心功能实现（3周）

**任务清单**：
- [ ] 实现 `submit_public_request()` 接口
- [ ] 实现 `submit_complaint()` 接口
- [ ] 实现 `review_complaint()` 接口
- [ ] 实现押金分配逻辑
- [ ] 实现公示期调度机制
- [ ] 编写单元测试

**交付物**：
- 核心功能代码
- 单元测试用例
- 接口文档

#### 第二阶段：集成和优化（2周）

**任务清单**：
- [ ] 与现有申诉系统集成
- [ ] 实现委员会奖励分配算法
- [ ] 优化存储和查询性能
- [ ] 编写集成测试
- [ ] 前端接口对接

**交付物**：
- 集成测试报告
- 性能测试报告
- 前端对接文档

#### 第三阶段：测试和部署（2周）

**任务清单**：
- [ ] 端到端测试
- [ ] 安全审计
- [ ] 文档完善
- [ ] 测试网部署
- [ ] 主网部署准备

**交付物**：
- 测试报告
- 安全审计报告
- 用户指南
- 部署文档

### 4.2 风险控制

#### 技术风险

1. **公示期调度可能失败**
   - **缓解措施**：实现重试机制和手动触发接口
   - **监控**：设置告警，监控调度任务执行情况

2. **押金分配计算精度问题**
   - **缓解措施**：使用 `Perbill` 进行精确计算
   - **测试**：编写大量边界测试用例

3. **并发申请冲突**
   - **缓解措施**：实现申请优先级和冲突检测
   - **设计**：同一内容同时只能有一个活跃申请

#### 经济风险

1. **押金池不足**
   - **缓解措施**：设置合理的押金标准
   - **监控**：实时监控押金池余额

2. **委员会激励不足**
   - **缓解措施**：根据实际情况调整奖励比例
   - **优化**：建立委员会成员绩效考核机制

#### 治理风险

1. **恶意申请/投诉**
   - **缓解措施**：押金门槛 + 信誉评分
   - **监控**：建立恶意行为检测机制

2. **委员会不公正**
   - **缓解措施**：建立轮换和问责机制
   - **监督**：允许对委员会决策进行申诉

---

## 5. 监控和评估

### 5.1 关键指标

| 指标类别 | 指标名称 | 目标值 | 监控频率 |
|---------|---------|-------|---------|
| **申请质量** | 申请通过率 | 60-80% | 每日 |
| **投诉质量** | 投诉成功率 | 50-70% | 每日 |
| **系统性能** | 申请处理时间 | < 48小时 | 实时 |
| **经济指标** | 押金池余额 | > 1000 DUST | 每日 |
| **用户满意度** | 申请者满意度 | > 70% | 每周 |
| **治理效率** | 委员会响应时间 | < 24小时 | 每日 |

### 5.2 告警规则

```rust
/// 系统健康检查
fn check_system_health() -> Vec<Alert> {
    let mut alerts = Vec::new();
    
    // 1. 押金池余额告警
    let total_deposits = calculate_total_deposits();
    if total_deposits < 1000 * DUST {
        alerts.push(Alert::LowDepositPool {
            current: total_deposits,
            threshold: 1000 * DUST,
        });
    }
    
    // 2. 申请积压告警
    let pending_requests = count_pending_requests();
    if pending_requests > 100 {
        alerts.push(Alert::RequestBacklog {
            count: pending_requests,
            threshold: 100,
        });
    }
    
    // 3. 投诉积压告警
    let pending_complaints = count_pending_complaints();
    if pending_complaints > 50 {
        alerts.push(Alert::ComplaintBacklog {
            count: pending_complaints,
            threshold: 50,
        });
    }
    
    alerts
}
```

---

## 6. 总结和建议

### 6.1 可行性总结

| 维度 | 评分 | 结论 |
|------|------|------|
| **技术可行性** | ⭐⭐⭐⭐⭐ | 完全可行，基于现有基础设施 |
| **经济可行性** | ⭐⭐⭐⭐⚬ | 可行，需要合理设置参数 |
| **治理可行性** | ⭐⭐⭐⭐⚬ | 可行，需要完善监督机制 |
| **法律合规性** | ⭐⭐⭐⚬⚬ | 需要法律顾问审查 |

### 6.2 核心建议

#### 短期建议（1-3个月）

1. **保守设置初始参数**
   - 公示期：7天（可后续调整）
   - 押金标准：20-50 DUST（根据内容类型）
   - 奖励比例：80%/20%（可后续优化）

2. **建立完善的测试体系**
   - 单元测试覆盖率 > 90%
   - 集成测试覆盖主要流程
   - 压力测试验证性能

3. **完善文档和用户指南**
   - 申请流程说明
   - 投诉流程说明
   - 押金和奖励说明

#### 中期建议（3-6个月）

1. **根据运营数据优化参数**
   - 调整押金标准
   - 优化奖励比例
   - 调整公示期时长

2. **建立委员会绩效考核**
   - 审核质量评分
   - 响应时间统计
   - 奖励分配优化

3. **增强恶意行为检测**
   - 申请质量评估
   - 投诉质量评估
   - 信誉评分机制

#### 长期建议（6-12个月）

1. **引入AI辅助审核**
   - 自动识别恶意申请
   - 自动评估申请质量
   - 智能推荐审核优先级

2. **建立社区治理机制**
   - 社区投票参与审核
   - 建立专家库
   - 实现去中心化治理

3. **跨链和互操作性**
   - 支持多链申请
   - 建立跨链治理标准
   - 实现治理数据共享

### 6.3 风险提示

1. **法律风险**：务必确保符合当地法律法规，建议在实施前进行法律合规审查
2. **经济风险**：押金标准需要根据实际情况动态调整，避免过高或过低
3. **治理风险**：委员会的选择和管理至关重要，需要建立严格的监督机制
4. **技术风险**：公示期调度和押金分配需要充分测试，确保准确性和可靠性

### 6.4 成功关键因素

1. **合理的参数设置**：押金、奖励比例、公示期等参数需要根据实际情况不断优化
2. **完善的监督机制**：建立多层次的监督机制，确保治理公正性
3. **积极的社区参与**：鼓励社区参与治理，提高系统公信力
4. **持续的技术优化**：根据运营数据不断优化系统性能和用户体验

---

**文档版本**: v1.0  
**最后更新**: 2025-01-15  
**作者**: Stardust 开发团队  
**状态**: 待审核实施

**相关文档**:
- [公众投诉治理机制设计方案](./公众投诉治理机制设计方案.md)
- [作品投诉治理机制补充方案](./作品投诉治理机制补充方案.md)
- [pallet-stardust-appeals README](../pallets/stardust-appeals/README.md)

