# Stardust 关系功能逻辑文档

## 概述

Stardust 纪念园系统包含**两套独立但相关的关系管理系统**：

1. **逝者关系系统** (Deceased Relationship System) - 在 `pallet-deceased` 中实现
2. **墓地亲缘系统** (Grave Kinship System) - 在 `pallet-stardust-grave` 中实现

两套系统服务于不同的业务场景，具有不同的关系类型定义和管理逻辑。

---

## 一、逝者关系系统 (pallet-deceased)

### 1.1 关系类型定义

系统定义了 **4 种基础关系类型**，使用数字编码 (0-3)：

| 编码 | 类型 | 英文名 | 方向性 | 说明 |
|------|------|--------|--------|------|
| **0** | 父母 | ParentOf | 有向 | A 是 B 的父母 |
| **1** | 配偶 | SpouseOf | 无向 | A 与 B 是配偶关系 |
| **2** | 兄弟姐妹 | SiblingOf | 无向 | A 与 B 是兄弟姐妹 |
| **3** | 子女 | ChildOf | 有向 | A 是 B 的子女 |

#### 方向性说明

- **有向关系** (ParentOf, ChildOf)：关系具有明确方向，A→B 与 B→A 是不同的关系
- **无向关系** (SpouseOf, SiblingOf)：关系是对称的，A→B 等同于 B→A

### 1.2 数据结构

#### 关系记录结构

```rust
pub struct Relation<T: Config> {
    pub kind: u8,                              // 关系类型 (0-3)
    pub note: BoundedVec<u8, T::StringLimit>,  // 关系备注（可选）
    pub created_by: T::AccountId,              // 创建者账户
    pub since: BlockNumberFor<T>,              // 创建区块高度
}
```

#### 存储映射

```rust
// 主关系存储：(逝者A ID, 逝者B ID) -> 关系记录
pub type Relations<T> = StorageDoubleMap<DeceasedId, DeceasedId, Relation<T>>;

// 逝者关系索引：逝者ID -> [(关联逝者ID, 关系类型)]
pub type RelationsByDeceased<T> = StorageMap<DeceasedId, BoundedVec<(DeceasedId, u8), 128>>;

// 待处理关系请求：(发起者逝者ID, 目标逝者ID) -> (关系类型, 创建者, 备注, 区块)
pub type PendingRelationRequests<T> = StorageDoubleMap<DeceasedId, DeceasedId, (u8, AccountId, Note, BlockNumber)>;
```

### 1.3 核心功能 (Extrinsics)

#### 1.3.1 提出关系申请

```rust
#[pallet::call_index(0)]
pub fn propose_relation(
    origin: OriginFor<T>,
    from: u64,           // 发起方逝者ID
    to: u64,             // 目标方逝者ID
    kind: u8,            // 关系类型 (0-3)
    note_cid: Vec<u8>,   // 关系备注
) -> DispatchResult
```

**权限要求**：
- 调用者必须是 `from` 逝者的管理员
- 不能对同一逝者对建立重复关系
- 不能建立冲突的关系类型

**业务流程**：
1. 验证调用者对 `from` 逝者的管理权限
2. 检查是否存在冲突或重复关系
3. 将申请存入 `PendingRelationRequests`
4. 触发 `RelationProposed` 事件

#### 1.3.2 批准关系申请

```rust
#[pallet::call_index(1)]
pub fn approve_relation(
    origin: OriginFor<T>,
    from: u64,           // 申请发起方逝者ID
    to: u64,             // 申请目标方逝者ID（自己管理的逝者）
) -> DispatchResult
```

**权限要求**：
- 调用者必须是 `to` 逝者的管理员

**业务流程**：
1. 从 `PendingRelationRequests` 取出待处理申请
2. 建立双向关系记录：
   - 存储 `from → to` 关系
   - 存储 `to → from` 反向关系（对于无向关系使用规范化键）
3. 更新 `RelationsByDeceased` 索引
4. 清除待处理申请
5. 触发 `RelationApproved` 事件

#### 1.3.3 拒绝关系申请

```rust
#[pallet::call_index(2)]
pub fn reject_relation(
    origin: OriginFor<T>,
    from: u64,
    to: u64,
) -> DispatchResult
```

**权限要求**：
- 调用者必须是 `to` 逝者的管理员

**业务流程**：
- 从 `PendingRelationRequests` 移除申请
- 触发 `RelationRejected` 事件

#### 1.3.4 取消关系申请

```rust
#[pallet::call_index(3)]
pub fn cancel_relation_proposal(
    origin: OriginFor<T>,
    from: u64,           // 必须是调用者管理的逝者
    to: u64,
) -> DispatchResult
```

**权限要求**：
- 仅申请发起者（`from` 的管理员）可以取消

#### 1.3.5 撤销已建立的关系

```rust
#[pallet::call_index(4)]
pub fn revoke_relation(
    origin: OriginFor<T>,
    from: u64,
    to: u64,
) -> DispatchResult
```

**权限要求**：
- 关系任意一方的管理员都可以单方面撤销

**业务流程**：
1. 验证调用者是 `from` 或 `to` 的管理员
2. 移除双向关系记录
3. 更新 `RelationsByDeceased` 索引
4. 触发 `RelationRevoked` 事件

### 1.4 业务规则

#### 1.4.1 关系方向性判断

```rust
fn is_undirected_kind(kind: u8) -> bool {
    matches!(kind, 1 | 2)  // SpouseOf(1), SiblingOf(2) 是无向关系
}
```

#### 1.4.2 关系冲突检测

```rust
fn is_conflicting_kind(a: u8, b: u8) -> bool {
    // 有向关系 (ParentOf/ChildOf) 与无向关系 (SpouseOf/SiblingOf) 冲突
    // ParentOf 与 ChildOf 互为反向关系，视为冲突
}
```

**冲突规则**：
- 同一对逝者不能同时是配偶和父子关系
- 同一对逝者不能同时是兄弟姐妹和父子关系
- ParentOf(0) 与 ChildOf(3) 是相反方向，不能在同一对逝者间同时存在

#### 1.4.3 无向关系的规范化键

对于无向关系 (SpouseOf, SiblingOf)，存储时使用规范化键：

```rust
fn canonical_key(from: u64, to: u64) -> (u64, u64) {
    (min(from, to), max(from, to))
}
```

确保 (A, B) 和 (B, A) 使用同一个存储键，避免重复记录。

### 1.5 前端实现

#### 1.5.1 核心组件

**位置**：`stardust-dapp/src/features/deceased/`

| 组件文件 | 功能说明 |
|---------|----------|
| `RelationshipPage.tsx` | 关系管理主页面，包含列表视图和图形视图 |
| `RelationshipList.tsx` | 关系列表组件，按类型分组展示 |
| `RelationshipGraph.tsx` | 家谱图可视化（SVG力导向图） |
| `RelationProposalManager.tsx` | 关系申请管理（收到/发出的申请） |
| `RelationProposalForm.tsx` | 创建关系申请表单 |

#### 1.5.2 自定义 Hook

**位置**：`stardust-dapp/src/hooks/useRelationships.ts`

```typescript
// 查询单个逝者的所有关系
useRelationships(deceasedId: number)

// 递归查询家谱树（支持多层级）
useRelationshipGraph(rootId: number, maxDepth: number)

// 查询逝者详情
useDeceasedDetail(deceasedId: number)
```

#### 1.5.3 关系列表分组逻辑

前端按以下方式分组展示关系：

```typescript
const groupedRelations = {
  parents: [],      // kind = 0 (ParentOf)
  spouses: [],      // kind = 1 (SpouseOf)
  siblings: [],     // kind = 2 (SiblingOf)
  children: []      // kind = 3 (ChildOf)
}
```

#### 1.5.4 家谱图可视化

**特性**：
- SVG 绘制节点和连线
- 简化的力导向布局算法
- 递归查询最多 3 层关系
- 按性别和关系类型颜色编码
- 支持节点拖拽和缩放

---

## 二、墓地亲缘系统 (pallet-stardust-grave)

### 2.1 亲缘关系类型定义

系统定义了 **11+ 种细粒度亲缘类型**，使用数字编码：

| 编码 | 中文名称 | 英文名 | 类别 |
|------|---------|--------|------|
| **1** | 父亲 | Father | 直系亲属 |
| **2** | 母亲 | Mother | 直系亲属 |
| **3** | 儿子 | Son | 直系亲属 |
| **4** | 女儿 | Daughter | 直系亲属 |
| **5** | 哥哥 | OlderBrother | 旁系亲属 |
| **6** | 弟弟 | YoungerBrother | 旁系亲属 |
| **7** | 姐姐 | OlderSister | 旁系亲属 |
| **8** | 妹妹 | YoungerSister | 旁系亲属 |
| **9** | 配偶 | Spouse | 配偶 |
| **12** | 亲属 | Relative | 其他关系 |
| **13** | 朋友 | Friend | 其他关系 |

### 2.2 数据结构

#### 亲缘记录结构

```rust
pub struct KinshipRecord<T: Config> {
    pub code: u8,                              // 亲缘代码 (1-13+)
    pub note: BoundedVec<u8, T::MaxCidLen>,    // 关系备注
    pub verified: bool,                         // 是否已验证
    pub time: BlockNumberFor<T>,               // 声明时间
}
```

#### 存储映射

```rust
// 亲缘记录：墓地ID -> (逝者ID, 账户ID) -> 亲缘记录
pub type KinshipOf<T> = StorageDoubleMap<u64, (u64, AccountId), KinshipRecord<T>>;

// 亲缘审核策略：墓地ID -> 策略类型
// 0 = 自动批准，1 = 需要管理员审核
pub type KinshipPolicyOf<T> = StorageMap<u64, u8>;
```

### 2.3 核心功能 (Extrinsics)

#### 2.3.1 设置亲缘审核策略

```rust
#[pallet::call_index(X)]
pub fn set_kinship_policy(
    origin: OriginFor<T>,
    grave_id: u64,       // 墓地ID
    policy: u8,          // 0=自动批准, 1=需审核
) -> DispatchResult
```

**权限要求**：
- 仅墓地所有者或管理员可设置

#### 2.3.2 声明亲缘关系

```rust
#[pallet::call_index(Y)]
pub fn declare_kinship(
    origin: OriginFor<T>,
    grave_id: u64,       // 墓地ID
    deceased_id: u64,    // 逝者ID
    code: u8,            // 亲缘代码 (1-13+)
    note: Vec<u8>,       // 关系备注
) -> DispatchResult
```

**权限要求**：
- 调用者必须是墓地成员

**业务流程**：
1. 验证调用者的墓地成员身份
2. 检查该 (墓地, 逝者, 账户) 三元组是否已存在亲缘记录
3. 根据墓地亲缘策略设置 `verified` 状态：
   - 策略为 0（自动批准）→ `verified = true`
   - 策略为 1（需审核）→ `verified = false`
4. 存储亲缘记录
5. 触发 `KinshipDeclared` 事件

### 2.4 业务规则

#### 2.4.1 成员限制

- **仅成员可声明**：必须是墓地成员才能声明亲缘关系
- **唯一性约束**：每个 (墓地ID, 逝者ID, 账户ID) 三元组只能有一条亲缘记录

#### 2.4.2 审核策略

- **策略 0 (自动批准)**：成员声明的亲缘关系自动通过验证
- **策略 1 (需要审核)**：管理员需要手动审核批准

#### 2.4.3 作用域限制

- 亲缘关系绑定到特定墓地和逝者
- 不同墓地中可以对同一逝者声明不同的亲缘关系
- 不影响全局逝者关系系统

### 2.5 前端实现

#### 2.5.1 核心组件

**位置**：`stardust-dapp/src/features/grave/KinshipForm.tsx`

**功能**：
- 简单的亲缘声明表单
- 下拉选择 11 种亲缘类型
- 调用 `memoGrave.declareKinship` 提交声明

**代码示例**：

```typescript
const kinshipOptions = [
  { value: 1, label: '父亲' },
  { value: 2, label: '母亲' },
  { value: 3, label: '儿子' },
  { value: 4, label: '女儿' },
  { value: 5, label: '哥哥' },
  { value: 6, label: '弟弟' },
  { value: 7, label: '姐姐' },
  { value: 8, label: '妹妹' },
  { value: 9, label: '配偶' },
  { value: 12, label: '亲属' },
  { value: 13, label: '朋友' }
];
```

---

## 三、两套系统对比

| 对比维度 | 逝者关系系统 (pallet-deceased) | 墓地亲缘系统 (pallet-stardust-grave) |
|---------|-------------------------------|-----------------------------------|
| **作用域** | 全局，任意两个逝者记录之间 | 限定在 (墓地 + 逝者 + 成员) 范围内 |
| **关系类型** | 4 种基础类型 | 11+ 种细粒度类型 |
| **方向性** | 支持有向/无向关系 | 单向声明（成员→逝者） |
| **审批流程** | 双方管理员审批（提议→批准） | 策略驱动（自动批准或管理员审核） |
| **双向性** | 是（自动建立反向关系） | 否（仅记录声明者视角） |
| **撤销机制** | 任意一方可单方面撤销 | 由墓地所有者/管理员控制 |
| **业务用途** | 正式家族树结构、谱系管理 | 成员身份标识、访问权限依据 |
| **存储位置** | `Relations`, `PendingRelationRequests` | `KinshipOf`, `KinshipPolicyOf` |
| **前端复杂度** | 高（家谱图、多层关系查询） | 低（简单表单声明） |

### 3.1 设计理念差异

#### 逝者关系系统
- **正式性**：建立具有法律/社会认可度的家族关系
- **对称性**：强调关系的双向确认和公证性
- **持久性**：作为逝者身份的重要组成部分长期保存
- **互操作性**：可跨墓地建立全局家族网络

#### 墓地亲缘系统
- **便捷性**：成员快速声明与墓地内逝者的关系
- **灵活性**：不同成员可以有不同视角的关系声明
- **私密性**：关系声明限定在墓地范围内
- **可控性**：管理员可设置审核策略控制声明质量

### 3.2 应用场景

**使用逝者关系系统的场景**：
- 建立正式的家族谱系图
- 跨墓地的亲属关系证明
- 需要双方家族确认的关系
- 家族树可视化和谱系研究

**使用墓地亲缘系统的场景**：
- 墓地访客表明身份和关系
- 成员访问权限的依据
- 墓地内部的社交关系管理
- 快速建立关系标签（无需对方确认）

---

## 四、技术实现细节

### 4.1 关系冲突处理

#### 逝者关系系统冲突矩阵

|       | ParentOf(0) | SpouseOf(1) | SiblingOf(2) | ChildOf(3) |
|-------|-------------|-------------|--------------|------------|
| **ParentOf(0)** | ❌ 重复 | ✅ 允许 | ✅ 允许 | ❌ 冲突 |
| **SpouseOf(1)** | ✅ 允许 | ❌ 重复 | ❌ 冲突 | ✅ 允许 |
| **SiblingOf(2)** | ✅ 允许 | ❌ 冲突 | ❌ 重复 | ✅ 允许 |
| **ChildOf(3)** | ❌ 冲突 | ✅ 允许 | ✅ 允许 | ❌ 重复 |

注：
- ❌ 重复：完全相同的关系类型，不允许重复建立
- ❌ 冲突：逻辑上互斥的关系，不允许同时存在
- ✅ 允许：理论上可以同时存在（但实际业务可能需要进一步限制）

### 4.2 存储键规范化

#### 逝者关系系统

```rust
// 有向关系：直接使用 (from, to) 作为键
Relations::<T>::insert((from_id, to_id), relation);

// 无向关系：使用 min/max 规范化键
let (key1, key2) = if from_id < to_id {
    (from_id, to_id)
} else {
    (to_id, from_id)
};
Relations::<T>::insert((key1, key2), relation);
```

#### 墓地亲缘系统

```rust
// 使用三元组作为复合键
KinshipOf::<T>::insert(
    grave_id,
    (deceased_id, account_id),
    kinship_record
);
```

### 4.3 事件通知

#### 逝者关系系统事件

```rust
pub enum Event<T: Config> {
    RelationProposed { from: u64, to: u64, kind: u8, proposer: T::AccountId },
    RelationApproved { from: u64, to: u64, approver: T::AccountId },
    RelationRejected { from: u64, to: u64, rejector: T::AccountId },
    RelationRevoked { from: u64, to: u64, revoker: T::AccountId },
    ProposalCanceled { from: u64, to: u64, canceler: T::AccountId },
}
```

#### 墓地亲缘系统事件

```rust
pub enum Event<T: Config> {
    KinshipDeclared { grave_id: u64, deceased_id: u64, account: T::AccountId, code: u8, verified: bool },
    KinshipPolicySet { grave_id: u64, policy: u8, setter: T::AccountId },
}
```

---

## 五、最佳实践建议

### 5.1 关系建立流程

#### 建立正式家族关系（推荐流程）

1. **准备阶段**
   - 确认双方逝者记录已创建
   - 确认自己是发起方逝者的管理员
   - 与对方家族协商关系类型

2. **提议阶段**
   - 调用 `deceased.proposeRelation(from, to, kind, note)`
   - 等待对方管理员响应

3. **审批阶段**
   - 对方管理员审核提议
   - 调用 `deceased.approveRelation(from, to)` 批准
   - 或调用 `deceased.rejectRelation(from, to)` 拒绝

4. **确认阶段**
   - 双方在前端查看已建立的关系
   - 关系出现在家谱图中

#### 声明墓地亲缘关系（推荐流程）

1. **加入墓地**
   - 确保自己是墓地成员

2. **声明关系**
   - 在墓地页面找到目标逝者
   - 选择亲缘类型（父亲、母亲等）
   - 填写关系备注（可选）
   - 提交声明

3. **等待验证**（如果墓地策略为需审核）
   - 管理员审核声明
   - 审核通过后 `verified` 变为 `true`

### 5.2 权限管理建议

#### 逝者关系系统

- **最小权限原则**：仅授予可信任的人逝者管理员权限
- **关系审查**：认真审核来自其他家族的关系提议
- **定期复查**：定期检查已建立的关系，撤销不当关系

#### 墓地亲缘系统

- **默认策略**：公共墓地建议设置为"需要审核"（策略 1）
- **私密墓地**：家族私有墓地可设置为"自动批准"（策略 0）
- **成员筛选**：谨慎添加墓地成员，避免虚假关系声明

### 5.3 数据一致性注意事项

1. **两套系统独立**
   - 逝者关系和墓地亲缘不自动同步
   - 需要在业务层面协调一致性

2. **关系类型映射**
   - 前端可建立映射逻辑：
     - 亲缘"父亲"/"母亲" → 关系 ParentOf
     - 亲缘"儿子"/"女儿" → 关系 ChildOf
     - 亲缘"配偶" → 关系 SpouseOf
     - 亲缘"哥哥"/"弟弟"/"姐姐"/"妹妹" → 关系 SiblingOf

3. **冲突处理**
   - 当两套系统对同一对人存在不同关系时，以逝者关系系统为准
   - 墓地亲缘作为补充声明，不影响正式谱系

---

## 六、常见问题 (FAQ)

### Q1: 为什么需要两套关系系统？

**A**: 两套系统服务不同目的：
- **逝者关系系统**：建立正式的、全局的家族谱系网络，需要双方确认，具有公证性
- **墓地亲缘系统**：提供灵活的、局部的关系声明机制，方便成员表明身份和关系

### Q2: 如何选择使用哪套系统？

**A**:
- 需要建立**正式家族树**、**跨墓地谱系** → 使用逝者关系系统
- 需要在**墓地内快速标识关系**、**成员身份管理** → 使用墓地亲缘系统
- 两套系统可以**同时使用**，互不冲突

### Q3: 逝者关系中的"朋友"关系怎么表示？

**A**: 当前逝者关系系统（4种类型）不包含"朋友"关系。如需表达：
- 方案 1：使用墓地亲缘系统的"朋友"代码（13）
- 方案 2：考虑扩展逝者关系系统增加"朋友"类型（需修改 pallet 代码）

### Q4: 能否撤销已批准的逝者关系？

**A**: 可以。任意一方的管理员都可以调用 `revoke_relation` 单方面撤销关系。

### Q5: 墓地亲缘审核策略何时生效？

**A**: 策略在成员声明亲缘时立即生效：
- 策略设置为 0（自动批准）时，新声明的 `verified` 自动为 `true`
- 策略设置为 1（需审核）时，新声明的 `verified` 初始为 `false`
- **注意**：修改策略不影响已存在的亲缘记录

### Q6: 如何防止虚假关系？

**A**:
- **逝者关系系统**：通过双方管理员审批机制防止单方面虚假声明
- **墓地亲缘系统**：通过审核策略和成员管理机制控制
- **建议**：重要关系使用逝者关系系统，日常访客标识使用墓地亲缘系统

---

## 七、未来优化方向

### 7.1 功能增强

1. **关系类型扩展**
   - 逝者关系系统增加"朋友"、"同学"、"战友"等类型
   - 支持自定义关系类型

2. **关系证明机制**
   - 引入关系证明文档（IPFS 存储）
   - 增加第三方见证机制

3. **关系时间线**
   - 记录关系的起始和结束时间
   - 支持历史关系查询

### 7.2 性能优化

1. **关系图查询优化**
   - 实现关系缓存层
   - 优化多层级递归查询

2. **索引结构优化**
   - 增加反向索引加速查询
   - 实现关系统计缓存

### 7.3 用户体验改进

1. **智能关系推荐**
   - 基于已有关系推荐可能的亲属
   - 关系冲突实时提示

2. **批量操作支持**
   - 批量导入家族关系
   - 家族树模板导入

3. **隐私控制**
   - 关系可见性设置
   - 关系公开范围控制

---

## 八、技术参考

### 8.1 代码位置

#### 链端代码
- 逝者关系 Pallet: `/pallets/deceased/src/lib.rs`
- 墓地亲缘 Pallet: `/pallets/stardust-grave/src/lib.rs`

#### 前端代码
- 逝者关系组件: `/stardust-dapp/src/features/deceased/`
- 墓地亲缘组件: `/stardust-dapp/src/features/grave/KinshipForm.tsx`
- 关系 Hooks: `/stardust-dapp/src/hooks/useRelationships.ts`

### 8.2 相关文档

- Polkadot SDK 文档: https://docs.substrate.io
- Substrate Storage 指南: https://docs.substrate.io/build/runtime-storage/
- React Query 文档: https://tanstack.com/query/latest

---

## 附录：完整 API 参考

### A.1 逝者关系系统 API

```rust
// ===== 可调用函数 (Extrinsics) =====

/// 提出关系申请
propose_relation(origin, from: u64, to: u64, kind: u8, note_cid: Vec<u8>)

/// 批准关系申请
approve_relation(origin, from: u64, to: u64)

/// 拒绝关系申请
reject_relation(origin, from: u64, to: u64)

/// 取消关系申请
cancel_relation_proposal(origin, from: u64, to: u64)

/// 撤销已建立的关系
revoke_relation(origin, from: u64, to: u64)

// ===== 存储查询 (Storage Queries) =====

/// 查询关系记录
Relations(from_id, to_id) -> Option<Relation>

/// 查询逝者的所有关系
RelationsByDeceased(deceased_id) -> Option<Vec<(u64, u8)>>

/// 查询待处理的关系申请
PendingRelationRequests(from_id, to_id) -> Option<(u8, AccountId, Vec<u8>, BlockNumber)>
```

### A.2 墓地亲缘系统 API

```rust
// ===== 可调用函数 (Extrinsics) =====

/// 设置亲缘审核策略
set_kinship_policy(origin, grave_id: u64, policy: u8)

/// 声明亲缘关系
declare_kinship(origin, grave_id: u64, deceased_id: u64, code: u8, note: Vec<u8>)

// ===== 存储查询 (Storage Queries) =====

/// 查询亲缘记录
KinshipOf(grave_id, (deceased_id, account_id)) -> Option<KinshipRecord>

/// 查询墓地亲缘策略
KinshipPolicyOf(grave_id) -> Option<u8>
```

---

## 文档版本

- **版本**: v1.0
- **日期**: 2025-11-09
- **作者**: Stardust 开发团队
- **基于代码版本**: Runtime spec_version 101

---

*本文档详细描述了 Stardust 纪念园系统中的两套关系管理系统。如有疑问或建议，请联系开发团队。*
