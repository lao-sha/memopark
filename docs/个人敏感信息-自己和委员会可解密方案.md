# 个人敏感信息 - 自己和委员会可解密方案

## 一、需求分析

### 场景描述

**用户存储个人敏感信息：**
- 生日
- 身份证号
- 真实姓名
- 家庭住址
- 银行卡号

**解密权限：**
- ✅ 用户自己可以解密（随时查看、修改、删除）
- ✅ 委员会成员可以解密（审核、仲裁、KYC验证）
- ❌ 其他普通用户不能解密

---

## 二、可行性分析

### ✅ 技术完全可行

#### 方案：混合加密（对称加密 + 多接收方非对称加密）

```typescript
┌─────────────────────────────────────────────────┐
│                  用户（数据拥有者）                 │
│                                                  │
│  1. 生成随机AES密钥（32字节）                     │
│  2. 用AES密钥加密原始数据                         │
│  3. 获取授权接收方公钥：                          │
│     - 自己的公钥                                 │
│     - 所有委员会成员的公钥                        │
│  4. 为每个接收方用其公钥加密AES密钥               │
│  5. 上传到IPFS：                                 │
│     - encrypted_content: AES加密的数据            │
│     - encrypted_keys: {                         │
│         "用户地址": "用户公钥加密的AES密钥",       │
│         "委员A": "委员A公钥加密的AES密钥",        │
│         "委员B": "委员B公钥加密的AES密钥",        │
│         ...                                     │
│       }                                         │
└─────────────┬───────────────────────────────────┘
              │
              ↓
┌─────────────────────────────────────────────────┐
│             Pallet（链上记录层）                  │
│                                                  │
│  ✅ 存储：CID（IPFS位置）                        │
│  ✅ 存储：content_hash（验证完整性）             │
│  ✅ 存储：authorized_recipients（授权列表）      │
│  ✅ 存储：访问日志                               │
│  ❌ 不存储：任何私钥或明文数据                    │
└─────────────┬───────────────────────────────────┘
              │
              ↓
┌─────────────────────────────────────────────────┐
│          授权用户解密（用户自己 or 委员）          │
│                                                  │
│  1. 检查权限：是否在授权列表中                    │
│  2. 从IPFS下载加密数据                           │
│  3. 找到自己的加密密钥包                         │
│  4. 用自己的私钥解密得到AES密钥                   │
│  5. 用AES密钥解密数据                            │
│  6. 验证哈希                                     │
└─────────────────────────────────────────────────┘
```

**核心优势：**
- ✅ 数据只加密一次（AES加密）
- ✅ 每个授权用户都可以独立解密
- ✅ 新增委员会成员只需加密一个新的密钥包
- ✅ 撤销权限只需从授权列表中移除

---

## 三、合理性分析

### 业务场景1：做市商申请审核

#### 为什么需要委员会解密？

```
做市商申请流程：
1. 做市商提交申请 → 填写完整身份信息
2. 委员会审核 → 需要查看真实身份验证
3. 批准/拒绝 → 基于真实信息做决策
```

**如果委员会不能解密：**
- ❌ 无法验证身份真实性
- ❌ 无法防止欺诈
- ❌ 无法进行KYC/AML合规检查
- ❌ 出问题后无法追责

**委员会可以解密：**
- ✅ 验证申请人真实身份
- ✅ 检查是否有犯罪记录
- ✅ 验证银行账户真实性
- ✅ 防止重复申请
- ✅ 出现欺诈可以追责

---

### 业务场景2：OTC订单争议仲裁

#### 为什么需要委员会解密？

```
OTC争议流程：
1. 买家投诉做市商未打款
2. 做市商声称已打款到买家账户
3. 委员会仲裁 → 需要查看双方真实身份和银行信息
4. 核实转账记录 → 匹配身份信息
```

**如果委员会不能解密：**
- ❌ 无法核实打款目标账户
- ❌ 无法验证转账截图真实性
- ❌ 无法联系双方协调
- ❌ 无法公正仲裁

**委员会可以解密：**
- ✅ 核实双方真实身份
- ✅ 验证银行转账记录
- ✅ 联系双方线下协调
- ✅ 做出公正裁决

---

### 业务场景3：异常行为调查

#### 为什么需要委员会解密？

```
风控场景：
1. 检测到可疑交易（如洗钱、诈骗）
2. 委员会启动调查
3. 需要查看涉案账户真实身份
4. 配合执法机关处理
```

**如果委员会不能解密：**
- ❌ 无法调查可疑交易
- ❌ 无法配合执法
- ❌ 平台面临合规风险
- ❌ 无法保护其他用户

**委员会可以解密：**
- ✅ 及时发现并阻止违法行为
- ✅ 配合执法机关
- ✅ 保护平台和其他用户
- ✅ 满足合规要求

---

### 业务场景4：用户资料修改审核

#### 为什么需要委员会解密？

```
资料修改场景：
1. 做市商想修改身份信息
2. 需要验证新旧身份的关联性
3. 防止账户买卖和冒用
```

**如果委员会不能解密：**
- ❌ 无法验证修改的合理性
- ❌ 无法防止账户买卖
- ❌ 无法防止身份冒用

**委员会可以解密：**
- ✅ 验证新旧身份一致性
- ✅ 防止账户转让
- ✅ 保护平台信用体系

---

## 四、隐私保护平衡

### 对比方案

| 方案 | 用户隐私 | 平台治理 | 合规要求 | 推荐度 |
|------|---------|---------|---------|-------|
| **只有自己可解密** | 🟢 极高 | 🔴 无法治理 | 🔴 不合规 | ❌ 不推荐 |
| **自己+委员会可解密（当前）** | 🟡 较高 | 🟢 可治理 | 🟢 合规 | ✅ 推荐 |
| **公开（不加密）** | 🔴 无隐私 | 🟢 可治理 | 🟡 过度公开 | ❌ 不推荐 |

---

### 隐私保护机制

#### ① 访问审计（必须实现）

```rust
/// 委员会成员访问敏感信息时，必须记录日志
#[pallet::call_index(10)]
pub fn log_access(
    origin: OriginFor<T>,
    data_owner: T::AccountId,
    data_type: Vec<u8>,
    purpose: Vec<u8>,  // "kyc_review", "dispute_investigation", etc.
) -> DispatchResult {
    let who = ensure_signed(origin)?;
    
    // 验证是委员会成员
    ensure!(
        Self::is_committee_member(&who),
        Error::<T>::NotCommitteeMember
    );
    
    let now = <frame_system::Pallet<T>>::block_number();
    
    // 记录访问日志
    AccessLogs::<T>::try_mutate(&data_owner, &data_type, |logs| -> DispatchResult {
        logs.try_push(AccessRecord {
            accessor: who.clone(),
            accessed_at: now,
            purpose: purpose.try_into().map_err(|_| Error::<T>::PurposeTooLong)?,
        })
        .map_err(|_| Error::<T>::TooManyAccessRecords)?;
        Ok(())
    })?;
    
    // 发送事件（链上可查）
    Self::deposit_event(Event::SensitiveDataAccessed {
        data_owner,
        accessor: who,
        purpose,
        timestamp: now,
    });
    
    Ok(())
}
```

**效果：**
- ✅ 用户可以查看谁访问过自己的信息
- ✅ 委员会成员必须说明访问目的
- ✅ 链上永久记录，不可篡改
- ✅ 威慑滥用权限

---

#### ② 访问权限分级

```rust
pub enum AccessLevel {
    /// 基础信息（姓名、生日）- 所有委员会成员
    Basic,
    
    /// 敏感信息（身份证、地址）- 需要2/3委员会成员同意
    Sensitive,
    
    /// 核心机密（银行卡）- 需要Root + 委员会主席同意
    Critical,
}

pub struct SensitiveDataAccess<T: Config> {
    pub data_owner: T::AccountId,
    pub data_type: Vec<u8>,
    pub access_level: AccessLevel,
    pub required_approvals: u32,
    pub approvals: BoundedVec<T::AccountId, ConstU32<50>>,
}
```

**效果：**
- ✅ 不同敏感度的信息有不同的访问门槛
- ✅ 防止单个委员会成员滥用权限
- ✅ 重要信息需要多人共识才能查看

---

#### ③ 定期审查和问责

```rust
/// 每季度生成访问报告
pub fn generate_access_report(
    quarter: u32,
) -> BoundedVec<AccessSummary, ConstU32<1000>> {
    // 统计每个委员会成员的访问次数
    // 标记异常访问（如频繁访问、非工作时间访问）
    // 公开给所有用户查看
}
```

**效果：**
- ✅ 定期公开委员会访问统计
- ✅ 用户可以监督委员会行为
- ✅ 异常访问行为会被标记

---

## 五、实施方案

### 5.1 数据结构

```rust
/// 函数级详细中文注释：敏感个人数据元数据
#[derive(Clone, Encode, Decode, PartialEq, RuntimeDebug, TypeInfo, MaxEncodedLen)]
pub struct SensitivePersonalData<AccountId, BlockNumber> {
    /// 数据拥有者
    pub owner: AccountId,
    
    /// 数据类型（"identity", "financial", "medical"）
    pub data_type: BoundedVec<u8, ConstU32<32>>,
    
    /// IPFS CID（多接收方加密数据）
    pub cid: BoundedVec<u8, ConstU32<64>>,
    
    /// 原始数据哈希
    pub content_hash: H256,
    
    /// 授权接收方列表
    /// - 永远包含数据拥有者自己
    /// - 包含所有当前委员会成员
    pub authorized_recipients: BoundedVec<AccountId, ConstU32<50>>,
    
    /// 访问级别
    pub access_level: AccessLevel,
    
    /// 创建时间
    pub created_at: BlockNumber,
    
    /// 最后更新时间
    pub updated_at: BlockNumber,
}

/// 函数级详细中文注释：访问记录
#[derive(Clone, Encode, Decode, PartialEq, RuntimeDebug, TypeInfo, MaxEncodedLen)]
pub struct AccessRecord<AccountId, BlockNumber> {
    /// 访问者
    pub accessor: AccountId,
    
    /// 访问时间
    pub accessed_at: BlockNumber,
    
    /// 访问目的
    pub purpose: BoundedVec<u8, ConstU32<256>>,
    
    /// 访问结果（是否成功解密）
    pub success: bool,
}
```

---

### 5.2 核心接口

#### ① 用户存储敏感数据

```rust
/// 函数级详细中文注释：存储敏感个人数据
/// 
/// 用户提交加密的个人信息，自动授权给自己和所有委员会成员
/// 
/// # 参数
/// - data_type: 数据类型（如 "identity"）
/// - cid: IPFS CID（多接收方加密数据）
/// - content_hash: 原始数据哈希
/// - access_level: 访问级别
#[pallet::call_index(0)]
#[pallet::weight(10_000)]
pub fn store_sensitive_data(
    origin: OriginFor<T>,
    data_type: Vec<u8>,
    cid: Vec<u8>,
    content_hash: H256,
    access_level: AccessLevel,
) -> DispatchResult {
    let who = ensure_signed(origin)?;
    
    // 获取当前所有委员会成员
    let committee_members = Self::get_committee_members();
    
    // 构建授权列表：用户自己 + 所有委员会成员
    let mut authorized_recipients = BoundedVec::new();
    authorized_recipients.try_push(who.clone())
        .map_err(|_| Error::<T>::TooManyRecipients)?;
    
    for member in committee_members {
        authorized_recipients.try_push(member)
            .map_err(|_| Error::<T>::TooManyRecipients)?;
    }
    
    let now = <frame_system::Pallet<T>>::block_number();
    
    let data = SensitivePersonalData {
        owner: who.clone(),
        data_type: data_type.clone().try_into().map_err(|_| Error::<T>::DataTypeTooLong)?,
        cid: cid.clone().try_into().map_err(|_| Error::<T>::CidTooLong)?,
        content_hash,
        authorized_recipients,
        access_level,
        created_at: now,
        updated_at: now,
    };
    
    // 存储
    SensitiveData::<T>::insert(&who, &data_type, data);
    
    Self::deposit_event(Event::SensitiveDataStored {
        owner: who,
        data_type,
        cid,
        access_level,
    });
    
    Ok(())
}
```

---

#### ② 委员会成员访问数据（需记录日志）

```rust
/// 函数级详细中文注释：访问敏感数据
/// 
/// 委员会成员访问用户的敏感信息，必须说明访问目的，链上记录日志
/// 
/// # 参数
/// - data_owner: 数据拥有者账户
/// - data_type: 数据类型
/// - purpose: 访问目的（如 "kyc_review", "dispute_investigation"）
#[pallet::call_index(1)]
#[pallet::weight(10_000)]
pub fn access_sensitive_data(
    origin: OriginFor<T>,
    data_owner: T::AccountId,
    data_type: Vec<u8>,
    purpose: Vec<u8>,
) -> DispatchResult {
    let who = ensure_signed(origin)?;
    
    // 获取数据
    let data = SensitiveData::<T>::get(&data_owner, &data_type)
        .ok_or(Error::<T>::DataNotFound)?;
    
    // 检查权限：是数据拥有者本人 或 委员会成员
    let is_owner = who == data_owner;
    let is_committee = Self::is_committee_member(&who);
    
    ensure!(
        is_owner || is_committee,
        Error::<T>::NotAuthorized
    );
    
    // 如果是委员会成员访问，记录日志
    if is_committee && !is_owner {
        let now = <frame_system::Pallet<T>>::block_number();
        
        AccessLogs::<T>::try_mutate(&data_owner, &data_type, |logs| -> DispatchResult {
            logs.try_push(AccessRecord {
                accessor: who.clone(),
                accessed_at: now,
                purpose: purpose.clone().try_into().map_err(|_| Error::<T>::PurposeTooLong)?,
                success: true,
            })
            .map_err(|_| Error::<T>::TooManyAccessRecords)?;
            Ok(())
        })?;
        
        // 发送事件
        Self::deposit_event(Event::SensitiveDataAccessed {
            data_owner: data_owner.clone(),
            accessor: who.clone(),
            data_type: data_type.clone(),
            purpose: purpose.clone(),
        });
        
        // 通知数据拥有者（链下通知）
        // 用户可以在前端看到谁查看了自己的信息
    }
    
    Ok(())
}
```

---

#### ③ 用户查看访问日志

```rust
/// 函数级详细中文注释：查询访问日志
/// 
/// 用户查看谁访问过自己的敏感信息
#[pallet::storage]
pub type AccessLogs<T: Config> = StorageDoubleMap<
    _,
    Blake2_128Concat,
    T::AccountId,           // 数据拥有者
    Blake2_128Concat,
    Vec<u8>,                // 数据类型
    BoundedVec<AccessRecord<T::AccountId, BlockNumberFor<T>>, ConstU32<100>>,
    ValueQuery,
>;

// 前端查询示例
const logs = await api.query.sensitiveData.accessLogs(
  myAccount,
  'identity'
);

console.log('谁访问过我的身份信息：', logs);
/*
[
  {
    accessor: "委员A",
    accessed_at: 12345,
    purpose: "做市商KYC审核",
    success: true
  },
  {
    accessor: "委员B",
    accessed_at: 12389,
    purpose: "OTC争议调查",
    success: true
  }
]
*/
```

---

### 5.3 前端完整示例

```typescript
// src/components/SensitiveDataManager.tsx

import React, { useState, useEffect } from 'react';
import { Form, Input, Button, Card, Table, Alert, Modal } from 'antd';
import { useApi, useAccount } from '@/hooks';

export const SensitiveDataManager: React.FC = () => {
  const { api } = useApi();
  const { account } = useAccount();
  const [accessLogs, setAccessLogs] = useState<any[]>([]);
  
  /**
   * 保存敏感信息（自己 + 委员会可解密）
   */
  const handleSave = async (values: any) => {
    // 1. 获取委员会成员列表
    const committeeMembers = await api.query.collective.members(3); // Instance3
    
    // 2. 获取所有授权用户的公钥
    const recipients = new Map();
    
    // 用户自己的公钥
    const myPubKey = await api.query.evidence.userPublicKeys(account.address);
    if (myPubKey.isSome) {
      recipients.set(account.address, myPubKey.unwrap().keyData);
    }
    
    // 所有委员会成员的公钥
    for (const member of committeeMembers) {
      const pubKey = await api.query.evidence.userPublicKeys(member);
      if (pubKey.isSome) {
        recipients.set(member.toString(), pubKey.unwrap().keyData);
      }
    }
    
    console.log(`✅ 将加密给 ${recipients.size} 个接收方：`);
    console.log('- 我自己');
    console.log(`- ${committeeMembers.length} 个委员会成员`);
    
    // 3. 准备数据
    const sensitiveData = {
      full_name: values.full_name,
      id_card: values.id_card,
      birthday: values.birthday,
      address: values.address,
      phone: values.phone,
    };
    
    // 4. 生成随机AES密钥
    const aesKey = crypto.randomBytes(32);
    
    // 5. 用AES加密数据
    const encryptedData = aesEncrypt(JSON.stringify(sensitiveData), aesKey);
    const contentHash = sha256(JSON.stringify(sensitiveData));
    
    // 6. 为每个接收方加密AES密钥
    const encryptedKeys: any = {};
    for (const [accountId, publicKey] of recipients) {
      const encryptedAesKey = rsaEncrypt(aesKey, publicKey);
      encryptedKeys[accountId] = encryptedAesKey;
    }
    
    // 7. 上传到IPFS
    const ipfsData = {
      version: '1.0',
      encrypted_content: encryptedData,
      encrypted_keys: encryptedKeys,
      metadata: {
        encrypted_at: Date.now(),
        encryptor: account.address,
      },
    };
    
    const result = await ipfs.add(JSON.stringify(ipfsData));
    const cid = result.path;
    
    console.log('✅ 加密数据已上传到IPFS:', cid);
    
    // 8. 调用链上接口
    await api.tx.sensitiveData.storeSensitiveData(
      'identity',           // 数据类型
      cid,                  // IPFS CID
      contentHash,          // 哈希
      'Sensitive'           // 访问级别：敏感
    ).signAndSend(account, ({ status }) => {
      if (status.isInBlock) {
        Modal.success({
          title: '✅ 保存成功',
          content: (
            <div>
              <p>您的敏感信息已加密保存</p>
              <p><strong>可以解密的人：</strong></p>
              <ul>
                <li>✅ 您自己（随时查看）</li>
                <li>✅ {committeeMembers.length} 位委员会成员（审核/仲裁时查看）</li>
              </ul>
              <Alert 
                message="隐私保护" 
                description="委员会成员访问您的信息时，会在链上记录访问日志，您可以随时查看。"
                type="info"
              />
            </div>
          ),
        });
      }
    });
  };
  
  /**
   * 查看访问日志
   */
  const loadAccessLogs = async () => {
    const logs = await api.query.sensitiveData.accessLogs(
      account.address,
      'identity'
    );
    
    const formattedLogs = logs.map((log: any) => ({
      accessor: log.accessor.toString(),
      accessedAt: new Date(log.accessed_at.toNumber() * 6000).toLocaleString(),
      purpose: new TextDecoder().decode(log.purpose),
      success: log.success,
    }));
    
    setAccessLogs(formattedLogs);
  };
  
  useEffect(() => {
    loadAccessLogs();
  }, []);
  
  return (
    <div style={{ maxWidth: 1000, margin: '0 auto', padding: 24 }}>
      <Card title="🔒 敏感个人信息">
        <Alert
          message="隐私说明"
          description={
            <div>
              <p>您的敏感信息将被加密保存，只有以下人员可以解密：</p>
              <ul>
                <li>✅ <strong>您自己</strong> - 随时查看、修改、删除</li>
                <li>✅ <strong>委员会成员</strong> - 在以下情况查看：
                  <ul>
                    <li>做市商申请审核</li>
                    <li>OTC订单争议仲裁</li>
                    <li>异常行为调查</li>
                  </ul>
                </li>
              </ul>
              <p><strong>隐私保护措施：</strong></p>
              <ul>
                <li>✅ 委员会成员访问时必须记录目的</li>
                <li>✅ 所有访问记录链上可查</li>
                <li>✅ 您可以随时查看谁访问了您的信息</li>
              </ul>
            </div>
          }
          type="info"
          style={{ marginBottom: 24 }}
        />
        
        <Form onFinish={handleSave} layout="vertical">
          <Form.Item
            label="姓名"
            name="full_name"
            rules={[{ required: true }]}
          >
            <Input placeholder="张三" />
          </Form.Item>
          
          <Form.Item
            label="身份证号"
            name="id_card"
            rules={[{ required: true }]}
          >
            <Input placeholder="110101199001011234" />
          </Form.Item>
          
          <Form.Item
            label="生日"
            name="birthday"
            rules={[{ required: true }]}
          >
            <Input type="date" />
          </Form.Item>
          
          <Form.Item label="地址" name="address">
            <Input.TextArea placeholder="北京市朝阳区..." />
          </Form.Item>
          
          <Form.Item label="手机号" name="phone">
            <Input placeholder="13800138000" />
          </Form.Item>
          
          <Form.Item>
            <Button type="primary" htmlType="submit" block>
              加密保存（我自己 + 委员会可解密）
            </Button>
          </Form.Item>
        </Form>
      </Card>
      
      <Card 
        title="📋 访问日志" 
        style={{ marginTop: 24 }}
        extra={<Button onClick={loadAccessLogs}>刷新</Button>}
      >
        <Alert
          message="您可以查看谁访问过您的敏感信息"
          type="info"
          style={{ marginBottom: 16 }}
        />
        
        <Table
          dataSource={accessLogs}
          columns={[
            {
              title: '访问者',
              dataIndex: 'accessor',
              key: 'accessor',
              render: (text) => <code>{text.slice(0, 10)}...</code>,
            },
            {
              title: '访问时间',
              dataIndex: 'accessedAt',
              key: 'accessedAt',
            },
            {
              title: '访问目的',
              dataIndex: 'purpose',
              key: 'purpose',
            },
            {
              title: '状态',
              dataIndex: 'success',
              key: 'success',
              render: (success) => success ? '✅ 成功' : '❌ 失败',
            },
          ]}
          pagination={false}
        />
        
        {accessLogs.length === 0 && (
          <div style={{ textAlign: 'center', padding: 40, color: '#999' }}>
            暂无访问记录
          </div>
        )}
      </Card>
    </div>
  );
};
```

---

## 六、总结

### ✅ 可行性结论

**技术完全可行**，使用现有的 evidence pallet 即可实现。

**实现方案：**
1. ✅ 用户生成AES密钥加密数据
2. ✅ 为自己和所有委员会成员加密AES密钥
3. ✅ 上传到IPFS，链上存储元数据
4. ✅ 授权用户用各自私钥解密

---

### ✅ 合理性结论

**业务上合理且必要**，原因如下：

#### 1. **平台治理需要**
- ✅ 做市商KYC审核
- ✅ OTC争议仲裁
- ✅ 异常行为调查
- ✅ 防止欺诈和洗钱

#### 2. **合规要求**
- ✅ 满足金融监管KYC要求
- ✅ 配合执法机关调查
- ✅ 防止平台被滥用

#### 3. **隐私保护**
- ✅ 访问审计（链上记录）
- ✅ 访问分级（不同级别不同门槛）
- ✅ 定期公开访问报告
- ✅ 用户可监督委员会行为

#### 4. **权限平衡**
| 角色 | 权限 | 限制 |
|-----|-----|-----|
| **用户** | 随时查看/修改/删除 | - |
| **委员会** | 特定场景查看 | 必须记录访问日志 + 说明目的 |
| **普通用户** | 无权限 | - |

---

### 建议实施

1. ✅ **使用现有的 evidence pallet**（已有基础设施）
2. ✅ **强制访问审计**（委员会访问必须记录）
3. ✅ **前端提示**（明确告知用户委员会可访问）
4. ✅ **定期公开报告**（增加透明度）
5. ⚠️ **考虑分级访问**（不同敏感度不同门槛）

---

**编写日期**：2025-10-23  
**版本**：v1.0  
**状态**：实施方案  
**结论**：✅ 技术可行 + ✅ 业务合理

