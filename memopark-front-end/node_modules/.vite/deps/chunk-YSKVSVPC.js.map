{
  "version": 3,
  "sources": ["../../@polkadot/keyring/index.js", "../../@polkadot/keyring/packageDetect.js", "../../@polkadot/keyring/packageInfo.js", "../../@polkadot/keyring/bundle.js", "../../@polkadot/keyring/keyring.js", "../../@polkadot/keyring/pair/index.js", "../../@polkadot/keyring/pair/decode.js", "../../@polkadot/keyring/pair/defaults.js", "../../@polkadot/keyring/pair/encode.js", "../../@polkadot/keyring/pair/toJson.js", "../../@polkadot/keyring/defaults.js", "../../@polkadot/keyring/pairs.js", "../../@polkadot/keyring/testing.js", "../../@polkadot/keyring/testingPairs.js", "../../@polkadot/keyring/pair/nobody.js"],
  "sourcesContent": ["import './packageDetect.js';\nimport { Keyring } from './bundle.js';\nexport * from './bundle.js';\nexport default Keyring;\n", "import { detectPackage } from '@polkadot/util';\nimport { packageInfo as utilInfo } from '@polkadot/util/packageInfo';\nimport { packageInfo as cryptoInfo } from '@polkadot/util-crypto/packageInfo';\nimport { packageInfo } from './packageInfo.js';\ndetectPackage(packageInfo, null, [cryptoInfo, utilInfo]);\n", "export const packageInfo = { name: '@polkadot/keyring', path: (import.meta && import.meta.url) ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf('/') + 1) : 'auto', type: 'esm', version: '13.5.6' };\n", "export { decodeAddress, encodeAddress, setSS58Format } from '@polkadot/util-crypto';\nexport { Keyring } from './keyring.js';\nexport { packageInfo } from './packageInfo.js';\nexport { createPair } from './pair/index.js';\nexport { createTestKeyring } from './testing.js';\nexport { createTestPairs } from './testingPairs.js';\nexport * from './defaults.js';\n", "import { hexToU8a, isHex, stringToU8a } from '@polkadot/util';\nimport { base64Decode, decodeAddress, ed25519PairFromSeed as ed25519FromSeed, encodeAddress, ethereumEncode, hdEthereum, keyExtractSuri, keyFromPath, mnemonicToLegacySeed, mnemonicToMiniSecret, secp256k1PairFromSeed as secp256k1FromSeed, sr25519PairFromSeed as sr25519FromSeed } from '@polkadot/util-crypto';\nimport { createPair } from './pair/index.js';\nimport { DEV_PHRASE } from './defaults.js';\nimport { Pairs } from './pairs.js';\nconst PairFromSeed = {\n    ecdsa: (seed) => secp256k1FromSeed(seed),\n    ed25519: (seed) => ed25519FromSeed(seed),\n    ethereum: (seed) => secp256k1FromSeed(seed),\n    sr25519: (seed) => sr25519FromSeed(seed)\n};\nfunction pairToPublic({ publicKey }) {\n    return publicKey;\n}\n/**\n * # @polkadot/keyring\n *\n * ## Overview\n *\n * @name Keyring\n * @summary Keyring management of user accounts\n * @description Allows generation of keyring pairs from a variety of input combinations, such as\n * json object containing account address or public key, account metadata, and account encoded using\n * `addFromJson`, or by providing those values as arguments separately to `addFromAddress`,\n * or by providing the mnemonic (seed phrase) and account metadata as arguments to `addFromMnemonic`.\n * Stores the keyring pairs in a keyring pair dictionary. Removal of the keyring pairs from the keyring pair\n * dictionary is achieved using `removePair`. Retrieval of all the stored pairs via `getPairs` or perform\n * lookup of a pair for a given account address or public key using `getPair`. JSON metadata associated with\n * an account may be obtained using `toJson` accompanied by the account passphrase.\n */\nexport class Keyring {\n    #pairs;\n    #type;\n    #ss58;\n    decodeAddress = decodeAddress;\n    constructor(options = {}) {\n        options.type = options.type || 'ed25519';\n        if (!['ecdsa', 'ethereum', 'ed25519', 'sr25519'].includes(options.type || 'undefined')) {\n            throw new Error(`Expected a keyring type of either 'ed25519', 'sr25519', 'ethereum' or 'ecdsa', found '${options.type || 'unknown'}`);\n        }\n        this.#pairs = new Pairs();\n        this.#ss58 = options.ss58Format;\n        this.#type = options.type;\n    }\n    /**\n     * @description retrieve the pairs (alias for getPairs)\n     */\n    get pairs() {\n        return this.getPairs();\n    }\n    /**\n     * @description retrieve the publicKeys (alias for getPublicKeys)\n     */\n    get publicKeys() {\n        return this.getPublicKeys();\n    }\n    /**\n     * @description Returns the type of the keyring, ed25519, sr25519 or ecdsa\n     */\n    get type() {\n        return this.#type;\n    }\n    /**\n     * @name addPair\n     * @summary Stores an account, given a keyring pair, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     */\n    addPair(pair) {\n        return this.#pairs.add(pair);\n    }\n    /**\n     * @name addFromAddress\n     * @summary Stores an account, given an account address, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Allows user to explicitly provide separate inputs including account address or public key, and optionally\n     * the associated account metadata, and the default encoded value as arguments (that may be obtained from the json file\n     * of an account backup), and then generates a keyring pair from them that it passes to\n     * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n    addFromAddress(address, meta = {}, encoded = null, type = this.type, ignoreChecksum, encType) {\n        const publicKey = this.decodeAddress(address, ignoreChecksum);\n        return this.addPair(createPair({ toSS58: this.encodeAddress, type }, { publicKey, secretKey: new Uint8Array() }, meta, encoded, encType));\n    }\n    /**\n     * @name addFromJson\n     * @summary Stores an account, given JSON data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Allows user to provide a json object argument that contains account information (that may be obtained from the json file\n     * of an account backup), and then generates a keyring pair from it that it passes to\n     * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n    addFromJson(json, ignoreChecksum) {\n        return this.addPair(this.createFromJson(json, ignoreChecksum));\n    }\n    /**\n     * @name addFromMnemonic\n     * @summary Stores an account, given a mnemonic, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Allows user to provide a mnemonic (seed phrase that is provided when account is originally created)\n     * argument and a metadata argument that contains account information (that may be obtained from the json file\n     * of an account backup), and then generates a keyring pair from it that it passes to\n     * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n    addFromMnemonic(mnemonic, meta = {}, type = this.type, wordlist) {\n        return this.addFromUri(mnemonic, meta, type, wordlist);\n    }\n    /**\n     * @name addFromPair\n     * @summary Stores an account created from an explicit publicKey/secreteKey combination\n     */\n    addFromPair(pair, meta = {}, type = this.type) {\n        return this.addPair(this.createFromPair(pair, meta, type));\n    }\n    /**\n     * @name addFromSeed\n     * @summary Stores an account, given seed data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Stores in a keyring pair dictionary the public key of the pair as a key and the pair as the associated value.\n     * Allows user to provide the account seed as an argument, and then generates a keyring pair from it that it passes to\n     * `addPair` to store in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n    addFromSeed(seed, meta = {}, type = this.type) {\n        return this.addPair(createPair({ toSS58: this.encodeAddress, type }, PairFromSeed[type](seed), meta, null));\n    }\n    /**\n     * @name addFromUri\n     * @summary Creates an account via an suri\n     * @description Extracts the phrase, path and password from a SURI format for specifying secret keys `<secret>/<soft-key>//<hard-key>///<password>` (the `///password` may be omitted, and `/<soft-key>` and `//<hard-key>` maybe repeated and mixed). The secret can be a hex string, mnemonic phrase or a string (to be padded)\n     * @param _suri\n     * @param meta\n     * @param type The supported types of pairs. Either 'ed25519' | 'sr25519' | 'ecdsa' | 'ethereum'.\n     * @param wordlist - Optional custom wordlist for mnemonic.\n     * @param rounds - Optional: Number of PBKDF2 iterations to run (default: 210000 (when onlyJS = true) or 2048 (when onlyJS = false).\n    */\n    addFromUri(suri, meta = {}, type = this.type, wordlist, rounds) {\n        return this.addPair(this.createFromUri(suri, meta, type, wordlist, rounds));\n    }\n    /**\n     * @name createFromJson\n     * @description Creates a pair from a JSON keyfile\n     */\n    createFromJson({ address, encoded, encoding: { content, type, version }, meta }, ignoreChecksum) {\n        if (version === '3' && content[0] !== 'pkcs8') {\n            throw new Error(`Unable to decode non-pkcs8 type, [${content.join(',')}] found}`);\n        }\n        const cryptoType = version === '0' || !Array.isArray(content)\n            ? this.type\n            : content[1];\n        const encType = !Array.isArray(type)\n            ? [type]\n            : type;\n        if (!['ed25519', 'sr25519', 'ecdsa', 'ethereum'].includes(cryptoType)) {\n            throw new Error(`Unknown crypto type ${cryptoType}`);\n        }\n        // Here the address and publicKey are 32 bytes and isomorphic. This is why the address field needs to be the public key for ethereum type pairs\n        const publicKey = isHex(address)\n            ? hexToU8a(address)\n            : this.decodeAddress(address, ignoreChecksum);\n        const decoded = isHex(encoded)\n            ? hexToU8a(encoded)\n            : base64Decode(encoded);\n        return createPair({ toSS58: this.encodeAddress, type: cryptoType }, { publicKey, secretKey: new Uint8Array() }, meta, decoded, encType);\n    }\n    /**\n     * @name createFromPair\n     * @summary Creates a pair from an explicit publicKey/secreteKey combination\n     */\n    createFromPair(pair, meta = {}, type = this.type) {\n        return createPair({ toSS58: this.encodeAddress, type }, pair, meta, null);\n    }\n    /**\n     * @name createFromUri\n     * @summary Creates a Keypair from an suri\n     * @description This creates a pair from the suri, but does not add it to the keyring\n     *\n     * @param _suri\n     * @param meta\n     * @param type The supported types of pairs. Either 'ed25519' | 'sr25519' | 'ecdsa' | 'ethereum'.\n     * @param wordlist - Optional custom wordlist for mnemonic.\n     * @param rounds - Optional: Number of PBKDF2 iterations to run (default: 210000 (when onlyJS = true) or 2048 (when onlyJS = false).\n     */\n    createFromUri(_suri, meta = {}, type = this.type, wordlist, rounds) {\n        // here we only aut-add the dev phrase if we have a hard-derived path\n        const suri = _suri.startsWith('//')\n            ? `${DEV_PHRASE}${_suri}`\n            : _suri;\n        const { derivePath, password, path, phrase } = keyExtractSuri(suri);\n        let seed;\n        const isPhraseHex = isHex(phrase, 256);\n        if (isPhraseHex) {\n            seed = hexToU8a(phrase);\n        }\n        else {\n            const parts = phrase.split(' ');\n            if ([12, 15, 18, 21, 24].includes(parts.length)) {\n                seed = type === 'ethereum'\n                    ? mnemonicToLegacySeed(phrase, '', false, 64, rounds)\n                    : mnemonicToMiniSecret(phrase, password, wordlist, false, rounds);\n            }\n            else {\n                if (phrase.length > 32) {\n                    throw new Error('specified phrase is not a valid mnemonic and is invalid as a raw seed at > 32 bytes');\n                }\n                seed = stringToU8a(phrase.padEnd(32));\n            }\n        }\n        const derived = type === 'ethereum'\n            ? isPhraseHex\n                ? PairFromSeed[type](seed) // for eth, if the private key is provided as suri, it must be derived only once\n                : hdEthereum(seed, derivePath.substring(1))\n            : keyFromPath(PairFromSeed[type](seed), path, type);\n        return createPair({ toSS58: this.encodeAddress, type }, derived, meta, null);\n    }\n    /**\n     * @name encodeAddress\n     * @description Encodes the input into an ss58 representation\n     */\n    encodeAddress = (address, ss58Format) => {\n        return this.type === 'ethereum'\n            ? ethereumEncode(address)\n            : encodeAddress(address, ss58Format ?? this.#ss58);\n    };\n    /**\n     * @name getPair\n     * @summary Retrieves an account keyring pair from the Keyring Pair Dictionary, given an account address\n     * @description Returns a keyring pair value from the keyring pair dictionary by performing\n     * a key lookup using the provided account address or public key (after decoding it).\n     */\n    getPair(address) {\n        return this.#pairs.get(address);\n    }\n    /**\n     * @name getPairs\n     * @summary Retrieves all account keyring pairs from the Keyring Pair Dictionary\n     * @description Returns an array list of all the keyring pair values that are stored in the keyring pair dictionary.\n     */\n    getPairs() {\n        return this.#pairs.all();\n    }\n    /**\n     * @name getPublicKeys\n     * @summary Retrieves Public Keys of all Keyring Pairs stored in the Keyring Pair Dictionary\n     * @description Returns an array list of all the public keys associated with each of the keyring pair values that are stored in the keyring pair dictionary.\n     */\n    getPublicKeys() {\n        return this.#pairs.all().map(pairToPublic);\n    }\n    /**\n     * @name removePair\n     * @description Deletes the provided input address or public key from the stored Keyring Pair Dictionary.\n     */\n    removePair(address) {\n        this.#pairs.remove(address);\n    }\n    /**\n     * @name setSS58Format;\n     * @description Sets the ss58 format for the keyring\n     */\n    setSS58Format(ss58) {\n        this.#ss58 = ss58;\n    }\n    /**\n     * @name toJson\n     * @summary Returns a JSON object associated with the input argument that contains metadata assocated with an account\n     * @description Returns a JSON object containing the metadata associated with an account\n     * when valid address or public key and when the account passphrase is provided if the account secret\n     * is not already unlocked and available in memory. Note that in [Polkadot-JS Apps](https://github.com/polkadot-js/apps) the user\n     * may backup their account to a JSON file that contains this information.\n     */\n    toJson(address, passphrase) {\n        return this.#pairs.get(address).toJson(passphrase);\n    }\n}\n", "import { objectSpread, u8aConcat, u8aEmpty, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { blake2AsU8a, ed25519PairFromSeed as ed25519FromSeed, ed25519Sign, ethereumEncode, keccakAsU8a, keyExtractPath, keyFromPath, secp256k1Compress, secp256k1Expand, secp256k1PairFromSeed as secp256k1FromSeed, secp256k1Sign, signatureVerify, sr25519PairFromSeed as sr25519FromSeed, sr25519Sign, sr25519VrfSign, sr25519VrfVerify } from '@polkadot/util-crypto';\nimport { decodePair } from './decode.js';\nimport { encodePair } from './encode.js';\nimport { pairToJson } from './toJson.js';\nconst SIG_TYPE_NONE = new Uint8Array();\nconst TYPE_FROM_SEED = {\n    ecdsa: secp256k1FromSeed,\n    ed25519: ed25519FromSeed,\n    ethereum: secp256k1FromSeed,\n    sr25519: sr25519FromSeed\n};\nconst TYPE_PREFIX = {\n    ecdsa: new Uint8Array([2]),\n    ed25519: new Uint8Array([0]),\n    ethereum: new Uint8Array([2]),\n    sr25519: new Uint8Array([1])\n};\nconst TYPE_SIGNATURE = {\n    ecdsa: (m, p) => secp256k1Sign(m, p, 'blake2'),\n    ed25519: ed25519Sign,\n    ethereum: (m, p) => secp256k1Sign(m, p, 'keccak'),\n    sr25519: sr25519Sign\n};\nconst TYPE_ADDRESS = {\n    ecdsa: (p) => p.length > 32 ? blake2AsU8a(p) : p,\n    ed25519: (p) => p,\n    ethereum: (p) => p.length === 20 ? p : keccakAsU8a(secp256k1Expand(p)),\n    sr25519: (p) => p\n};\nfunction isLocked(secretKey) {\n    return !secretKey || u8aEmpty(secretKey);\n}\nfunction vrfHash(proof, context, extra) {\n    return blake2AsU8a(u8aConcat(context || '', extra || '', proof));\n}\n/**\n * @name createPair\n * @summary Creates a keyring pair object\n * @description Creates a keyring pair object with provided account public key, metadata, and encoded arguments.\n * The keyring pair stores the account state including the encoded address and associated metadata.\n *\n * It has properties whose values are functions that may be called to perform account actions:\n *\n * - `address` function retrieves the address associated with the account.\n * - `decodedPkcs8` function is called with the account passphrase and account encoded public key.\n * It decodes the encoded public key using the passphrase provided to obtain the decoded account public key\n * and associated secret key that are then available in memory, and changes the account address stored in the\n * state of the pair to correspond to the address of the decoded public key.\n * - `encodePkcs8` function when provided with the correct passphrase associated with the account pair\n * and when the secret key is in memory (when the account pair is not locked) it returns an encoded\n * public key of the account.\n * - `meta` is the metadata that is stored in the state of the pair, either when it was originally\n * created or set via `setMeta`.\n * - `publicKey` returns the public key stored in memory for the pair.\n * - `sign` may be used to return a signature by signing a provided message with the secret\n * key (if it is in memory) using Nacl.\n * - `toJson` calls another `toJson` function and provides the state of the pair,\n * it generates arguments to be passed to the other `toJson` function including an encoded public key of the account\n * that it generates using the secret key from memory (if it has been made available in memory)\n * and the optionally provided passphrase argument. It passes a third boolean argument to `toJson`\n * indicating whether the public key has been encoded or not (if a passphrase argument was provided then it is encoded).\n * The `toJson` function that it calls returns a JSON object with properties including the `address`\n * and `meta` that are assigned with the values stored in the corresponding state variables of the account pair,\n * an `encoded` property that is assigned with the encoded public key in hex format, and an `encoding`\n * property that indicates whether the public key value of the `encoded` property is encoded or not.\n */\nexport function createPair({ toSS58, type }, { publicKey, secretKey }, meta = {}, encoded = null, encTypes) {\n    const decodePkcs8 = (passphrase, userEncoded) => {\n        const decoded = decodePair(passphrase, userEncoded || encoded, encTypes);\n        if (decoded.secretKey.length === 64) {\n            publicKey = decoded.publicKey;\n            secretKey = decoded.secretKey;\n        }\n        else {\n            const pair = TYPE_FROM_SEED[type](decoded.secretKey);\n            publicKey = pair.publicKey;\n            secretKey = pair.secretKey;\n        }\n    };\n    const recode = (passphrase) => {\n        isLocked(secretKey) && encoded && decodePkcs8(passphrase, encoded);\n        encoded = encodePair({ publicKey, secretKey }, passphrase); // re-encode, latest version\n        encTypes = undefined; // swap to defaults, latest version follows\n        return encoded;\n    };\n    const encodeAddress = () => {\n        const raw = TYPE_ADDRESS[type](publicKey);\n        return type === 'ethereum'\n            ? ethereumEncode(raw)\n            : toSS58(raw);\n    };\n    return {\n        get address() {\n            return encodeAddress();\n        },\n        get addressRaw() {\n            const raw = TYPE_ADDRESS[type](publicKey);\n            return type === 'ethereum'\n                ? raw.slice(-20)\n                : raw;\n        },\n        get isLocked() {\n            return isLocked(secretKey);\n        },\n        get meta() {\n            return meta;\n        },\n        get publicKey() {\n            return publicKey;\n        },\n        get type() {\n            return type;\n        },\n        // eslint-disable-next-line sort-keys\n        decodePkcs8,\n        derive: (suri, meta) => {\n            if (type === 'ethereum') {\n                throw new Error('Unable to derive on this keypair');\n            }\n            else if (isLocked(secretKey)) {\n                throw new Error('Cannot derive on a locked keypair');\n            }\n            const { path } = keyExtractPath(suri);\n            const derived = keyFromPath({ publicKey, secretKey }, path, type);\n            return createPair({ toSS58, type }, derived, meta, null);\n        },\n        encodePkcs8: (passphrase) => {\n            return recode(passphrase);\n        },\n        lock: () => {\n            secretKey = new Uint8Array();\n        },\n        setMeta: (additional) => {\n            meta = objectSpread({}, meta, additional);\n        },\n        sign: (message, options = {}) => {\n            if (isLocked(secretKey)) {\n                throw new Error('Cannot sign with a locked key pair');\n            }\n            return u8aConcat(options.withType\n                ? TYPE_PREFIX[type]\n                : SIG_TYPE_NONE, TYPE_SIGNATURE[type](u8aToU8a(message), { publicKey, secretKey }));\n        },\n        toJson: (passphrase) => {\n            // NOTE: For ecdsa and ethereum, the publicKey cannot be extracted from the address. For these\n            // pass the hex-encoded publicKey through to the address portion of the JSON (before decoding)\n            // unless the publicKey is already an address\n            const address = ['ecdsa', 'ethereum'].includes(type)\n                ? publicKey.length === 20\n                    ? u8aToHex(publicKey)\n                    : u8aToHex(secp256k1Compress(publicKey))\n                : encodeAddress();\n            return pairToJson(type, { address, meta }, recode(passphrase), !!passphrase);\n        },\n        unlock: (passphrase) => {\n            return decodePkcs8(passphrase);\n        },\n        verify: (message, signature, signerPublic) => {\n            return signatureVerify(message, signature, TYPE_ADDRESS[type](u8aToU8a(signerPublic))).isValid;\n        },\n        vrfSign: (message, context, extra) => {\n            if (isLocked(secretKey)) {\n                throw new Error('Cannot sign with a locked key pair');\n            }\n            if (type === 'sr25519') {\n                return sr25519VrfSign(message, { secretKey }, context, extra);\n            }\n            const proof = TYPE_SIGNATURE[type](u8aToU8a(message), { publicKey, secretKey });\n            return u8aConcat(vrfHash(proof, context, extra), proof);\n        },\n        vrfVerify: (message, vrfResult, signerPublic, context, extra) => {\n            if (type === 'sr25519') {\n                return sr25519VrfVerify(message, vrfResult, publicKey, context, extra);\n            }\n            const result = signatureVerify(message, u8aConcat(TYPE_PREFIX[type], vrfResult.subarray(32)), TYPE_ADDRESS[type](u8aToU8a(signerPublic)));\n            return result.isValid && u8aEq(vrfResult.subarray(0, 32), vrfHash(vrfResult.subarray(32), context, extra));\n        }\n    };\n}\n", "import { u8aEq } from '@polkadot/util';\nimport { jsonDecryptData } from '@polkadot/util-crypto';\nimport { PAIR_DIV, PAIR_HDR, PUB_LENGTH, SEC_LENGTH, SEED_LENGTH } from './defaults.js';\nconst SEED_OFFSET = PAIR_HDR.length;\n/**\n * Decode a pair, taking into account the generation-specific formats and headers\n *\n * For divisor/headers, don't rely on the magic being static. These will\n * change between generations, aka with the long-awaited 4th generation\n * of the format. The external decode interface is the only way to use and decode these.\n **/\nexport function decodePair(passphrase, encrypted, _encType) {\n    const encType = Array.isArray(_encType) || _encType === undefined\n        ? _encType\n        : [_encType];\n    const decrypted = jsonDecryptData(encrypted, passphrase, encType);\n    const header = decrypted.subarray(0, PAIR_HDR.length);\n    // check the start header (generations 1-3)\n    if (!u8aEq(header, PAIR_HDR)) {\n        throw new Error('Invalid encoding header found in body');\n    }\n    // setup for generation 3 format\n    let secretKey = decrypted.subarray(SEED_OFFSET, SEED_OFFSET + SEC_LENGTH);\n    let divOffset = SEED_OFFSET + SEC_LENGTH;\n    let divider = decrypted.subarray(divOffset, divOffset + PAIR_DIV.length);\n    // old-style (generation 1 & 2), we have the seed here\n    if (!u8aEq(divider, PAIR_DIV)) {\n        divOffset = SEED_OFFSET + SEED_LENGTH;\n        secretKey = decrypted.subarray(SEED_OFFSET, divOffset);\n        divider = decrypted.subarray(divOffset, divOffset + PAIR_DIV.length);\n        // check the divisior at this point (already checked for generation 3)\n        if (!u8aEq(divider, PAIR_DIV)) {\n            throw new Error('Invalid encoding divider found in body');\n        }\n    }\n    const pubOffset = divOffset + PAIR_DIV.length;\n    const publicKey = decrypted.subarray(pubOffset, pubOffset + PUB_LENGTH);\n    return {\n        publicKey,\n        secretKey\n    };\n}\n", "/** public/secret section divider (generation 1-3, will change in 4, don't rely on value) */\nexport const PAIR_DIV = new Uint8Array([161, 35, 3, 33, 0]);\n/** public/secret start block (generation 1-3, will change in 4, don't rely on value) */\nexport const PAIR_HDR = new Uint8Array([48, 83, 2, 1, 1, 48, 5, 6, 3, 43, 101, 112, 4, 34, 4, 32]);\n/** length of a public key */\nexport const PUB_LENGTH = 32;\n/** length of a salt */\nexport const SALT_LENGTH = 32;\n/** length of a secret key */\nexport const SEC_LENGTH = 64;\n/** length of a user-input seed */\nexport const SEED_LENGTH = 32;\n", "import { u8aConcat } from '@polkadot/util';\nimport { naclEncrypt, scryptEncode, scryptToU8a } from '@polkadot/util-crypto';\nimport { PAIR_DIV, PAIR_HDR } from './defaults.js';\n/**\n * Encode a pair with the latest generation format (generation 3)\n **/\nexport function encodePair({ publicKey, secretKey }, passphrase) {\n    if (!secretKey) {\n        throw new Error('Expected a valid secretKey to be passed to encode');\n    }\n    const encoded = u8aConcat(PAIR_HDR, secretKey, PAIR_DIV, publicKey);\n    if (!passphrase) {\n        return encoded;\n    }\n    // this is only for generation 3 (previous generations are only handled in decoding)\n    const { params, password, salt } = scryptEncode(passphrase);\n    const { encrypted, nonce } = naclEncrypt(encoded, password.subarray(0, 32));\n    return u8aConcat(scryptToU8a(salt, params), nonce, encrypted);\n}\n", "import { objectSpread } from '@polkadot/util';\nimport { jsonEncryptFormat } from '@polkadot/util-crypto';\nexport function pairToJson(type, { address, meta }, encoded, isEncrypted) {\n    return objectSpread(jsonEncryptFormat(encoded, ['pkcs8', type], isEncrypted), {\n        address,\n        meta\n    });\n}\n", "export const DEV_PHRASE = 'bottom drive obey lake curtain smoke basket hold race lonely fit walk';\nexport const DEV_SEED = '0xfac7959dbfe72f052e5a0c3c8d6530f202b02fd8f9f5ca3580ec8deb7797479e';\n", "import { isHex, isU8a, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { decodeAddress } from '@polkadot/util-crypto';\nexport class Pairs {\n    #map = {};\n    add(pair) {\n        this.#map[decodeAddress(pair.address).toString()] = pair;\n        return pair;\n    }\n    all() {\n        return Object.values(this.#map);\n    }\n    get(address) {\n        const pair = this.#map[decodeAddress(address).toString()];\n        if (!pair) {\n            throw new Error(`Unable to retrieve keypair '${isU8a(address) || isHex(address)\n                ? u8aToHex(u8aToU8a(address))\n                : address}'`);\n        }\n        return pair;\n    }\n    remove(address) {\n        delete this.#map[decodeAddress(address).toString()];\n    }\n}\n", "import { hexToU8a } from '@polkadot/util';\nimport { createPair } from './pair/index.js';\nimport { Keyring } from './keyring.js';\nexport const PAIRSSR25519 = [\n    {\n        p: '0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d',\n        s: '0x98319d4ff8a9508c4bb0cf0b5a78d760a0b2082c02775e6e82370816fedfff48925a225d97aa00682d6a59b95b18780c10d7032336e88f3442b42361f4a66011', // nosemgrep\n        seed: 'Alice',\n        type: 'sr25519'\n    },\n    {\n        p: '0xbe5ddb1579b72e84524fc29e78609e3caf42e85aa118ebfe0b0ad404b5bdd25f',\n        s: '0xe8da6c9d810e020f5e3c7f5af2dea314cbeaa0d72bc6421e92c0808a0c584a6046ab28e97c3ffc77fe12b5a4d37e8cd4afbfebbf2391ffc7cb07c0f38c023efd', // nosemgrep\n        seed: 'Alice//stash',\n        type: 'sr25519'\n    },\n    {\n        p: '0x8eaf04151687736326c9fea17e25fc5287613693c912909cb226aa4794f26a48',\n        s: '0x081ff694633e255136bdb456c20a5fc8fed21f8b964c11bb17ff534ce80ebd5941ae88f85d0c1bfc37be41c904e1dfc01de8c8067b0d6d5df25dd1ac0894a325', // nosemgrep\n        seed: 'Bob',\n        type: 'sr25519'\n    },\n    {\n        p: '0xfe65717dad0447d715f660a0a58411de509b42e6efb8375f562f58a554d5860e',\n        s: '0xc006507cdfc267a21532394c49ca9b754ca71de21e15a1cdf807c7ceab6d0b6c3ed408d9d35311540dcd54931933e67cf1ea10d46f75408f82b789d9bd212fde', // nosemgrep\n        seed: 'Bob//stash',\n        type: 'sr25519'\n    },\n    {\n        p: '0x90b5ab205c6974c9ea841be688864633dc9ca8a357843eeacf2314649965fe22',\n        s: '0xa8f2d83016052e5d6d77b2f6fd5d59418922a09024cda701b3c34369ec43a7668faf12ff39cd4e5d92bb773972f41a7a5279ebc2ed92264bed8f47d344f8f18c', // nosemgrep\n        seed: 'Charlie',\n        type: 'sr25519'\n    },\n    {\n        p: '0x306721211d5404bd9da88e0204360a1a9ab8b87c66c1bc2fcdd37f3c2222cc20',\n        s: '0x20e05482ca4677e0edbc58ae9a3a59f6ed3b1a9484ba17e64d6fe8688b2b7b5d108c4487b9323b98b11fe36cb301b084e920f7b7895536809a6d62a451b25568', // nosemgrep\n        seed: 'Dave',\n        type: 'sr25519'\n    },\n    {\n        p: '0xe659a7a1628cdd93febc04a4e0646ea20e9f5f0ce097d9a05290d4a9e054df4e',\n        s: '0x683576abfd5dc35273e4264c23095a1bf21c14517bece57c7f0cc5c0ed4ce06a3dbf386b7828f348abe15d76973a72009e6ef86a5c91db2990cb36bb657c6587', // nosemgrep\n        seed: 'Eve',\n        type: 'sr25519'\n    },\n    {\n        p: '0x1cbd2d43530a44705ad088af313e18f80b53ef16b36177cd4b77b846f2a5f07c',\n        s: '0xb835c20f450079cf4f513900ae9faf8df06ad86c681884122c752a4b2bf74d4303e4f21bc6cc62bb4eeed5a9cce642c25e2d2ac1464093b50f6196d78e3a7426', // nosemgrep\n        seed: 'Ferdie',\n        type: 'sr25519'\n    }\n];\nexport const PAIRSETHEREUM = [\n    {\n        name: 'Alith',\n        p: '0x02509540919faacf9ab52146c9aa40db68172d83777250b28e4679176e49ccdd9f',\n        s: '0x5fb92d6e98884f76de468fa3f6278f8807c48bebc13595d45af5bdc4da702133', // nosemgrep\n        type: 'ethereum'\n    },\n    {\n        name: 'Baltathar',\n        p: '0x033bc19e36ff1673910575b6727a974a9abd80c9a875d41ab3e2648dbfb9e4b518',\n        s: '0x8075991ce870b93a8870eca0c0f91913d12f47948ca0fd25b49c6fa7cdbeee8b', // nosemgrep\n        type: 'ethereum'\n    },\n    {\n        name: 'Charleth',\n        p: '0x0234637bdc0e89b5d46543bcbf8edff329d2702bc995e27e9af4b1ba009a3c2a5e',\n        s: '0x0b6e18cafb6ed99687ec547bd28139cafdd2bffe70e6b688025de6b445aa5c5b', // nosemgrep\n        type: 'ethereum'\n    },\n    {\n        name: 'Dorothy',\n        p: '0x02a00d60b2b408c2a14c5d70cdd2c205db8985ef737a7e55ad20ea32cc9e7c417c',\n        s: '0x39539ab1876910bbf3a223d84a29e28f1cb4e2e456503e7e91ed39b2e7223d68', // nosemgrep\n        type: 'ethereum'\n    },\n    {\n        name: 'Ethan',\n        p: '0x025cdc005b752651cd3f728fb9192182acb3a9c89e19072cbd5b03f3ee1f1b3ffa',\n        s: '0x7dce9bc8babb68fec1409be38c8e1a52650206a7ed90ff956ae8a6d15eeaaef4', // nosemgrep\n        type: 'ethereum'\n    },\n    {\n        name: 'Faith',\n        p: '0x037964b6c9d546da4646ada28a99e34acaa1d14e7aba861a9055f9bd200c8abf74',\n        s: '0xb9d2ea9a615f3165812e8d44de0d24da9bbd164b65c4f0573e1ce2c8dbd9c8df', // nosemgrep\n        type: 'ethereum'\n    }\n];\nfunction createMeta(name, seed) {\n    if (!name && !seed) {\n        throw new Error('Testing pair should have either a name or a seed');\n    }\n    return {\n        isTesting: true,\n        name: name || seed?.replace('//', '_').toLowerCase()\n    };\n}\n/**\n * @name testKeyring\n * @summary Create an instance of Keyring pre-populated with locked test accounts\n * @description The test accounts (i.e. alice, bob, dave, eve, ferdie)\n * are available on the dev chain and each test account is initialized with DOT funds.\n */\nexport function createTestKeyring(options = {}, isDerived = true) {\n    const keyring = new Keyring(options);\n    const pairs = options.type === 'ethereum'\n        ? PAIRSETHEREUM\n        : PAIRSSR25519;\n    for (const { name, p, s, seed, type } of pairs) {\n        const meta = createMeta(name, seed);\n        const pair = !isDerived && !name && seed\n            ? keyring.addFromUri(seed, meta, options.type)\n            : keyring.addPair(createPair({ toSS58: keyring.encodeAddress, type }, { publicKey: hexToU8a(p), secretKey: hexToU8a(s) }, meta));\n        pair.lock = () => {\n            // we don't have lock/unlock functionality here\n        };\n    }\n    return keyring;\n}\n", "import { nobody } from './pair/nobody.js';\nimport { createTestKeyring } from './testing.js';\nexport function createTestPairs(options, isDerived = true) {\n    const keyring = createTestKeyring(options, isDerived);\n    const pairs = keyring.getPairs();\n    const map = { nobody: nobody() };\n    for (const p of pairs) {\n        if (p.meta.name) {\n            map[p.meta.name] = p;\n        }\n    }\n    return map;\n}\n", "const publicKey = new Uint8Array(32);\nconst address = '5C4hrfjw9DjXZTzV3MwzrrAr9P1MJhSrvWGWqi1eSuyUpnhM';\nconst meta = {\n    isTesting: true,\n    name: 'nobody'\n};\nconst json = {\n    address,\n    encoded: '',\n    encoding: {\n        content: ['pkcs8', 'ed25519'],\n        type: 'none',\n        version: '0'\n    },\n    meta\n};\nconst pair = {\n    address,\n    addressRaw: publicKey,\n    decodePkcs8: (_passphrase, _encoded) => undefined,\n    derive: (_suri, _meta) => pair,\n    encodePkcs8: (_passphrase) => new Uint8Array(0),\n    isLocked: true,\n    lock: () => {\n        // no locking, it is always locked\n    },\n    meta,\n    publicKey,\n    setMeta: (_meta) => undefined,\n    sign: (_message) => new Uint8Array(64),\n    toJson: (_passphrase) => json,\n    type: 'ed25519',\n    unlock: (_passphrase) => undefined,\n    verify: (_message, _signature) => false,\n    vrfSign: (_message, _context, _extra) => new Uint8Array(96),\n    vrfVerify: (_message, _vrfResult, _context, _extra) => false\n};\nexport function nobody() {\n    return pair;\n}\n"],
  "mappings": "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",
  "names": ["import_dist", "import_dist", "import_dist", "packageInfo", "packageInfo", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "publicKey", "import_dist", "publicKey", "import_dist", "address", "meta", "publicKey", "meta", "pair", "encodeAddress", "address", "import_dist", "import_dist", "pair", "address", "publicKey", "pair", "address", "meta", "json", "import_dist", "meta", "pair", "import_dist", "import_dist"]
}
