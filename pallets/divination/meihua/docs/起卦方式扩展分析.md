# 梅花易数起卦方式扩展分析

## 一、当前起卦方式

现有 `DivinationMethod` 枚举包含以下起卦方式：

| 枚举值 | 说明 | 调用函数 |
|--------|------|----------|
| `DateTime` | 时间起卦（农历） | `divine_by_time` |
| `TwoNumbers` | 双数起卦 | `divine_by_numbers` |
| `SingleNumber` | 单数起卦 | `divine_by_single_number` |
| `Random` | 随机起卦 | `divine_random` |
| `Manual` | 手动指定 | `divine_manual` |

---

## 二、扩展需求分析

### 2.1 DateTime 拆分为农历/公历起卦

**当前实现**：
- `divine_by_time` 使用 `pallet-almanac` 将时间戳转换为农历
- 使用农历的年支数、月数、日数、时支数计算卦数

**扩展方案**：

#### 方案 A：新增 `GregorianDateTime` 枚举值

```rust
pub enum DivinationMethod {
    /// 农历时间起卦（传统方式）
    LunarDateTime = 0,
    /// 公历时间起卦（现代简化）
    GregorianDateTime = 1,
    // ... 其他方式
}
```

#### 农历起卦算法（已有）

```
上卦 = (年支数 + 农历月 + 农历日) % 8
下卦 = (年支数 + 农历月 + 农历日 + 时支数) % 8
动爻 = (年支数 + 农历月 + 农历日 + 时支数) % 6
```

#### 公历起卦算法（新增）

```
上卦 = (公历年份后两位 + 公历月 + 公历日) % 8
下卦 = (公历年份后两位 + 公历月 + 公历日 + 24小时制小时) % 8
动爻 = (公历年份后两位 + 公历月 + 公历日 + 24小时制小时) % 6
```

**可行性分析**：

| 维度 | 农历起卦 | 公历起卦 |
|------|---------|---------|
| 传统性 | ✅ 符合传统 | ❌ 非传统方式 |
| 便利性 | ❌ 需要农历转换 | ✅ 直接使用时间戳 |
| 计算成本 | 较高（需调用 almanac） | 较低（简单取模） |
| 易学正统性 | ✅ 邵雍原法 | ⚠️ 现代变体 |

**合理性评估**：⭐⭐⭐⭐ (4/5)

- **优点**：
  - 满足不同用户需求（传统派 vs 现代派）
  - 公历起卦计算更轻量
  - 向后兼容，原有功能不受影响

- **缺点**：
  - 公历起卦非传统方法，易学界存在争议
  - 增加了枚举复杂度

**实现建议**：
1. 将 `DateTime` 重命名为 `LunarDateTime`
2. 新增 `GregorianDateTime` 枚举值
3. 新增 `divine_by_gregorian_time` 调用函数
4. 前端提供切换选项，默认使用农历

---

### 2.2 链摇起卦（ChainShake）

**用户描述的流程**：
1. 前端点击"开始摇卦"
2. 链端返回一个爻（阴爻或阳爻）
3. 重复 6 次，得到 6 个爻
4. 前端将 6 个爻上传到链上

**技术挑战分析**：

#### 挑战 1：6 次交易成本

| 方案 | 交易次数 | Gas 成本 | 用户体验 |
|------|---------|---------|---------|
| 每爻一笔交易 | 6 次 | 高 | 差（等待6次确认） |
| RPC 查询 + 最终提交 | 1 次 | 低 | 好 |
| 一次生成6爻前端动画 | 1 次 | 低 | 中（无真实交互感） |

#### 挑战 2：随机数来源

链上随机数获取方式：
```rust
// 当前实现
let random_seed = T::Randomness::random(&b"meihua"[..]).0;
```

**问题**：
- 同一区块内多次调用可能返回相同值
- 需要引入用户交互时间作为熵源

#### 挑战 3：状态管理

需要存储"摇卦进行中"的状态：
```rust
/// 摇卦会话存储
#[pallet::storage]
pub type ShakeSessions<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::AccountId,
    ShakeSession,  // 包含已摇爻数据和时间戳
>;
```

**三种实现方案对比**：

### 方案 A：纯链上方案（6次交易）

```
用户 -> 链: start_shake()  // 初始化会话
用户 -> 链: shake_once() x6 // 每次摇一爻
用户 -> 链: finish_shake() // 完成并存储
```

| 优点 | 缺点 |
|------|------|
| 完全去中心化 | 6次交易成本高 |
| 随机性可验证 | 用户体验差 |
| 状态完全链上 | 复杂度高 |

**可行性**：⭐⭐ (2/5) - 成本过高，不推荐

### 方案 B：RPC 查询 + 最终提交

```
用户 -> RPC: get_random_yao() x6  // 链下查询获取随机爻
用户 -> 链: submit_shake_result([爻1, 爻2, ..., 爻6])
```

实现细节：
```rust
// Runtime API
fn get_random_yao(account: AccountId, nonce: u64) -> u8 {
    // 使用 account + nonce + 区块哈希 生成随机爻
    let seed = (account, nonce, frame_system::BlockHash::<T>::get());
    let hash = sp_io::hashing::blake2_256(&seed.encode());
    hash[0] % 2  // 0 = 阴爻, 1 = 阳爻
}

// Pallet 调用
fn submit_shake_result(
    origin: OriginFor<T>,
    yaos: [u8; 6],  // 6个爻的阴阳值
    question_hash: [u8; 32],
    is_public: bool,
) -> DispatchResult {
    // 验证并存储
}
```

| 优点 | 缺点 |
|------|------|
| 只需1次交易 | 随机性不可完全验证 |
| 用户体验好 | RPC 可被操控 |
| 成本低 | 需要 Runtime API |

**可行性**：⭐⭐⭐⭐ (4/5) - 平衡了成本和体验

### 方案 C：前端生成 + 链上存储（推荐）

```
前端: 用户点击摇卦
前端: 本地生成随机爻（使用 crypto.getRandomValues + 时间戳）
前端: 展示动画效果
前端: 6爻完成后，调用链上提交
用户 -> 链: divine_by_shake([爻1, 爻2, ..., 爻6])
```

实现细节：
```rust
/// 链摇起卦（前端生成爻，链上验证存储）
///
/// # 参数
/// - `yaos`: 6个爻的值（0=阴爻，1=阳爻），从初爻到上爻
/// - `shake_timestamps`: 6次摇卦的时间戳（用于验证时间合理性）
/// - `question_hash`: 问题哈希
/// - `is_public`: 是否公开
#[pallet::call_index(8)]
#[pallet::weight(Weight::from_parts(50_000_000, 0))]
pub fn divine_by_shake(
    origin: OriginFor<T>,
    yaos: [u8; 6],
    shake_timestamps: [u64; 6],
    question_hash: [u8; 32],
    is_public: bool,
    gender: u8,
    category: u8,
) -> DispatchResult {
    let who = ensure_signed(origin)?;
    Self::check_daily_limit(&who)?;

    // 验证爻值合法性（0或1）
    for yao in yaos.iter() {
        ensure!(*yao <= 1, Error::<T>::InvalidYaoValue);
    }

    // 验证时间戳合理性（可选）
    // 确保6次摇卦有时间间隔，防止机器人

    // 从6个爻构建上下卦
    // yaos[0..3] = 下卦（初爻到三爻）
    // yaos[3..6] = 上卦（四爻到上爻）
    let xia_binary = (yaos[2] << 2) | (yaos[1] << 1) | yaos[0];
    let shang_binary = (yaos[5] << 2) | (yaos[4] << 1) | yaos[3];

    let shang_gua_num = Bagua::from_binary(shang_binary).number();
    let xia_gua_num = Bagua::from_binary(xia_binary).number();

    // 动爻：取最后一次摇卦时间戳 % 6 + 1
    let dong_yao = ((shake_timestamps[5] % 6) + 1) as u8;

    Self::create_hexagram(
        who,
        shang_gua_num,
        xia_gua_num,
        dong_yao,
        DivinationMethod::ChainShake,
        question_hash,
        is_public,
        gender,
        category,
    )
}
```

| 优点 | 缺点 |
|------|------|
| 只需1次交易 | 随机性依赖前端 |
| 用户体验最好（有交互感） | 理论上可被操控 |
| 成本低 | - |
| 实现简单 | - |

**可行性**：⭐⭐⭐⭐⭐ (5/5) - 最佳平衡方案

---

## 三、综合评估与建议

### 3.1 扩展后的 DivinationMethod 枚举

```rust
#[derive(Clone, Copy, Encode, Decode, TypeInfo, MaxEncodedLen, PartialEq, Eq, Debug, Default)]
pub enum DivinationMethod {
    /// 农历时间起卦 - 传统方式
    #[default]
    LunarDateTime = 0,
    /// 公历时间起卦 - 现代简化
    GregorianDateTime = 1,
    /// 双数起卦
    TwoNumbers = 2,
    /// 单数起卦
    SingleNumber = 3,
    /// 随机起卦
    Random = 4,
    /// 手动指定
    Manual = 5,
    /// 链摇起卦（新增）
    ChainShake = 6,
}
```

### 3.2 前端界面建议

```
┌─────────────────────────────────────┐
│         选择起卦方式                │
├─────────────────────────────────────┤
│  🕐 时间起卦                        │
│     ├─ ○ 农历起卦（推荐）           │
│     └─ ○ 公历起卦                   │
│                                     │
│  🔢 数字起卦                        │
│     ├─ ○ 双数起卦                   │
│     └─ ○ 单数起卦                   │
│                                     │
│  🎲 随机起卦                        │
│                                     │
│  🤲 链摇起卦（新增）                │
│     点击摇动获取每一爻              │
│                                     │
│  ✏️ 手动输入                        │
└─────────────────────────────────────┘
```

### 3.3 链摇起卦前端交互流程

```
┌─────────────────────────────────────┐
│         链摇起卦                    │
├─────────────────────────────────────┤
│                                     │
│     ━━━  第 1 爻 / 6               │
│                                     │
│        ┌─────────────┐             │
│        │   🎴        │   <- 动画  │
│        │   摇动中... │              │
│        └─────────────┘             │
│                                     │
│     [    点击摇卦    ]              │
│                                     │
│  已得：                             │
│  ━━━ ━━━ ━━━  (3阳爻)              │
│                                     │
└─────────────────────────────────────┘
```

### 3.4 实现优先级建议

| 功能 | 优先级 | 工作量 | 说明 |
|------|--------|--------|------|
| 公历起卦 | P2 | 小 | 算法简单，仅需新增函数 |
| 链摇起卦（方案C） | P1 | 中 | 用户体验提升明显 |

---

## 四、风险与注意事项

### 4.1 公历起卦

- **易学正统性争议**：传统梅花易数使用农历，公历起卦为现代变体
- **建议**：前端默认选择农历，公历作为备选；文案说明两种方式的区别

### 4.2 链摇起卦

- **随机性可操控风险**：
  - 前端生成的随机数理论上可被用户控制
  - **缓解措施**：
    1. 记录摇卦时间戳，验证时间间隔合理性
    2. 结合用户账户哈希增加熵
    3. 在解读中标注起卦方式，让查看者知情

- **反作弊考虑**：
  ```rust
  // 验证摇卦时间间隔
  for i in 1..6 {
      let interval = shake_timestamps[i] - shake_timestamps[i-1];
      ensure!(interval >= 500 && interval <= 30000, Error::<T>::InvalidShakeInterval);
      // 每次摇卦间隔应在 500ms ~ 30s 之间
  }
  ```

---

## 五、结论

### 推荐实施方案

1. **农历/公历起卦拆分**：✅ 可行且合理
   - 重命名 `DateTime` 为 `LunarDateTime`
   - 新增 `GregorianDateTime`
   - 工作量小，向后兼容

2. **链摇起卦**：✅ 推荐方案 C（前端生成 + 链上存储）
   - 用户体验最佳
   - 实现成本低
   - 只需 1 次链上交易
   - 通过时间戳验证增加防作弊

### 不推荐方案

- 链摇起卦方案 A（6次交易）：成本过高，用户体验差
- 链摇起卦方案 B（RPC查询）：增加 Runtime API 复杂度，收益不明显
