# 八字命盘多服务提供者加密存储设计

## 一、设计目标

### 1.1 核心需求

1. **隐私保护**：用户出生时间等敏感数据加密存储在链上
2. **多方解密**：用户可授权多位服务提供者（如命理师、AI 服务）解密
3. **细粒度授权**：用户可随时授予/撤销特定服务提供者的访问权限
4. **可追溯性**：所有授权和访问行为上链，可审计
5. **去中心化**：无需可信第三方托管密钥

### 1.2 设计原则

- **用户主权**：用户始终控制自己的数据
- **最小暴露**：服务提供者只能访问被授权的命盘
- **密钥隔离**：不同命盘使用不同密钥，单个泄露不影响其他
- **前向安全**：撤销授权后，服务提供者无法解密新数据

---

## 二、技术方案

### 2.1 密钥架构（三层结构）

```
┌─────────────────────────────────────────────────────────────────┐
│                      用户主密钥（MasterKey）                       │
│           由钱包私钥签名固定消息派生，永不暴露                         │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                    命盘密钥（ChartKey）                           │
│           MasterKey + ChartID 派生，每个命盘独立                    │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                   授权密钥（AccessKey）                           │
│           ChartKey + ProviderID + 有效期 派生                      │
│           可时间限制、可撤销                                        │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 密钥派生算法

```rust
/// 用户主密钥派生
/// 用户使用钱包签名固定消息得到签名值，再哈希得到主密钥
fn derive_master_key(wallet_signature: &[u8; 64]) -> [u8; 32] {
    blake2_256(b"STARDUST_BAZI_MASTER_KEY_V1" || wallet_signature)
}

/// 命盘密钥派生
/// 每个命盘有独立密钥，单个命盘密钥泄露不影响其他
fn derive_chart_key(master_key: &[u8; 32], chart_id: u64) -> [u8; 32] {
    blake2_256(b"CHART_KEY" || master_key || chart_id.to_le_bytes())
}

/// 授权密钥派生
/// 为特定服务提供者生成的受限访问密钥
fn derive_access_key(
    chart_key: &[u8; 32],
    provider_id: &AccountId,
    expiry_block: u32,
    nonce: u64,
) -> [u8; 32] {
    blake2_256(
        b"ACCESS_KEY" || chart_key || provider_id ||
        expiry_block.to_le_bytes() || nonce.to_le_bytes()
    )
}
```

### 2.3 加密方案：混合加密 + 密钥封装

采用 **ECIES 变体 + AES-256-GCM** 混合加密方案：

```
┌────────────────────────────────────────────────────────────────────┐
│                         加密流程                                    │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  原始数据（出生时间等）                                               │
│         │                                                          │
│         ▼                                                          │
│  ┌─────────────────────────────────────────────┐                   │
│  │  AES-256-GCM 加密（使用 ChartKey）             │                   │
│  │  生成: encrypted_data + nonce + auth_tag      │                   │
│  └─────────────────────────────────────────────┘                   │
│         │                                                          │
│         ▼                                                          │
│  存储到链上 EncryptedBaziChart.encrypted_data                        │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

### 2.4 多服务提供者授权机制

#### 方案 A：密钥封装（Key Encapsulation）

```
┌────────────────────────────────────────────────────────────────────┐
│                      授权流程                                       │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  1. 服务提供者注册时公开其公钥（Provider_PubKey）                      │
│                                                                    │
│  2. 用户授权时：                                                     │
│     - 生成 AccessKey = derive_access_key(...)                       │
│     - 用 Provider_PubKey 加密 AccessKey                             │
│     - 存储 EncryptedAccessKey 到链上                                 │
│                                                                    │
│  3. 服务提供者解密时：                                                │
│     - 用自己的私钥解密 EncryptedAccessKey                            │
│     - 用 AccessKey 解密命盘数据                                      │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

#### 方案 B：代理重加密（Proxy Re-Encryption）

```
┌────────────────────────────────────────────────────────────────────┐
│                    代理重加密流程                                    │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  1. 数据用用户公钥加密存储                                            │
│                                                                    │
│  2. 授权时，用户生成重加密密钥：                                       │
│     ReKey = f(User_PrivKey, Provider_PubKey)                       │
│                                                                    │
│  3. 代理节点（或链上逻辑）使用 ReKey 转换密文：                         │
│     Ciphertext_User → Ciphertext_Provider                          │
│     （代理无法解密原文）                                              │
│                                                                    │
│  4. 服务提供者用自己私钥解密                                          │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

**推荐方案**：方案 A（密钥封装）
- 实现简单，前端可完成
- 不需要链上密码学运算
- 广泛使用的标准方案

---

## 三、链上数据结构设计

### 3.1 服务提供者注册

```rust
/// 服务提供者信息
#[derive(Clone, Debug, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub struct ServiceProvider<T: Config> {
    /// 提供者账户
    pub account: T::AccountId,
    /// 服务类型（命理师、AI服务等）
    pub service_type: ServiceType,
    /// X25519 公钥（用于密钥封装）
    pub public_key: [u8; 32],
    /// 信誉分（用于筛选）
    pub reputation: u32,
    /// 注册时间
    pub registered_at: u32,
    /// 是否激活
    pub is_active: bool,
}

/// 服务类型枚举
#[derive(Clone, Copy, Debug, PartialEq, Eq, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub enum ServiceType {
    /// 命理师（人工解读）
    MingLiShi,
    /// AI 解读服务
    AiService,
    /// 命理学校/培训
    School,
    /// 研究机构
    Research,
}
```

### 3.2 授权记录

```rust
/// 访问授权记录
#[derive(Clone, Debug, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub struct AccessGrant<T: Config> {
    /// 授权 ID（唯一标识）
    pub grant_id: u64,
    /// 命盘 ID
    pub chart_id: u64,
    /// 命盘所有者
    pub owner: T::AccountId,
    /// 被授权的服务提供者
    pub provider: T::AccountId,
    /// 加密的访问密钥（用提供者公钥加密）
    pub encrypted_access_key: BoundedVec<u8, ConstU32<128>>,
    /// 授权开始时间（区块号）
    pub start_block: u32,
    /// 授权结束时间（区块号，0 表示永久）
    pub end_block: u32,
    /// 授权范围（只读/可分享等）
    pub scope: AccessScope,
    /// 是否已撤销
    pub revoked: bool,
    /// 撤销时间
    pub revoked_at: Option<u32>,
}

/// 访问范围
#[derive(Clone, Copy, Debug, PartialEq, Eq, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub enum AccessScope {
    /// 只读（查看命盘）
    ReadOnly,
    /// 可评论/解读
    CanComment,
    /// 可转授权（需谨慎）
    CanDelegate,
}
```

### 3.3 增强的加密命盘结构

```rust
/// 增强版加密八字命盘（支持多方访问）
#[derive(Clone, Debug, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub struct EncryptedBaziChartV2<T: Config> {
    // === 基础字段（与 V1 相同）===
    /// 所有者账户
    pub owner: T::AccountId,
    /// 四柱干支索引（明文，用于免费计算）
    pub sizhu_index: SiZhuIndex,
    /// 性别（明文，用于大运计算）
    pub gender: Gender,

    // === 加密数据 ===
    /// 加密的敏感数据（AES-256-GCM）
    pub encrypted_data: BoundedVec<u8, ConstU32<256>>,
    /// 加密使用的 nonce（12 bytes）
    pub nonce: [u8; 12],
    /// 认证标签（16 bytes）
    pub auth_tag: [u8; 16],

    // === 验证数据 ===
    /// 原始数据哈希（用于验证解密正确性）
    pub data_hash: [u8; 32],

    // === 元数据 ===
    /// 创建时间（区块号）
    pub created_at: u32,
    /// 加密方案版本
    pub encryption_version: u8,
    /// 当前授权数量（快速查询）
    pub active_grants_count: u16,
}
```

### 3.4 存储映射设计

```rust
/// 服务提供者注册表
#[pallet::storage]
pub type Providers<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::AccountId,  // 提供者账户
    ServiceProvider<T>,
>;

/// 命盘授权列表（命盘 ID → 授权列表）
#[pallet::storage]
pub type ChartGrants<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    u64,  // chart_id
    BoundedVec<AccessGrant<T>, ConstU32<50>>,  // 最多 50 个授权
    ValueQuery,
>;

/// 提供者收到的授权（提供者 → 命盘 ID 列表）
#[pallet::storage]
pub type ProviderGrants<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::AccountId,  // provider
    BoundedVec<u64, ConstU32<1000>>,  // 最多管理 1000 个命盘
    ValueQuery,
>;

/// 授权日志（用于审计）
#[pallet::storage]
pub type GrantLogs<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    u64,  // grant_id
    GrantLog<T>,
>;
```

---

## 四、交易接口设计

### 4.1 服务提供者管理

```rust
/// 注册成为服务提供者
#[pallet::call_index(10)]
pub fn register_provider(
    origin: OriginFor<T>,
    service_type: ServiceType,
    public_key: [u8; 32],  // X25519 公钥
    metadata: BoundedVec<u8, ConstU32<256>>,  // 服务描述
) -> DispatchResult;

/// 更新服务提供者公钥
#[pallet::call_index(11)]
pub fn update_provider_key(
    origin: OriginFor<T>,
    new_public_key: [u8; 32],
) -> DispatchResult;

/// 注销服务提供者
#[pallet::call_index(12)]
pub fn deregister_provider(
    origin: OriginFor<T>,
) -> DispatchResult;
```

### 4.2 授权管理

```rust
/// 授权服务提供者访问命盘
#[pallet::call_index(20)]
pub fn grant_access(
    origin: OriginFor<T>,
    chart_id: u64,
    provider: T::AccountId,
    encrypted_access_key: BoundedVec<u8, ConstU32<128>>,
    duration_blocks: Option<u32>,  // None = 永久
    scope: AccessScope,
) -> DispatchResult;

/// 撤销授权
#[pallet::call_index(21)]
pub fn revoke_access(
    origin: OriginFor<T>,
    grant_id: u64,
) -> DispatchResult;

/// 批量撤销（紧急情况）
#[pallet::call_index(22)]
pub fn revoke_all_access(
    origin: OriginFor<T>,
    chart_id: u64,
) -> DispatchResult;

/// 续期授权
#[pallet::call_index(23)]
pub fn extend_access(
    origin: OriginFor<T>,
    grant_id: u64,
    additional_blocks: u32,
    new_encrypted_access_key: Option<BoundedVec<u8, ConstU32<128>>>,
) -> DispatchResult;
```

---

## 五、前端加密流程

### 5.1 创建加密命盘

```typescript
// 1. 派生用户主密钥（只需做一次，安全存储在本地）
async function deriveMasterKey(wallet: Wallet): Promise<Uint8Array> {
    const message = "STARDUST_BAZI_MASTER_KEY_V1";
    const signature = await wallet.signMessage(message);
    return blake2_256(signature);
}

// 2. 派生命盘密钥
function deriveChartKey(masterKey: Uint8Array, chartId: bigint): Uint8Array {
    const data = new Uint8Array([
        ...new TextEncoder().encode("CHART_KEY"),
        ...masterKey,
        ...bigintToBytes(chartId, 8),
    ]);
    return blake2_256(data);
}

// 3. 加密命盘数据
async function encryptChartData(
    chartKey: Uint8Array,
    sensitiveData: BaziSensitiveData,
): Promise<EncryptedData> {
    const plaintext = JSON.stringify(sensitiveData);
    const nonce = crypto.getRandomValues(new Uint8Array(12));

    const key = await crypto.subtle.importKey(
        "raw",
        chartKey,
        { name: "AES-GCM" },
        false,
        ["encrypt"]
    );

    const ciphertext = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv: nonce },
        key,
        new TextEncoder().encode(plaintext)
    );

    return {
        encrypted_data: new Uint8Array(ciphertext),
        nonce: nonce,
        data_hash: blake2_256(new TextEncoder().encode(plaintext)),
    };
}
```

### 5.2 授权服务提供者

```typescript
// 1. 获取提供者公钥
async function getProviderPublicKey(
    api: ApiPromise,
    providerAccount: string,
): Promise<Uint8Array> {
    const provider = await api.query.baziBazi.providers(providerAccount);
    return provider.unwrap().publicKey;
}

// 2. 生成并加密访问密钥
async function createAccessGrant(
    masterKey: Uint8Array,
    chartId: bigint,
    providerPublicKey: Uint8Array,
    expiryBlock: number,
): Promise<EncryptedAccessKey> {
    // 派生访问密钥
    const chartKey = deriveChartKey(masterKey, chartId);
    const nonce = Date.now();
    const accessKey = deriveAccessKey(chartKey, providerPublicKey, expiryBlock, nonce);

    // 用提供者公钥加密（X25519 + ChaCha20-Poly1305）
    const encryptedAccessKey = await encryptForProvider(accessKey, providerPublicKey);

    return {
        encrypted_access_key: encryptedAccessKey,
        nonce: nonce,
    };
}

// 3. 提交授权交易
async function grantAccess(
    api: ApiPromise,
    signer: KeyringPair,
    chartId: bigint,
    provider: string,
    duration: number | null,
    scope: AccessScope,
): Promise<void> {
    const masterKey = await getMasterKeyFromStorage();
    const providerPubKey = await getProviderPublicKey(api, provider);
    const expiryBlock = duration
        ? (await api.query.system.number()).toNumber() + duration
        : 0;

    const { encrypted_access_key } = await createAccessGrant(
        masterKey,
        chartId,
        providerPubKey,
        expiryBlock,
    );

    await api.tx.baziBazi.grantAccess(
        chartId,
        provider,
        encrypted_access_key,
        duration,
        scope,
    ).signAndSend(signer);
}
```

### 5.3 服务提供者解密

```typescript
// 服务提供者端的解密流程
async function decryptChartAsProvider(
    api: ApiPromise,
    providerPrivateKey: Uint8Array,
    chartId: bigint,
): Promise<BaziSensitiveData | null> {
    // 1. 获取授权记录
    const grants = await api.query.baziBazi.chartGrants(chartId);
    const myGrant = grants.find(g =>
        g.provider.eq(providerAccount) &&
        !g.revoked &&
        (g.endBlock.eq(0) || g.endBlock.gt(currentBlock))
    );

    if (!myGrant) {
        throw new Error("No valid access grant found");
    }

    // 2. 解密访问密钥
    const accessKey = await decryptAccessKey(
        myGrant.encryptedAccessKey,
        providerPrivateKey,
    );

    // 3. 获取加密命盘
    const encryptedChart = await api.query.baziBazi.encryptedChartById(chartId);

    // 4. 使用访问密钥解密数据
    const decryptedData = await decryptWithAccessKey(
        encryptedChart.encryptedData,
        encryptedChart.nonce,
        accessKey,
    );

    // 5. 验证哈希
    const hash = blake2_256(decryptedData);
    if (!arraysEqual(hash, encryptedChart.dataHash)) {
        throw new Error("Data integrity check failed");
    }

    return JSON.parse(new TextDecoder().decode(decryptedData));
}
```

---

## 六、安全分析

### 6.1 威胁模型

| 威胁 | 缓解措施 |
|------|----------|
| 链上数据泄露 | 敏感数据加密存储，只有密钥持有者可解密 |
| 服务提供者滥用 | 时间限制授权 + 可撤销 + 链上审计日志 |
| 密钥泄露 | 每个命盘独立密钥，单个泄露不影响其他 |
| 重放攻击 | 授权包含 nonce，每次授权唯一 |
| 前端攻击 | 密钥派生在本地，原始密钥不离开浏览器 |

### 6.2 隐私保护层级

```
┌─────────────────────────────────────────────────────────────────┐
│  Layer 1: 四柱索引（公开）                                        │
│  - 可用于免费解盘计算                                             │
│  - 无法反推出生时间                                               │
├─────────────────────────────────────────────────────────────────┤
│  Layer 2: 加密敏感数据（仅授权方可见）                              │
│  - 出生时间、地点、备注等                                          │
│  - 需要有效授权才能解密                                            │
├─────────────────────────────────────────────────────────────────┤
│  Layer 3: 主密钥（仅用户持有）                                     │
│  - 由钱包签名派生                                                  │
│  - 永不上链、永不暴露                                              │
└─────────────────────────────────────────────────────────────────┘
```

### 6.3 授权撤销安全

```
撤销授权后：
┌──────────────────────────────────────────────────────────────────┐
│  1. 链上标记 revoked = true                                       │
│  2. 服务提供者无法使用旧的 AccessKey（链上验证会失败）                │
│  3. 用户可选择重新加密数据（使用新的 ChartKey）                      │
│  4. 新授权使用新的 AccessKey，与旧授权隔离                          │
└──────────────────────────────────────────────────────────────────┘
```

---

## 七、使用场景示例

### 场景 1：用户找命理师解读

```
1. 用户创建加密命盘（出生时间加密）
2. 用户在平台搜索命理师，查看其资质和评价
3. 用户点击"授权解读"，选择授权期限（如 7 天）
4. 前端自动生成 AccessKey，用命理师公钥加密后上链
5. 命理师收到通知，使用私钥解密获取 AccessKey
6. 命理师解密命盘数据，进行解读
7. 7 天后授权自动失效，命理师无法再解密
```

### 场景 2：AI 服务批量解读

```
1. AI 服务商注册为服务提供者，上传公钥
2. 用户授权 AI 服务（可设为永久）
3. AI 服务解密用户命盘，生成解读报告
4. 报告可选择加密存储或明文返回给用户
5. 用户随时可撤销授权
```

### 场景 3：研究机构数据分析

```
1. 研究机构注册，声明研究目的
2. 用户主动授权（可获得激励）
3. 研究机构只能看到：
   - 四柱索引（已是公开的）
   - 授权后才能看出生时间
4. 研究机构承诺匿名化处理
5. 用户随时可退出研究
```

---

## 八、实现路线图

### Phase 1：基础设施（预计 2 周）

- [ ] 新增 `ServiceProvider` 存储和注册接口
- [ ] 新增 `AccessGrant` 存储和授权接口
- [ ] 升级 `EncryptedBaziChart` 为 V2 版本
- [ ] 实现授权验证逻辑

### Phase 2：前端集成（预计 2 周）

- [ ] 实现密钥派生 SDK（TypeScript）
- [ ] 实现加密/解密工具函数
- [ ] 授权管理界面（授权/撤销/查看）
- [ ] 服务提供者注册界面

### Phase 3：服务提供者工具（预计 1 周）

- [ ] 提供者 SDK（解密、验证授权）
- [ ] 示例解读服务接入代码
- [ ] 授权通知 webhook

### Phase 4：安全审计与优化（预计 2 周）

- [ ] 密码学实现审计
- [ ] 渗透测试
- [ ] 性能优化
- [ ] 文档完善

---

## 九、附录

### A. 密码学库选择

| 功能 | 推荐库 | 说明 |
|------|--------|------|
| 哈希 | blake2 | Substrate 原生支持 |
| 对称加密 | AES-256-GCM | Web Crypto API 原生支持 |
| 密钥交换 | X25519 | libsodium / @noble/curves |
| 签名 | Ed25519/Sr25519 | 钱包原生支持 |

### B. 存储成本估算

| 数据项 | 大小（bytes） | 说明 |
|--------|--------------|------|
| EncryptedBaziChartV2 | ~350 | 包含加密数据和元数据 |
| AccessGrant | ~200 | 单个授权记录 |
| ServiceProvider | ~350 | 提供者信息 |

### C. 相关标准参考

- [NaCl/libsodium](https://nacl.cr.yp.to/) - 密码学库
- [ECIES](https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme) - 混合加密方案
- [X25519](https://cr.yp.to/ecdh.html) - 密钥交换
- [AES-GCM](https://en.wikipedia.org/wiki/Galois/Counter_Mode) - 认证加密
