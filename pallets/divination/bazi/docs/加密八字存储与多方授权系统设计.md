# 加密八字存储与多方授权系统设计

## 一、概述

### 1.1 设计目标

本设计实现八字命盘的加密存储与多方授权访问系统，核心功能：

1. **隐私保护**：用户敏感数据（出生时间等）加密存储在链上
2. **多方解密**：用户可授权命理师、AI服务、家族成员等解密访问
3. **细粒度控制**：支持时间限制、访问范围控制、随时撤销
4. **免费计算**：四柱索引明文存储，Runtime API 可免费计算解盘
5. **可审计**：所有授权操作上链记录，完全透明

### 1.2 典型场景

```
用户张三创建加密命盘（出生时间加密）
    ↓
授权给命理师 A（7天有效期，只读权限）
授权给 AI 服务（永久，只读权限）
授权给家人（永久，可评论权限）
    ↓
命理师/AI/家人 各自用私钥解密查看
    ↓
7天后命理师授权自动失效
用户主动撤销 AI 服务授权
    ↓
只有家人仍可访问
```

---

## 二、密钥架构

### 2.1 会话密钥体系（Session Key Architecture）

```
┌─────────────────────────────────────────────────────────────────┐
│                      主密钥（MasterKey）                          │
│           钱包签名固定消息派生，【永不存储】，用完即丢               │
│           MasterKey = Blake2_256("STARDUST_BAZI_V1" || signature) │
│           仅在需要时临时派生，操作完成后立即从内存清除               │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼ (派生)
┌─────────────────────────────────────────────────────────────────┐
│                    会话密钥（SessionKey）                         │
│           MasterKey + 时间戳 派生，存储在 SessionStorage           │
│           SessionKey = Blake2_256(MasterKey || timestamp || nonce)│
│           有效期 1 小时，关闭浏览器自动清除                         │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼ (加密)
┌─────────────────────────────────────────────────────────────────┐
│                    数据密钥（DataKey）                            │
│           随机生成，用于 AES-256-GCM 加密敏感数据                   │
│           每个命盘独立，单个泄露不影响其他                           │
│           DataKey 用 SessionKey 加密后临时缓存                     │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼ (分发)
┌─────────────────────────────────────────────────────────────────┐
│                   授权密钥分发（KeyDistribution）                  │
│           DataKey 用各授权方公钥加密后上链                          │
│           每方用自己的私钥解密获取 DataKey                          │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 会话密钥生命周期

```
┌────────────────────────────────────────────────────────────────────┐
│                        会话密钥生命周期                              │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  1. 用户登录/首次操作                                                │
│     ├─ 检查 SessionStorage 是否有有效会话                           │
│     ├─ 如果没有或已过期：                                            │
│     │   ├─ 请求钱包签名固定消息                                      │
│     │   ├─ 派生 MasterKey（内存中，不存储）                          │
│     │   ├─ 派生 SessionKey = Blake2(MasterKey || timestamp || nonce)│
│     │   ├─ 存储到 SessionStorage: { sessionKey, expiresAt, nonce }  │
│     │   └─ 立即清除 MasterKey                                       │
│     └─ 如果有效：直接使用缓存的 SessionKey                           │
│                                                                    │
│  2. 会话期间操作（无需再次签名）                                      │
│     ├─ 从 SessionStorage 读取 SessionKey                           │
│     ├─ 验证 expiresAt > Date.now()                                 │
│     └─ 使用 SessionKey 进行加密/解密操作                             │
│                                                                    │
│  3. 会话过期（1小时后）                                              │
│     ├─ 前端检测到 expiresAt <= Date.now()                          │
│     ├─ 清除 SessionStorage                                         │
│     └─ 下次操作重新请求签名                                          │
│                                                                    │
│  4. 用户关闭浏览器                                                   │
│     └─ SessionStorage 自动清除（浏览器行为）                          │
│                                                                    │
│  5. 用户主动登出                                                     │
│     └─ 调用 clearSession() 清除 SessionStorage                      │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

### 2.3 密钥派生算法

```rust
/// 主密钥派生（前端执行，永不存储，用完即丢）
///
/// 用户使用钱包签名固定消息，哈希后得到主密钥
/// ⚠️ 此密钥仅在内存中临时存在，操作完成后必须立即清除
fn derive_master_key(wallet_signature: &[u8; 64]) -> [u8; 32] {
    blake2_256(b"STARDUST_BAZI_MASTER_KEY_V1" || wallet_signature)
}

/// 会话密钥派生（存储在 SessionStorage，有效期 1 小时）
///
/// 从主密钥派生会话密钥，包含时间戳和随机 nonce
/// 会话密钥可安全存储，因为没有主密钥无法反推
fn derive_session_key(
    master_key: &[u8; 32],
    timestamp: u64,
    nonce: &[u8; 16],
) -> [u8; 32] {
    blake2_256(
        b"STARDUST_SESSION_KEY_V1" ||
        master_key ||
        timestamp.to_le_bytes() ||
        nonce
    )
}

/// 数据密钥生成（每个命盘独立）
///
/// 随机生成 32 字节密钥，用于 AES-256-GCM 加密
fn generate_data_key() -> [u8; 32] {
    let mut key = [0u8; 32];
    getrandom::getrandom(&mut key).expect("Failed to generate random key");
    key
}

/// 数据密钥加密（为授权方加密 DataKey）
///
/// 使用 X25519 + ChaCha20-Poly1305 混合加密
fn encrypt_data_key_for_recipient(
    data_key: &[u8; 32],
    recipient_public_key: &[u8; 32],
) -> EncryptedKey {
    // X25519 密钥交换 + ChaCha20-Poly1305 加密
    let shared_secret = x25519(sender_private, recipient_public_key);
    let encryption_key = blake2_256(b"ENCRYPT_KEY" || shared_secret);
    chacha20_poly1305_encrypt(data_key, &encryption_key)
}
```

### 2.4 会话密钥安全性分析

| 特性 | 说明 |
|------|------|
| **主密钥永不存储** | 每次需要时从钱包签名派生，用完立即清除 |
| **会话密钥有时效** | 1 小时自动过期，减少泄露风险 |
| **浏览器关闭清除** | SessionStorage 特性，标签页关闭即清除 |
| **无法反推主密钥** | 会话密钥包含随机 nonce，无法反推原始签名 |
| **签名请求最小化** | 会话期间只需签名一次，用户体验好 |
| **跨标签页隔离** | 每个标签页独立会话，互不影响 |

---

## 三、数据结构设计

### 3.1 服务提供者注册

```rust
/// 服务提供者类型
#[derive(Clone, Copy, Debug, PartialEq, Eq, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub enum ServiceProviderType {
    /// 命理师（人工解读）
    MingLiShi = 0,
    /// AI 解读服务
    AiService = 1,
    /// 家族成员
    FamilyMember = 2,
    /// 研究机构
    Research = 3,
}

/// 服务提供者信息
#[derive(Clone, Debug, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub struct ServiceProvider<T: Config> {
    /// 提供者账户
    pub account: T::AccountId,
    /// 服务类型
    pub provider_type: ServiceProviderType,
    /// X25519 公钥（32 bytes，用于密钥加密）
    pub public_key: [u8; 32],
    /// 信誉分（0-100，用于筛选）
    pub reputation: u8,
    /// 注册时间（区块号）
    pub registered_at: u32,
    /// 是否激活
    pub is_active: bool,
}
```

### 3.2 访问授权记录

```rust
/// 授权角色类型
#[derive(Clone, Copy, Debug, PartialEq, Eq, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub enum AccessRole {
    /// 所有者（不可撤销）
    Owner = 0,
    /// 命理师（可撤销）
    Master = 1,
    /// 家族成员（可撤销）
    Family = 2,
    /// AI 服务（可撤销）
    AiService = 3,
}

/// 访问范围
#[derive(Clone, Copy, Debug, PartialEq, Eq, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub enum AccessScope {
    /// 只读（查看命盘）
    ReadOnly = 0,
    /// 可评论/解读
    CanComment = 1,
    /// 完全访问（含元数据）
    FullAccess = 2,
}

/// 加密密钥条目（链上存储）
#[derive(Clone, Debug, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub struct EncryptedKeyEntry<AccountId> {
    /// 授权账户
    pub account: AccountId,
    /// 用该账户公钥加密的 DataKey（48-64 bytes）
    /// 格式：nonce(12) + ciphertext(32) + tag(16)
    pub encrypted_key: BoundedVec<u8, ConstU32<64>>,
    /// 授权角色
    pub role: AccessRole,
    /// 访问范围
    pub scope: AccessScope,
    /// 授权开始时间（区块号）
    pub granted_at: u32,
    /// 授权结束时间（区块号，0 = 永久）
    pub expires_at: u32,
}
```

### 3.3 加密命盘结构 V2

```rust
/// 加密八字命盘 V2（支持多方授权）
///
/// # 存储结构（约 400-1400 bytes）
/// - sizhu_index: 8 bytes（四柱索引，明文）
/// - gender: 1 byte（性别，明文）
/// - encrypted_data: 64-256 bytes（加密的敏感数据）
/// - encrypted_keys: 每个授权约 100 bytes，最多 10 个
/// - 元数据: 约 50 bytes
#[derive(Clone, Debug, Encode, Decode, TypeInfo, MaxEncodedLen)]
#[scale_info(skip_type_params(T))]
pub struct EncryptedBaziChartV2<T: Config> {
    // === 基础信息（明文） ===
    /// 所有者账户
    pub owner: T::AccountId,
    /// 四柱干支索引（用于免费计算解盘）
    pub sizhu_index: SiZhuIndex,
    /// 性别（用于大运计算）
    pub gender: Gender,

    // === 加密数据 ===
    /// AES-256-GCM 加密的敏感数据
    /// 内容：出生时间、子时模式、经度、备注等
    pub encrypted_data: BoundedVec<u8, ConstU32<256>>,
    /// 加密使用的 nonce（12 bytes）
    pub nonce: [u8; 12],
    /// 认证标签（16 bytes）
    pub auth_tag: [u8; 16],

    // === 密钥分发 ===
    /// 多个加密的 DataKey（最多 10 个授权）
    pub encrypted_keys: BoundedVec<EncryptedKeyEntry<T::AccountId>, ConstU32<10>>,

    // === 验证与元数据 ===
    /// 原始数据哈希（用于验证解密正确性）
    pub data_hash: [u8; 32],
    /// 创建时间（区块号）
    pub created_at: u32,
    /// 加密方案版本
    pub encryption_version: u8,
}
```

### 3.4 敏感数据结构（加密前）

```rust
/// 敏感数据（前端加密/解密）
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SensitiveData {
    /// 出生年份
    pub birth_year: u16,
    /// 出生月份
    pub birth_month: u8,
    /// 出生日期
    pub birth_day: u8,
    /// 出生小时
    pub birth_hour: u8,
    /// 出生分钟
    pub birth_minute: u8,
    /// 子时模式
    pub zishi_mode: u8,
    /// 出生地经度（可选）
    pub longitude: Option<i32>,
    /// 输入日历类型（0=公历, 1=农历）
    pub input_calendar_type: u8,
    /// 命盘名称（可选）
    pub name: Option<String>,
    /// 备注（可选）
    pub notes: Option<String>,
}
```

---

## 四、存储设计

### 4.1 存储映射

```rust
/// 服务提供者注册表
#[pallet::storage]
#[pallet::getter(fn providers)]
pub type Providers<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::AccountId,
    ServiceProvider<T>,
>;

/// 加密命盘存储（V2 版本）
#[pallet::storage]
#[pallet::getter(fn encrypted_chart_v2_by_id)]
pub type EncryptedChartV2ById<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    u64,  // chart_id
    EncryptedBaziChartV2<T>,
>;

/// 用户的加密命盘列表
#[pallet::storage]
#[pallet::getter(fn user_encrypted_charts_v2)]
pub type UserEncryptedChartsV2<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::AccountId,
    BoundedVec<u64, T::MaxChartsPerAccount>,
    ValueQuery,
>;

/// 提供者收到的授权（快速查询）
#[pallet::storage]
#[pallet::getter(fn provider_grants)]
pub type ProviderGrants<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::AccountId,  // provider
    BoundedVec<u64, ConstU32<1000>>,  // chart_ids
    ValueQuery,
>;
```

### 4.2 版本兼容

```rust
/// 统一的加密命盘存储（支持多版本）
#[derive(Clone, Debug, Encode, Decode, TypeInfo)]
pub enum EncryptedBaziChartVersion<T: Config> {
    /// V1: 单密钥版本（现有系统）
    V1(EncryptedBaziChart<T>),
    /// V2: 多密钥版本（新增）
    V2(EncryptedBaziChartV2<T>),
}
```

---

## 五、交易接口设计

### 5.1 服务提供者管理

```rust
/// 注册成为服务提供者
///
/// # 参数
/// - provider_type: 服务类型
/// - public_key: X25519 公钥（用于接收加密的 DataKey）
///
/// # 注意
/// - 公钥必须是有效的 X25519 公钥（32 bytes）
/// - 初始信誉分为 50
#[pallet::call_index(10)]
#[pallet::weight(T::WeightInfo::register_provider())]
pub fn register_provider(
    origin: OriginFor<T>,
    provider_type: ServiceProviderType,
    public_key: [u8; 32],
) -> DispatchResult {
    let who = ensure_signed(origin)?;

    // 检查未重复注册
    ensure!(
        !Providers::<T>::contains_key(&who),
        Error::<T>::ProviderAlreadyRegistered
    );

    let current_block = <frame_system::Pallet<T>>::block_number().saturated_into();

    let provider = ServiceProvider {
        account: who.clone(),
        provider_type,
        public_key,
        reputation: 50,
        registered_at: current_block,
        is_active: true,
    };

    Providers::<T>::insert(&who, provider);

    Self::deposit_event(Event::ProviderRegistered {
        account: who,
        provider_type,
    });

    Ok(())
}

/// 更新服务提供者公钥
#[pallet::call_index(11)]
#[pallet::weight(T::WeightInfo::update_provider_key())]
pub fn update_provider_key(
    origin: OriginFor<T>,
    new_public_key: [u8; 32],
) -> DispatchResult;

/// 注销服务提供者
#[pallet::call_index(12)]
#[pallet::weight(T::WeightInfo::deregister_provider())]
pub fn deregister_provider(
    origin: OriginFor<T>,
) -> DispatchResult;
```

### 5.2 加密命盘管理

```rust
/// 创建支持多方授权的加密命盘
///
/// # 参数
/// - sizhu_index: 四柱干支索引（明文）
/// - gender: 性别（明文）
/// - encrypted_data: AES-256-GCM 加密的敏感数据
/// - nonce: 加密 nonce（12 bytes）
/// - auth_tag: 认证标签（16 bytes）
/// - encrypted_keys: 多个加密的 DataKey（含所有者 + 初始授权方）
/// - data_hash: 原始数据哈希
///
/// # 验证
/// - encrypted_keys 必须包含一个 Owner 角色且账户等于调用者
/// - encrypted_keys 长度 ≤ 10
#[pallet::call_index(20)]
#[pallet::weight(T::WeightInfo::create_encrypted_chart_v2())]
pub fn create_encrypted_chart_v2(
    origin: OriginFor<T>,
    sizhu_index: SiZhuIndex,
    gender: Gender,
    encrypted_data: BoundedVec<u8, ConstU32<256>>,
    nonce: [u8; 12],
    auth_tag: [u8; 16],
    encrypted_keys: BoundedVec<EncryptedKeyEntry<T::AccountId>, ConstU32<10>>,
    data_hash: [u8; 32],
) -> DispatchResult {
    let who = ensure_signed(origin)?;

    // 验证四柱索引有效性
    ensure!(sizhu_index.is_valid(), Error::<T>::InvalidSiZhuIndex);

    // 验证必须有 Owner 密钥且账户匹配
    let has_owner = encrypted_keys.iter().any(|k|
        k.account == who && k.role == AccessRole::Owner
    );
    ensure!(has_owner, Error::<T>::MissingOwnerKey);

    // 检查账户命盘数量限制
    let existing = UserEncryptedChartsV2::<T>::get(&who);
    ensure!(
        existing.len() < T::MaxChartsPerAccount::get() as usize,
        Error::<T>::TooManyCharts
    );

    // 获取新 ID
    let chart_id = NextChartId::<T>::get();
    ensure!(chart_id < u64::MAX, Error::<T>::ChartIdOverflow);

    let current_block = <frame_system::Pallet<T>>::block_number().saturated_into();

    // 构建命盘
    let chart = EncryptedBaziChartV2 {
        owner: who.clone(),
        sizhu_index,
        gender,
        encrypted_data,
        nonce,
        auth_tag,
        encrypted_keys: encrypted_keys.clone(),
        data_hash,
        created_at: current_block,
        encryption_version: 2,
    };

    // 存储
    EncryptedChartV2ById::<T>::insert(chart_id, chart);

    UserEncryptedChartsV2::<T>::try_mutate(&who, |charts| {
        charts.try_push(chart_id).map_err(|_| Error::<T>::TooManyCharts)
    })?;

    // 更新提供者授权索引
    for key_entry in encrypted_keys.iter() {
        if key_entry.role != AccessRole::Owner {
            ProviderGrants::<T>::try_mutate(&key_entry.account, |grants| {
                grants.try_push(chart_id).ok();
                Ok::<(), ()>(())
            }).ok();
        }
    }

    NextChartId::<T>::put(chart_id + 1);

    Self::deposit_event(Event::EncryptedChartV2Created {
        owner: who,
        chart_id,
        initial_grants: encrypted_keys.len() as u8 - 1,
    });

    Ok(())
}
```

### 5.3 授权管理

```rust
/// 授权新账户访问命盘
///
/// # 参数
/// - chart_id: 命盘 ID
/// - grantee: 被授权账户
/// - encrypted_key: 用被授权方公钥加密的 DataKey
/// - role: 授权角色
/// - scope: 访问范围
/// - duration_blocks: 有效期（区块数，None = 永久）
///
/// # 权限
/// - 只有所有者可以授权
/// - 不能超过 10 个授权
/// - 不能授权自己（已经是 Owner）
#[pallet::call_index(21)]
#[pallet::weight(T::WeightInfo::grant_chart_access())]
pub fn grant_chart_access(
    origin: OriginFor<T>,
    chart_id: u64,
    grantee: T::AccountId,
    encrypted_key: BoundedVec<u8, ConstU32<64>>,
    role: AccessRole,
    scope: AccessScope,
    duration_blocks: Option<u32>,
) -> DispatchResult {
    let who = ensure_signed(origin)?;

    // 获取命盘并验证所有权
    let mut chart = EncryptedChartV2ById::<T>::get(chart_id)
        .ok_or(Error::<T>::ChartNotFound)?;
    ensure!(chart.owner == who, Error::<T>::NotOwner);

    // 不能授权给自己
    ensure!(grantee != who, Error::<T>::CannotGrantToSelf);

    // 检查是否已授权
    let already_granted = chart.encrypted_keys.iter()
        .any(|k| k.account == grantee);
    ensure!(!already_granted, Error::<T>::AlreadyGranted);

    // 检查授权数量限制
    ensure!(
        chart.encrypted_keys.len() < 10,
        Error::<T>::TooManyAuthorizations
    );

    // 验证被授权方是注册的服务提供者（可选）
    if role == AccessRole::Master || role == AccessRole::AiService {
        ensure!(
            Providers::<T>::contains_key(&grantee),
            Error::<T>::ProviderNotRegistered
        );
    }

    let current_block = <frame_system::Pallet<T>>::block_number().saturated_into();
    let expires_at = duration_blocks.map(|d| current_block + d).unwrap_or(0);

    // 添加新授权
    let entry = EncryptedKeyEntry {
        account: grantee.clone(),
        encrypted_key,
        role,
        scope,
        granted_at: current_block,
        expires_at,
    };

    chart.encrypted_keys.try_push(entry)
        .map_err(|_| Error::<T>::TooManyAuthorizations)?;

    EncryptedChartV2ById::<T>::insert(chart_id, chart);

    // 更新提供者索引
    ProviderGrants::<T>::try_mutate(&grantee, |grants| {
        grants.try_push(chart_id).ok();
        Ok::<(), ()>(())
    }).ok();

    Self::deposit_event(Event::ChartAccessGranted {
        chart_id,
        owner: who,
        grantee,
        role,
        scope,
        expires_at,
    });

    Ok(())
}

/// 撤销账户访问权限
#[pallet::call_index(22)]
#[pallet::weight(T::WeightInfo::revoke_chart_access())]
pub fn revoke_chart_access(
    origin: OriginFor<T>,
    chart_id: u64,
    revokee: T::AccountId,
) -> DispatchResult {
    let who = ensure_signed(origin)?;

    let mut chart = EncryptedChartV2ById::<T>::get(chart_id)
        .ok_or(Error::<T>::ChartNotFound)?;
    ensure!(chart.owner == who, Error::<T>::NotOwner);

    // 不能撤销所有者
    ensure!(revokee != who, Error::<T>::CannotRevokeOwner);

    // 检查是否存在该授权
    let existed = chart.encrypted_keys.iter()
        .any(|k| k.account == revokee);
    ensure!(existed, Error::<T>::GrantNotFound);

    // 移除授权
    chart.encrypted_keys.retain(|k| k.account != revokee);

    EncryptedChartV2ById::<T>::insert(chart_id, chart);

    // 更新提供者索引
    ProviderGrants::<T>::try_mutate(&revokee, |grants| {
        grants.retain(|&id| id != chart_id);
        Ok::<(), ()>(())
    }).ok();

    Self::deposit_event(Event::ChartAccessRevoked {
        chart_id,
        owner: who,
        revokee,
    });

    Ok(())
}

/// 批量撤销所有授权（紧急情况）
#[pallet::call_index(23)]
#[pallet::weight(T::WeightInfo::revoke_all_access())]
pub fn revoke_all_access(
    origin: OriginFor<T>,
    chart_id: u64,
) -> DispatchResult {
    let who = ensure_signed(origin)?;

    let mut chart = EncryptedChartV2ById::<T>::get(chart_id)
        .ok_or(Error::<T>::ChartNotFound)?;
    ensure!(chart.owner == who, Error::<T>::NotOwner);

    // 收集要撤销的账户（用于更新索引）
    let revoked_accounts: Vec<T::AccountId> = chart.encrypted_keys.iter()
        .filter(|k| k.role != AccessRole::Owner)
        .map(|k| k.account.clone())
        .collect();

    // 只保留 Owner
    chart.encrypted_keys.retain(|k| k.role == AccessRole::Owner);

    EncryptedChartV2ById::<T>::insert(chart_id, chart);

    // 更新所有提供者索引
    for account in revoked_accounts.iter() {
        ProviderGrants::<T>::try_mutate(account, |grants| {
            grants.retain(|&id| id != chart_id);
            Ok::<(), ()>(())
        }).ok();
    }

    Self::deposit_event(Event::AllAccessRevoked {
        chart_id,
        owner: who,
        count: revoked_accounts.len() as u8,
    });

    Ok(())
}

/// 续期授权
#[pallet::call_index(24)]
#[pallet::weight(T::WeightInfo::extend_access())]
pub fn extend_access(
    origin: OriginFor<T>,
    chart_id: u64,
    grantee: T::AccountId,
    additional_blocks: u32,
    new_encrypted_key: Option<BoundedVec<u8, ConstU32<64>>>,
) -> DispatchResult;
```

---

## 六、前端加密流程

### 6.1 会话密钥管理

```typescript
// session-key-manager.ts

import { blake2AsU8a } from '@polkadot/util-crypto';
import { u8aToHex, hexToU8a } from '@polkadot/util';

const MASTER_KEY_MESSAGE = "STARDUST_BAZI_MASTER_KEY_V1";
const SESSION_KEY_PREFIX = "STARDUST_SESSION_KEY_V1";
const SESSION_STORAGE_KEY = "stardust_bazi_session";
const SESSION_DURATION_MS = 60 * 60 * 1000; // 1 小时

/**
 * 会话数据结构
 */
interface SessionData {
    sessionKey: string;      // hex 编码的会话密钥
    expiresAt: number;       // 过期时间戳（毫秒）
    nonce: string;           // hex 编码的随机 nonce
    address: string;         // 钱包地址（用于验证）
}

/**
 * 检查会话是否有效
 */
export function isSessionValid(): boolean {
    const session = getSession();
    if (!session) return false;
    return session.expiresAt > Date.now();
}

/**
 * 获取当前会话
 */
function getSession(): SessionData | null {
    try {
        const data = sessionStorage.getItem(SESSION_STORAGE_KEY);
        if (!data) return null;
        return JSON.parse(data) as SessionData;
    } catch {
        return null;
    }
}

/**
 * 获取会话密钥（如果有效）
 *
 * @returns 会话密钥或 null（需要重新登录）
 */
export function getSessionKey(): Uint8Array | null {
    const session = getSession();
    if (!session || session.expiresAt <= Date.now()) {
        clearSession();
        return null;
    }
    return hexToU8a(session.sessionKey);
}

/**
 * 初始化会话（用户登录时调用）
 *
 * ⚠️ 这是唯一需要钱包签名的地方
 * 会话期间（1小时）后续操作无需再次签名
 *
 * @param wallet - 钱包实例
 * @param address - 钱包地址
 * @returns 会话密钥
 */
export async function initSession(
    wallet: Wallet,
    address: string
): Promise<Uint8Array> {
    // 1. 检查是否有有效会话（同一地址）
    const existingSession = getSession();
    if (existingSession &&
        existingSession.address === address &&
        existingSession.expiresAt > Date.now()) {
        return hexToU8a(existingSession.sessionKey);
    }

    // 2. 请求钱包签名（唯一需要签名的地方）
    const signature = await wallet.signMessage(MASTER_KEY_MESSAGE);

    // 3. 派生主密钥（仅在内存中，不存储）
    const masterKey = blake2AsU8a(signature, 256);

    // 4. 生成随机 nonce
    const nonce = crypto.getRandomValues(new Uint8Array(16));

    // 5. 派生会话密钥
    const timestamp = Date.now();
    const sessionKeyInput = new Uint8Array([
        ...new TextEncoder().encode(SESSION_KEY_PREFIX),
        ...masterKey,
        ...new Uint8Array(new BigUint64Array([BigInt(timestamp)]).buffer),
        ...nonce,
    ]);
    const sessionKey = blake2AsU8a(sessionKeyInput, 256);

    // 6. 存储到 SessionStorage
    const sessionData: SessionData = {
        sessionKey: u8aToHex(sessionKey),
        expiresAt: timestamp + SESSION_DURATION_MS,
        nonce: u8aToHex(nonce),
        address,
    };
    sessionStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(sessionData));

    // 7. ⚠️ 立即清除主密钥（关键安全步骤）
    // masterKey 变量将在函数结束后被 GC 回收
    // 这里我们不能真正"清除"它，但确保不存储到任何持久化存储

    return sessionKey;
}

/**
 * 清除会话（用户登出或会话过期时调用）
 */
export function clearSession(): void {
    sessionStorage.removeItem(SESSION_STORAGE_KEY);
}

/**
 * 获取会话剩余时间（毫秒）
 */
export function getSessionRemainingTime(): number {
    const session = getSession();
    if (!session) return 0;
    return Math.max(0, session.expiresAt - Date.now());
}

/**
 * 续期会话（需要重新签名）
 *
 * @param wallet - 钱包实例
 * @param address - 钱包地址
 * @returns 新的会话密钥
 */
export async function renewSession(
    wallet: Wallet,
    address: string
): Promise<Uint8Array> {
    clearSession();
    return initSession(wallet, address);
}
```

### 6.2 加密工具函数

```typescript
// crypto-utils.ts

import { blake2AsU8a, naclEncrypt, naclDecrypt } from '@polkadot/util-crypto';
import { hexToU8a, u8aToHex } from '@polkadot/util';
import { getSessionKey, initSession, isSessionValid } from './session-key-manager';

/**
 * 确保有有效会话，否则初始化
 *
 * @param wallet - 钱包实例（仅在需要初始化时使用）
 * @param address - 钱包地址
 * @returns 会话密钥
 */
export async function ensureSession(
    wallet: Wallet,
    address: string
): Promise<Uint8Array> {
    const sessionKey = getSessionKey();
    if (sessionKey) {
        return sessionKey;
    }
    return initSession(wallet, address);
}

/**
 * 生成随机数据密钥
 *
 * @returns 32 字节随机密钥
 */
export function generateDataKey(): Uint8Array {
    return crypto.getRandomValues(new Uint8Array(32));
}

/**
 * 使用 AES-256-GCM 加密数据
 */
export async function encryptWithAES(
    plaintext: string,
    key: Uint8Array
): Promise<{ ciphertext: Uint8Array; nonce: Uint8Array; tag: Uint8Array }> {
    const nonce = crypto.getRandomValues(new Uint8Array(12));
    const encoder = new TextEncoder();
    const data = encoder.encode(plaintext);

    const cryptoKey = await crypto.subtle.importKey(
        'raw',
        key,
        { name: 'AES-GCM' },
        false,
        ['encrypt']
    );

    const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv: nonce },
        cryptoKey,
        data
    );

    // 分离 ciphertext 和 auth tag
    const encryptedArray = new Uint8Array(encrypted);
    const ciphertext = encryptedArray.slice(0, -16);
    const tag = encryptedArray.slice(-16);

    return { ciphertext, nonce, tag };
}

/**
 * 使用 AES-256-GCM 解密数据
 */
export async function decryptWithAES(
    ciphertext: Uint8Array,
    nonce: Uint8Array,
    tag: Uint8Array,
    key: Uint8Array
): Promise<string> {
    const cryptoKey = await crypto.subtle.importKey(
        'raw',
        key,
        { name: 'AES-GCM' },
        false,
        ['decrypt']
    );

    // 合并 ciphertext 和 tag
    const combined = new Uint8Array(ciphertext.length + tag.length);
    combined.set(ciphertext);
    combined.set(tag, ciphertext.length);

    const decrypted = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv: nonce },
        cryptoKey,
        combined
    );

    return new TextDecoder().decode(decrypted);
}

/**
 * 使用公钥加密数据密钥（NaCl box）
 */
export function encryptKeyForRecipient(
    dataKey: Uint8Array,
    recipientPublicKey: Uint8Array,
    senderSecretKey: Uint8Array
): Uint8Array {
    const { encrypted, nonce } = naclEncrypt(dataKey, senderSecretKey, recipientPublicKey);
    // 返回 nonce + encrypted
    const result = new Uint8Array(nonce.length + encrypted.length);
    result.set(nonce);
    result.set(encrypted, nonce.length);
    return result;
}

/**
 * 使用私钥解密数据密钥
 */
export function decryptKeyFromSender(
    encryptedKey: Uint8Array,
    senderPublicKey: Uint8Array,
    recipientSecretKey: Uint8Array
): Uint8Array | null {
    const nonce = encryptedKey.slice(0, 24);
    const encrypted = encryptedKey.slice(24);
    return naclDecrypt(encrypted, nonce, senderPublicKey, recipientSecretKey);
}
```

### 6.3 创建加密命盘

```typescript
// create-encrypted-chart.ts

import { ApiPromise } from '@polkadot/api';
import { blake2AsU8a } from '@polkadot/util-crypto';
import {
    generateDataKey,
    encryptWithAES,
    encryptKeyForRecipient,
} from './crypto-utils';
import { ensureSession, isSessionValid } from './session-key-manager';

interface BirthData {
    year: number;
    month: number;
    day: number;
    hour: number;
    minute: number;
    zishiMode: number;
    longitude?: number;
    inputCalendarType: number;
    name?: string;
}

interface AuthorizedParty {
    account: string;
    publicKey: Uint8Array;
    role: 'Master' | 'Family' | 'AiService';
    scope: 'ReadOnly' | 'CanComment' | 'FullAccess';
    durationBlocks?: number;
}

/**
 * 创建支持多方授权的加密命盘
 *
 * ⚠️ 会话密钥方案说明：
 * - 首次调用时会请求钱包签名（派生会话密钥）
 * - 会话期间（1小时）后续调用无需再次签名
 * - 数据密钥是随机生成的，与会话密钥独立
 * - 会话密钥仅用于用户身份验证，不直接用于数据加密
 */
export async function createMultiKeyEncryptedChart(
    api: ApiPromise,
    wallet: Wallet,
    signer: KeyringPair,
    sizhuIndex: SiZhuIndex,
    gender: number,
    birthData: BirthData,
    authorizedParties: AuthorizedParty[]
): Promise<number> {
    // 0. 确保有有效会话（首次会请求签名，后续复用）
    if (!isSessionValid()) {
        await ensureSession(wallet, signer.address);
    }

    // 1. 生成随机数据密钥（每个命盘独立）
    const dataKey = generateDataKey();

    // 2. 加密敏感数据
    const plaintext = JSON.stringify(birthData);
    const { ciphertext, nonce, tag } = await encryptWithAES(plaintext, dataKey);

    // 3. 计算数据哈希（用于验证解密正确性）
    const dataHash = blake2AsU8a(new TextEncoder().encode(plaintext), 256);

    // 4. 为每个授权方加密数据密钥
    const encryptedKeys = [];

    // 4.1 所有者的加密密钥
    const ownerEncryptedKey = encryptKeyForRecipient(
        dataKey,
        signer.publicKey,
        signer.secretKey
    );

    encryptedKeys.push({
        account: signer.address,
        encrypted_key: Array.from(ownerEncryptedKey),
        role: { Owner: null },
        scope: { FullAccess: null },
        granted_at: 0,  // 链上会填充
        expires_at: 0,  // 永不过期
    });

    // 4.2 其他授权方的加密密钥
    for (const party of authorizedParties) {
        const encryptedKey = encryptKeyForRecipient(
            dataKey,
            party.publicKey,
            signer.secretKey
        );

        encryptedKeys.push({
            account: party.account,
            encrypted_key: Array.from(encryptedKey),
            role: { [party.role]: null },
            scope: { [party.scope]: null },
            granted_at: 0,
            expires_at: party.durationBlocks || 0,
        });
    }

    // 5. 提交交易
    return new Promise((resolve, reject) => {
        api.tx.baziChart.createEncryptedChartV2(
            sizhuIndex,
            gender,
            Array.from(ciphertext),
            Array.from(nonce),
            Array.from(tag),
            encryptedKeys,
            Array.from(dataHash)
        ).signAndSend(signer, ({ status, events }) => {
            if (status.isInBlock) {
                // 从事件中提取 chart_id
                const event = events.find(e =>
                    e.event.section === 'baziChart' &&
                    e.event.method === 'EncryptedChartV2Created'
                );
                if (event) {
                    const chartId = event.event.data[1].toNumber();
                    resolve(chartId);
                }
            }
        }).catch(reject);
    });
}
```

### 6.4 解密命盘数据

```typescript
// decrypt-chart.ts

import { ApiPromise } from '@polkadot/api';
import { blake2AsU8a } from '@polkadot/util-crypto';
import { decryptWithAES, decryptKeyFromSender } from './crypto-utils';
import { ensureSession, isSessionValid } from './session-key-manager';

/**
 * 解密命盘数据
 *
 * ⚠️ 会话密钥方案说明：
 * - 首次调用时会请求钱包签名（派生会话密钥）
 * - 会话期间（1小时）后续调用无需再次签名
 * - 解密使用账户私钥，与会话密钥独立
 *
 * @param api - Polkadot API 实例
 * @param wallet - 钱包实例（用于会话管理）
 * @param chartId - 命盘 ID
 * @param account - 当前账户（私钥用于解密）
 * @returns 解密后的敏感数据
 */
export async function decryptBaziChart(
    api: ApiPromise,
    wallet: Wallet,
    chartId: number,
    account: KeyringPair
): Promise<BirthData> {
    // 0. 确保有有效会话（首次会请求签名，后续复用）
    if (!isSessionValid()) {
        await ensureSession(wallet, account.address);
    }

    // 1. 从链上读取加密命盘
    const chartOpt = await api.query.baziChart.encryptedChartV2ById(chartId);
    if (chartOpt.isNone) {
        throw new Error('命盘不存在');
    }

    const chart = chartOpt.unwrap();

    // 2. 查找自己的加密密钥
    const myKeyEntry = chart.encrypted_keys.find(
        entry => entry.account.toString() === account.address
    );

    if (!myKeyEntry) {
        throw new Error('无权访问此命盘');
    }

    // 3. 检查授权是否过期
    if (myKeyEntry.expires_at.toNumber() > 0) {
        const currentBlock = (await api.query.system.number()).toNumber();
        if (currentBlock > myKeyEntry.expires_at.toNumber()) {
            throw new Error('授权已过期');
        }
    }

    // 4. 解密数据密钥
    const encryptedKey = new Uint8Array(myKeyEntry.encrypted_key.toU8a());
    const ownerPublicKey = new Uint8Array(chart.owner.toU8a());

    const dataKey = decryptKeyFromSender(
        encryptedKey,
        ownerPublicKey,
        account.secretKey
    );

    if (!dataKey) {
        throw new Error('密钥解密失败');
    }

    // 5. 解密数据
    const ciphertext = new Uint8Array(chart.encrypted_data.toU8a());
    const nonce = new Uint8Array(chart.nonce);
    const tag = new Uint8Array(chart.auth_tag);

    const decryptedText = await decryptWithAES(ciphertext, nonce, tag, dataKey);

    // 6. 验证数据哈希
    const dataHash = blake2AsU8a(new TextEncoder().encode(decryptedText), 256);
    const storedHash = new Uint8Array(chart.data_hash);

    if (!arraysEqual(dataHash, storedHash)) {
        throw new Error('数据完整性校验失败');
    }

    // 7. 解析并返回
    return JSON.parse(decryptedText);
}

/**
 * 检查是否有访问权限
 *
 * 此函数不需要会话，仅查询链上数据
 */
export async function checkChartAccess(
    api: ApiPromise,
    chartId: number,
    account: string
): Promise<{ hasAccess: boolean; role?: string; scope?: string; expiresAt?: number }> {
    const chartOpt = await api.query.baziChart.encryptedChartV2ById(chartId);
    if (chartOpt.isNone) {
        return { hasAccess: false };
    }

    const chart = chartOpt.unwrap();
    const keyEntry = chart.encrypted_keys.find(
        entry => entry.account.toString() === account
    );

    if (!keyEntry) {
        return { hasAccess: false };
    }

    // 检查过期
    if (keyEntry.expires_at.toNumber() > 0) {
        const currentBlock = (await api.query.system.number()).toNumber();
        if (currentBlock > keyEntry.expires_at.toNumber()) {
            return { hasAccess: false };
        }
    }

    return {
        hasAccess: true,
        role: Object.keys(keyEntry.role.toHuman())[0],
        scope: Object.keys(keyEntry.scope.toHuman())[0],
        expiresAt: keyEntry.expires_at.toNumber() || undefined,
    };
}
```

### 6.5 授权管理

```typescript
// grant-access.ts

import { ApiPromise } from '@polkadot/api';
import { encryptKeyForRecipient, decryptKeyFromSender } from './crypto-utils';
import { ensureSession, isSessionValid } from './session-key-manager';

/**
 * 授权新的命理师访问
 *
 * ⚠️ 会话密钥方案说明：
 * - 首次调用时会请求钱包签名（派生会话密钥）
 * - 会话期间（1小时）后续调用无需再次签名
 * - 授权操作需要用户私钥来解密 DataKey 并重新加密给被授权方
 */
export async function grantAccessToMaster(
    api: ApiPromise,
    wallet: Wallet,
    ownerAccount: KeyringPair,
    chartId: number,
    masterAccount: string,
    masterPublicKey: Uint8Array,
    scope: 'ReadOnly' | 'CanComment' | 'FullAccess',
    durationBlocks?: number
): Promise<void> {
    // 0. 确保有有效会话（首次会请求签名，后续复用）
    if (!isSessionValid()) {
        await ensureSession(wallet, ownerAccount.address);
    }

    // 1. 读取命盘
    const chartOpt = await api.query.baziChart.encryptedChartV2ById(chartId);
    if (chartOpt.isNone) {
        throw new Error('命盘不存在');
    }

    const chart = chartOpt.unwrap();

    // 2. 解密自己的数据密钥
    const dataKey = await decryptMyDataKey(chart, ownerAccount);

    // 3. 用命理师公钥加密数据密钥
    const encryptedKey = encryptKeyForRecipient(
        dataKey,
        masterPublicKey,
        ownerAccount.secretKey
    );

    // 4. 提交授权交易
    await api.tx.baziChart.grantChartAccess(
        chartId,
        masterAccount,
        Array.from(encryptedKey),
        { Master: null },
        { [scope]: null },
        durationBlocks || null
    ).signAndSend(ownerAccount);
}

/**
 * 解密自己的数据密钥（内部函数）
 */
async function decryptMyDataKey(
    chart: EncryptedBaziChartV2,
    account: KeyringPair
): Promise<Uint8Array> {
    // 查找自己的加密密钥
    const myKeyEntry = chart.encrypted_keys.find(
        entry => entry.account.toString() === account.address
    );

    if (!myKeyEntry) {
        throw new Error('无权访问此命盘');
    }

    // 解密数据密钥
    const encryptedKey = new Uint8Array(myKeyEntry.encrypted_key.toU8a());
    const ownerPublicKey = new Uint8Array(chart.owner.toU8a());

    const dataKey = decryptKeyFromSender(
        encryptedKey,
        ownerPublicKey,
        account.secretKey
    );

    if (!dataKey) {
        throw new Error('密钥解密失败');
    }

    return dataKey;
}

/**
 * 撤销授权
 *
 * 注意：撤销操作不需要会话密钥，因为不涉及加密操作
 */
export async function revokeAccess(
    api: ApiPromise,
    ownerAccount: KeyringPair,
    chartId: number,
    revokedAccount: string
): Promise<void> {
    await api.tx.baziChart.revokeChartAccess(
        chartId,
        revokedAccount
    ).signAndSend(ownerAccount);
}

/**
 * 批量撤销所有授权
 *
 * 注意：撤销操作不需要会话密钥，因为不涉及加密操作
 */
export async function revokeAllAccess(
    api: ApiPromise,
    ownerAccount: KeyringPair,
    chartId: number
): Promise<void> {
    await api.tx.baziChart.revokeAllAccess(chartId)
        .signAndSend(ownerAccount);
}
```

---

## 七、安全分析

### 7.1 威胁模型

| 威胁 | 风险等级 | 缓解措施 |
|------|----------|----------|
| **链上数据泄露** | 低 | 敏感数据 AES-256-GCM 加密，只有密钥持有者可解密 |
| **服务提供者滥用** | 中 | 时间限制授权 + 可撤销 + 链上审计日志 |
| **用户私钥泄露** | 高 | 建议使用硬件钱包；支持密钥轮换重新加密 |
| **重放攻击** | 低 | 每个授权有唯一 granted_at 时间戳 |
| **中间人攻击** | 低 | 公钥与链上账户绑定验证 |
| **撤销后访问** | 中 | 告知用户风险；建立信用体系 |

### 7.2 隐私保护层级

```
┌─────────────────────────────────────────────────────────────────┐
│  Layer 0: 区块链公开数据                                         │
│  - 账户地址、交易记录、授权操作                                    │
├─────────────────────────────────────────────────────────────────┤
│  Layer 1: 四柱索引（公开）                                        │
│  - 可用于免费解盘计算                                             │
│  - 无法反推出生时间                                               │
│  - 8 bytes，信息有限                                             │
├─────────────────────────────────────────────────────────────────┤
│  Layer 2: 加密敏感数据（仅授权方可见）                              │
│  - 出生时间、地点、备注等                                          │
│  - 需要有效授权 + 私钥才能解密                                      │
├─────────────────────────────────────────────────────────────────┤
│  Layer 3: 数据密钥（短暂存在）                                     │
│  - 随机生成，加密后分发                                            │
│  - 明文仅在前端内存中短暂存在                                       │
├─────────────────────────────────────────────────────────────────┤
│  Layer 4: 用户主密钥（仅用户持有）                                  │
│  - 由钱包签名派生                                                  │
│  - 永不上链、永不暴露                                              │
└─────────────────────────────────────────────────────────────────┘
```

### 7.3 授权撤销后的安全性

```
撤销授权后：
┌──────────────────────────────────────────────────────────────────┐
│  1. 链上标记立即移除 encrypted_key                                │
│  2. 被撤销方无法再从链上读取自己的加密密钥                          │
│  3. 即使之前保存了 encrypted_key，也无法继续解密                    │
│     - 因为需要 owner 的公钥来完成密钥交换                          │
│  4. 但如果之前已解密并保存了明文数据，链上无法阻止                   │
│                                                                    │
│  ⚠️ 缓解措施：                                                     │
│  - 授权时明确告知用户此风险                                         │
│  - 只授权给信任的命理师                                             │
│  - 平台建立命理师信用体系                                           │
│  - 设置合理的授权时限（如 7 天）                                    │
└──────────────────────────────────────────────────────────────────┘
```

---

## 八、成本分析

### 8.1 存储成本

| 数据项 | 大小（bytes） | 说明 |
|--------|--------------|------|
| EncryptedBaziChartV2 基础 | ~400 | 不含授权 |
| 每个 EncryptedKeyEntry | ~100 | 含加密密钥和元数据 |
| 最大存储（10个授权） | ~1400 | 基础 + 10×100 |
| ServiceProvider | ~80 | 提供者注册信息 |

### 8.2 Gas 费用估算

| 操作 | 估算费用 | 说明 |
|------|----------|------|
| 创建命盘（无授权） | ~0.01 DUST | 基础费用 |
| 创建命盘（3个授权） | ~0.015 DUST | 含密钥存储 |
| 创建命盘（10个授权） | ~0.025 DUST | 最大授权 |
| 授权新用户 | ~0.005 DUST | 添加单个密钥 |
| 撤销授权 | ~0.003 DUST | 移除单个密钥 |
| 批量撤销 | ~0.008 DUST | 移除所有非 Owner |
| 注册服务提供者 | ~0.005 DUST | 一次性 |

### 8.3 性能评估

| 操作 | 前端耗时 | 说明 |
|------|----------|------|
| 派生主密钥 | ~100ms | 钱包签名 |
| 生成数据密钥 | <1ms | 随机生成 |
| AES 加密 | ~10ms | 256 bytes 数据 |
| 密钥加密（每个） | ~5ms | NaCl box |
| 密钥解密 | ~5ms | NaCl unbox |
| AES 解密 | ~10ms | 256 bytes 数据 |

---

## 九、事件定义

```rust
#[pallet::event]
#[pallet::generate_deposit(pub(super) fn deposit_event)]
pub enum Event<T: Config> {
    /// 服务提供者注册
    ProviderRegistered {
        account: T::AccountId,
        provider_type: ServiceProviderType,
    },

    /// 服务提供者注销
    ProviderDeregistered {
        account: T::AccountId,
    },

    /// 加密命盘 V2 创建
    EncryptedChartV2Created {
        owner: T::AccountId,
        chart_id: u64,
        initial_grants: u8,
    },

    /// 命盘访问授权
    ChartAccessGranted {
        chart_id: u64,
        owner: T::AccountId,
        grantee: T::AccountId,
        role: AccessRole,
        scope: AccessScope,
        expires_at: u32,
    },

    /// 命盘访问撤销
    ChartAccessRevoked {
        chart_id: u64,
        owner: T::AccountId,
        revokee: T::AccountId,
    },

    /// 批量撤销所有访问
    AllAccessRevoked {
        chart_id: u64,
        owner: T::AccountId,
        count: u8,
    },

    /// 授权续期
    ChartAccessExtended {
        chart_id: u64,
        grantee: T::AccountId,
        new_expires_at: u32,
    },
}
```

---

## 十、错误定义

```rust
#[pallet::error]
pub enum Error<T> {
    // === 服务提供者错误 ===
    /// 提供者已注册
    ProviderAlreadyRegistered,
    /// 提供者未注册
    ProviderNotRegistered,
    /// 无效的公钥
    InvalidPublicKey,

    // === 命盘错误 ===
    /// 命盘不存在
    ChartNotFound,
    /// 非命盘所有者
    NotOwner,
    /// 命盘数量超限
    TooManyCharts,
    /// 命盘 ID 溢出
    ChartIdOverflow,
    /// 无效的四柱索引
    InvalidSiZhuIndex,

    // === 授权错误 ===
    /// 缺少所有者密钥
    MissingOwnerKey,
    /// 授权数量超限
    TooManyAuthorizations,
    /// 不能授权给自己
    CannotGrantToSelf,
    /// 已经授权过
    AlreadyGranted,
    /// 授权不存在
    GrantNotFound,
    /// 不能撤销所有者权限
    CannotRevokeOwner,
    /// 授权已过期
    AuthorizationExpired,

    // === 加密错误 ===
    /// 加密数据过长
    EncryptedDataTooLong,
    /// 加密密钥无效
    InvalidEncryptedKey,
    /// 数据哈希不匹配
    DataHashMismatch,
}
```

---

## 十一、实施路线图

### Phase 1：核心功能（预计 1.5 周）

- [ ] 新增数据结构（`EncryptedBaziChartV2`、`EncryptedKeyEntry`、`AccessRole`、`AccessScope`）
- [ ] 实现 `create_encrypted_chart_v2` 接口
- [ ] 实现 `grant_chart_access` 接口
- [ ] 实现 `revoke_chart_access` 和 `revoke_all_access` 接口
- [ ] 编写单元测试

### Phase 2：服务提供者系统（预计 1 周）

- [ ] 实现服务提供者注册/注销
- [ ] 实现公钥管理
- [ ] 实现提供者授权索引（`ProviderGrants`）
- [ ] 编写集成测试

### Phase 3：前端集成（预计 2 周）

- [ ] 实现加密工具库（TypeScript）
- [ ] 实现创建加密命盘 UI
- [ ] 实现授权管理界面
- [ ] 实现解密查看功能
- [ ] 命理师选择器组件

### Phase 4：Runtime API（预计 0.5 周）

- [ ] `get_encrypted_chart_v2` - 获取加密命盘（不含敏感数据）
- [ ] `get_chart_access_list` - 获取命盘授权列表
- [ ] `get_provider_charts` - 获取提供者可访问的命盘
- [ ] `check_access` - 检查访问权限

### Phase 5：安全审计与优化（预计 1 周）

- [ ] 密码学实现审计
- [ ] 边界条件测试
- [ ] 性能优化
- [ ] 文档完善

---

## 十二、附录

### A. 密码学库选择

| 功能 | Rust（链上） | TypeScript（前端） |
|------|-------------|-------------------|
| 哈希 | `sp_core::hashing::blake2_256` | `@polkadot/util-crypto: blake2AsU8a` |
| 对称加密 | N/A（前端执行） | `Web Crypto API: AES-GCM` |
| 非对称加密 | N/A（前端执行） | `@polkadot/util-crypto: naclEncrypt/naclDecrypt` |
| 密钥交换 | N/A（前端执行） | `@noble/curves: x25519` |

### B. 与现有系统的兼容性

```rust
// 查询接口自动处理版本
impl<T: Config> Pallet<T> {
    /// 获取加密命盘（统一接口，返回最新版本）
    pub fn get_encrypted_chart(chart_id: u64) -> Option<EncryptedChartInfo> {
        // 先查 V2
        if let Some(chart_v2) = EncryptedChartV2ById::<T>::get(chart_id) {
            return Some(EncryptedChartInfo::from_v2(chart_v2));
        }

        // 再查 V1
        if let Some(chart_v1) = EncryptedChartById::<T>::get(chart_id) {
            return Some(EncryptedChartInfo::from_v1(chart_v1));
        }

        None
    }
}
```

### C. 迁移策略

V1 命盘可继续使用，用户可选择：
1. **保持 V1**：单密钥模式，不需要授权功能
2. **升级到 V2**：创建新的 V2 命盘，删除旧 V1 命盘

```rust
/// 从 V1 升级到 V2（需要前端配合）
///
/// 流程：
/// 1. 前端解密 V1 命盘获取明文数据
/// 2. 使用明文数据调用 create_encrypted_chart_v2
/// 3. 成功后删除 V1 命盘
#[pallet::call_index(30)]
pub fn migrate_v1_to_v2(
    origin: OriginFor<T>,
    old_chart_id: u64,
    // V2 创建参数...
) -> DispatchResult;
```

---

## 十三、总结

本设计融合了两个方案的优势：

| 特性 | 来源 | 说明 |
|------|------|------|
| 三层密钥架构 | 多服务提供者设计 | 安全性更高 |
| 多密钥分发 | 多密钥解密分析 | 实现更简洁 |
| 服务提供者系统 | 多服务提供者设计 | 便于管理 |
| 访问范围控制 | 多服务提供者设计 | 细粒度权限 |
| 时间限制授权 | 两者结合 | 自动过期 |
| 批量撤销 | 新增 | 紧急情况使用 |
| 向后兼容 | 多密钥解密分析 | 平滑迁移 |
| 前端代码示例 | 两者结合 | 完整实现 |
| 成本分析 | 两者结合 | 量化评估 |
| 安全分析 | 多服务提供者设计 | 威胁模型 |

**合理性评分：⭐⭐⭐⭐⭐ (5/5)**
**可行性评分：⭐⭐⭐⭐⭐ (5/5)**

强烈建议实施！
