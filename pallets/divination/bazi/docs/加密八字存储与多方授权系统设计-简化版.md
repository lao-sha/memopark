# 加密八字存储与多方授权系统设计 - 简化版

## 一、概述

### 1.1 设计目标

本设计实现八字命盘的加密存储与多方授权访问系统，**追求简洁实用**：

1. **隐私保护**：用户敏感数据（出生时间等）加密存储在链上
2. **多方解密**：用户可授权命理师、AI服务、家族成员等解密访问
3. **细粒度控制**：支持时间限制、访问范围控制、随时撤销
4. **免费计算**：四柱索引明文存储，Runtime API 可免费计算解盘
5. **可审计**：所有授权操作上链记录，完全透明

### 1.2 典型场景

```
用户张三创建加密命盘（出生时间加密）
    ↓
授权给命理师 A（7天有效期，只读权限）
授权给 AI 服务（永久，只读权限）
授权给家人（永久，可评论权限）
    ↓
命理师/AI/家人 各自用私钥解密查看
    ↓
7天后命理师授权自动失效
用户主动撤销 AI 服务授权
    ↓
只有家人仍可访问
```

---

## 二、密钥架构（简化版）

### 2.1 两层密钥体系

```
┌─────────────────────────────────────────────────────────────────┐
│               签名密钥对（Signing KeyPair）                        │
│           Polkadot 标准 SR25519/ED25519 密钥对                    │
│           用户钱包管理，仅用于签名交易                              │
│           永不上链（只有地址上链）                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│               加密密钥对（Encryption KeyPair）                     │
│           X25519 密钥对，专用于加密/解密                           │
│           从签名密钥派生，或独立生成后注册到链上                     │
│           公钥上链存储，私钥用户本地保管                            │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼ (加密/解密 DataKey)
┌─────────────────────────────────────────────────────────────────┐
│                    数据密钥（DataKey）                            │
│           随机生成（32 bytes），用于 AES-256-GCM 加密敏感数据      │
│           每个命盘独立生成，单个泄露不影响其他命盘                  │
│           用授权方的 X25519 公钥加密后存储在链上                   │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼ (加密敏感数据)
┌─────────────────────────────────────────────────────────────────┐
│                    加密的敏感数据                                 │
│           出生时间、经度、备注等敏感信息                           │
│           使用 AES-256-GCM 加密，存储在链上                       │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 密钥类型说明

| 密钥类型 | 算法 | 用途 | 存储位置 |
|----------|------|------|----------|
| **签名密钥** | SR25519/ED25519 | 交易签名、身份认证 | 钱包管理 |
| **加密密钥** | X25519 | DataKey 加密/解密 | 公钥上链，私钥本地 |
| **数据密钥** | AES-256 | 敏感数据加密/解密 | 加密后上链 |

### 2.3 加密密钥派生方案

**方案 A：从签名密钥派生（推荐）**

```typescript
// ED25519 签名密钥可以转换为 X25519 加密密钥
// 因为 ED25519 和 X25519 都基于 Curve25519

import { convertSecretKeyToX25519 } from '@polkadot/util-crypto';

// ED25519 私钥 (64 bytes) → X25519 私钥 (32 bytes)
const x25519SecretKey = convertSecretKeyToX25519(ed25519SecretKey);

// ED25519 公钥 (32 bytes) → X25519 公钥 (32 bytes)
const x25519PublicKey = convertPublicKeyToX25519(ed25519PublicKey);
```

**方案 B：独立生成（适用于 SR25519 账户）**

```typescript
// SR25519 无法直接转换，需要独立生成 X25519 密钥对
import { naclBoxPairFromSecret } from '@polkadot/util-crypto';

// 从随机种子或确定性派生生成
const { publicKey, secretKey } = naclBoxPairFromSecret(seed);

// 公钥需要注册到链上
await api.tx.baziChart.registerEncryptionKey(publicKey).signAndSend(signer);
```

### 2.5 密钥操作流程

```
┌────────────────────────────────────────────────────────────────────┐
│                        加密命盘创建流程                              │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  1. 用户创建命盘                                                    │
│     ├─ 生成随机 DataKey (32 bytes)                                │
│     ├─ 用 DataKey 加密敏感数据（AES-256-GCM）                      │
│     ├─ 用自己的公钥加密 DataKey（X25519 + ChaCha20-Poly1305）     │
│     └─ 提交交易到链上                                              │
│                                                                    │
│  2. 授权命理师访问                                                  │
│     ├─ 从链上读取自己的加密 DataKey                                │
│     ├─ 用自己的私钥解密 DataKey                                    │
│     ├─ 用命理师的公钥重新加密 DataKey                              │
│     └─ 提交授权交易到链上                                          │
│                                                                    │
│  3. 命理师查看命盘                                                  │
│     ├─ 从链上读取自己的加密 DataKey                                │
│     ├─ 用自己的私钥解密 DataKey                                    │
│     ├─ 用 DataKey 解密敏感数据                                     │
│     └─ 查看命盘详情                                                │
│                                                                    │
│  4. 撤销授权                                                        │
│     └─ 从链上删除命理师的加密 DataKey 条目                          │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

### 2.4 密钥算法选择

| 功能 | 算法 | 说明 |
|------|------|------|
| **对称加密** | AES-256-GCM | Web Crypto API 原生支持，性能好 |
| **非对称加密** | X25519 + ChaCha20-Poly1305 | Polkadot 生态标准（NaCl box） |
| **哈希** | Blake2-256 | Substrate 原生，用于数据完整性校验 |
| **账户签名** | SR25519/ED25519 | Polkadot 标准，钱包原生支持 |

---

## 三、数据结构设计

### 3.1 用户加密公钥注册

```rust
/// 用户加密公钥存储
///
/// 每个用户需要注册一个 X25519 公钥用于接收加密的 DataKey
/// 此公钥与签名密钥分离，专门用于加密操作
#[pallet::storage]
#[pallet::getter(fn user_encryption_keys)]
pub type UserEncryptionKeys<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::AccountId,
    [u8; 32],  // X25519 公钥
>;
```

### 3.2 服务提供者注册

```rust
/// 服务提供者类型
#[derive(Clone, Copy, Debug, PartialEq, Eq, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub enum ServiceProviderType {
    /// 命理师（人工解读）
    MingLiShi = 0,
    /// AI 解读服务
    AiService = 1,
    /// 家族成员
    FamilyMember = 2,
    /// 研究机构
    Research = 3,
}

/// 服务提供者信息
#[derive(Clone, Debug, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub struct ServiceProvider<T: Config> {
    /// 提供者账户
    pub account: T::AccountId,
    /// 服务类型
    pub provider_type: ServiceProviderType,
    /// X25519 公钥（32 bytes，用于密钥加密）
    pub public_key: [u8; 32],
    /// 信誉分（0-100，用于筛选）
    pub reputation: u8,
    /// 注册时间（区块号）
    pub registered_at: u32,
    /// 是否激活
    pub is_active: bool,
}
```

### 3.2 访问授权记录

```rust
/// 授权角色类型
#[derive(Clone, Copy, Debug, PartialEq, Eq, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub enum AccessRole {
    /// 所有者（不可撤销）
    Owner = 0,
    /// 命理师（可撤销）
    Master = 1,
    /// 家族成员（可撤销）
    Family = 2,
    /// AI 服务（可撤销）
    AiService = 3,
}

/// 访问范围
#[derive(Clone, Copy, Debug, PartialEq, Eq, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub enum AccessScope {
    /// 只读（查看命盘）
    ReadOnly = 0,
    /// 可评论/解读
    CanComment = 1,
    /// 完全访问（含元数据）
    FullAccess = 2,
}

/// 加密密钥条目（链上存储）
#[derive(Clone, Debug, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub struct EncryptedKeyEntry<AccountId> {
    /// 授权账户
    pub account: AccountId,
    /// 用该账户公钥加密的 DataKey（48 bytes）
    /// 格式：nonce(24) + ciphertext(16) + tag(16)（NaCl box 格式）
    pub encrypted_key: BoundedVec<u8, ConstU32<64>>,
    /// 授权角色
    pub role: AccessRole,
    /// 访问范围
    pub scope: AccessScope,
    /// 授权开始时间（区块号）
    pub granted_at: u32,
    /// 授权结束时间（区块号，0 = 永久）
    pub expires_at: u32,
}
```

### 3.3 加密命盘结构

```rust
/// 加密八字命盘（支持多方授权）
///
/// # 存储结构（约 400-1400 bytes）
/// - sizhu_index: 8 bytes（四柱索引，明文）
/// - gender: 1 byte（性别，明文）
/// - encrypted_data: 64-256 bytes（加密的敏感数据）
/// - encrypted_keys: 每个授权约 100 bytes，最多 10 个
/// - 元数据: 约 50 bytes
#[derive(Clone, Debug, Encode, Decode, TypeInfo, MaxEncodedLen)]
#[scale_info(skip_type_params(T))]
pub struct EncryptedBaziChart<T: Config> {
    // === 基础信息（明文） ===
    /// 所有者账户
    pub owner: T::AccountId,
    /// 四柱干支索引（用于免费计算解盘）
    pub sizhu_index: SiZhuIndex,
    /// 性别（用于大运计算）
    pub gender: Gender,

    // === 加密数据 ===
    /// AES-256-GCM 加密的敏感数据
    /// 内容：出生时间、子时模式、经度、备注等
    pub encrypted_data: BoundedVec<u8, ConstU32<256>>,
    /// 加密使用的 nonce（12 bytes）
    pub nonce: [u8; 12],
    /// 认证标签（16 bytes）
    pub auth_tag: [u8; 16],

    // === 密钥分发 ===
    /// 多个加密的 DataKey（最多 10 个授权）
    pub encrypted_keys: BoundedVec<EncryptedKeyEntry<T::AccountId>, ConstU32<10>>,

    // === 验证与元数据 ===
    /// 原始数据哈希（用于验证解密正确性）
    pub data_hash: [u8; 32],
    /// 创建时间（区块号）
    pub created_at: u32,
}
```

### 3.4 敏感数据结构（加密前）

```rust
/// 敏感数据（前端加密/解密）
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SensitiveData {
    /// 出生年份
    pub birth_year: u16,
    /// 出生月份
    pub birth_month: u8,
    /// 出生日期
    pub birth_day: u8,
    /// 出生小时
    pub birth_hour: u8,
    /// 出生分钟
    pub birth_minute: u8,
    /// 子时模式
    pub zishi_mode: u8,
    /// 出生地经度（可选）
    pub longitude: Option<i32>,
    /// 输入日历类型（0=公历, 1=农历）
    pub input_calendar_type: u8,
    /// 命盘名称（可选）
    pub name: Option<String>,
    /// 备注（可选）
    pub notes: Option<String>,
}
```

---

## 四、存储设计

### 4.1 存储映射

```rust
/// 服务提供者注册表
#[pallet::storage]
#[pallet::getter(fn providers)]
pub type Providers<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::AccountId,
    ServiceProvider<T>,
>;

/// 加密命盘存储
#[pallet::storage]
#[pallet::getter(fn encrypted_chart_by_id)]
pub type EncryptedChartById<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    u64,  // chart_id
    EncryptedBaziChart<T>,
>;

/// 用户的加密命盘列表
#[pallet::storage]
#[pallet::getter(fn user_encrypted_charts)]
pub type UserEncryptedCharts<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::AccountId,
    BoundedVec<u64, T::MaxChartsPerAccount>,
    ValueQuery,
>;

/// 提供者收到的授权（快速查询）
#[pallet::storage]
#[pallet::getter(fn provider_grants)]
pub type ProviderGrants<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::AccountId,  // provider
    BoundedVec<u64, ConstU32<1000>>,  // chart_ids
    ValueQuery,
>;

/// 下一个命盘 ID
#[pallet::storage]
pub type NextChartId<T: Config> = StorageValue<_, u64, ValueQuery>;
```

---

## 五、交易接口设计

### 5.1 服务提供者管理

```rust
/// 注册成为服务提供者
///
/// # 参数
/// - provider_type: 服务类型
/// - public_key: X25519 公钥（用于接收加密的 DataKey）
///
/// # 注意
/// - 公钥必须是有效的 X25519 公钥（32 bytes）
/// - 初始信誉分为 50
#[pallet::call_index(10)]
#[pallet::weight(T::WeightInfo::register_provider())]
pub fn register_provider(
    origin: OriginFor<T>,
    provider_type: ServiceProviderType,
    public_key: [u8; 32],
) -> DispatchResult {
    let who = ensure_signed(origin)?;

    // 检查未重复注册
    ensure!(
        !Providers::<T>::contains_key(&who),
        Error::<T>::ProviderAlreadyRegistered
    );

    let current_block = <frame_system::Pallet<T>>::block_number().saturated_into();

    let provider = ServiceProvider {
        account: who.clone(),
        provider_type,
        public_key,
        reputation: 50,
        registered_at: current_block,
        is_active: true,
    };

    Providers::<T>::insert(&who, provider);

    Self::deposit_event(Event::ProviderRegistered {
        account: who,
        provider_type,
    });

    Ok(())
}

/// 更新服务提供者公钥
#[pallet::call_index(11)]
#[pallet::weight(T::WeightInfo::update_provider_key())]
pub fn update_provider_key(
    origin: OriginFor<T>,
    new_public_key: [u8; 32],
) -> DispatchResult {
    let who = ensure_signed(origin)?;

    Providers::<T>::try_mutate(&who, |provider| {
        let p = provider.as_mut().ok_or(Error::<T>::ProviderNotRegistered)?;
        p.public_key = new_public_key;
        Ok(())
    })?;

    Self::deposit_event(Event::ProviderKeyUpdated {
        account: who,
    });

    Ok(())
}

/// 注销服务提供者
#[pallet::call_index(12)]
#[pallet::weight(T::WeightInfo::deregister_provider())]
pub fn deregister_provider(
    origin: OriginFor<T>,
) -> DispatchResult {
    let who = ensure_signed(origin)?;

    Providers::<T>::take(&who)
        .ok_or(Error::<T>::ProviderNotRegistered)?;

    Self::deposit_event(Event::ProviderDeregistered {
        account: who,
    });

    Ok(())
}
```

### 5.2 加密命盘管理

```rust
/// 创建支持多方授权的加密命盘
///
/// # 参数
/// - sizhu_index: 四柱干支索引（明文）
/// - gender: 性别（明文）
/// - encrypted_data: AES-256-GCM 加密的敏感数据
/// - nonce: 加密 nonce（12 bytes）
/// - auth_tag: 认证标签（16 bytes）
/// - encrypted_keys: 多个加密的 DataKey（含所有者 + 初始授权方）
/// - data_hash: 原始数据哈希
///
/// # 验证
/// - encrypted_keys 必须包含一个 Owner 角色且账户等于调用者
/// - encrypted_keys 长度 ≤ 10
#[pallet::call_index(20)]
#[pallet::weight(T::WeightInfo::create_encrypted_chart())]
pub fn create_encrypted_chart(
    origin: OriginFor<T>,
    sizhu_index: SiZhuIndex,
    gender: Gender,
    encrypted_data: BoundedVec<u8, ConstU32<256>>,
    nonce: [u8; 12],
    auth_tag: [u8; 16],
    encrypted_keys: BoundedVec<EncryptedKeyEntry<T::AccountId>, ConstU32<10>>,
    data_hash: [u8; 32],
) -> DispatchResult {
    let who = ensure_signed(origin)?;

    // 验证四柱索引有效性
    ensure!(sizhu_index.is_valid(), Error::<T>::InvalidSiZhuIndex);

    // 验证必须有 Owner 密钥且账户匹配
    let has_owner = encrypted_keys.iter().any(|k|
        k.account == who && k.role == AccessRole::Owner
    );
    ensure!(has_owner, Error::<T>::MissingOwnerKey);

    // 检查账户命盘数量限制
    let existing = UserEncryptedCharts::<T>::get(&who);
    ensure!(
        existing.len() < T::MaxChartsPerAccount::get() as usize,
        Error::<T>::TooManyCharts
    );

    // 获取新 ID
    let chart_id = NextChartId::<T>::get();
    ensure!(chart_id < u64::MAX, Error::<T>::ChartIdOverflow);

    let current_block = <frame_system::Pallet<T>>::block_number().saturated_into();

    // 构建命盘
    let chart = EncryptedBaziChart {
        owner: who.clone(),
        sizhu_index,
        gender,
        encrypted_data,
        nonce,
        auth_tag,
        encrypted_keys: encrypted_keys.clone(),
        data_hash,
        created_at: current_block,
    };

    // 存储
    EncryptedChartById::<T>::insert(chart_id, chart);

    UserEncryptedCharts::<T>::try_mutate(&who, |charts| {
        charts.try_push(chart_id).map_err(|_| Error::<T>::TooManyCharts)
    })?;

    // 更新提供者授权索引
    for key_entry in encrypted_keys.iter() {
        if key_entry.role != AccessRole::Owner {
            ProviderGrants::<T>::try_mutate(&key_entry.account, |grants| {
                grants.try_push(chart_id).ok();
                Ok::<(), ()>(())
            }).ok();
        }
    }

    NextChartId::<T>::put(chart_id + 1);

    Self::deposit_event(Event::EncryptedChartCreated {
        owner: who,
        chart_id,
        initial_grants: encrypted_keys.len() as u8 - 1,
    });

    Ok(())
}
```

### 5.3 授权管理

```rust
/// 授权新账户访问命盘
///
/// # 参数
/// - chart_id: 命盘 ID
/// - grantee: 被授权账户
/// - encrypted_key: 用被授权方公钥加密的 DataKey
/// - role: 授权角色
/// - scope: 访问范围
/// - duration_blocks: 有效期（区块数，None = 永久）
///
/// # 权限
/// - 只有所有者可以授权
/// - 不能超过 10 个授权
/// - 不能授权自己（已经是 Owner）
#[pallet::call_index(21)]
#[pallet::weight(T::WeightInfo::grant_chart_access())]
pub fn grant_chart_access(
    origin: OriginFor<T>,
    chart_id: u64,
    grantee: T::AccountId,
    encrypted_key: BoundedVec<u8, ConstU32<64>>,
    role: AccessRole,
    scope: AccessScope,
    duration_blocks: Option<u32>,
) -> DispatchResult {
    let who = ensure_signed(origin)?;

    // 获取命盘并验证所有权
    let mut chart = EncryptedChartById::<T>::get(chart_id)
        .ok_or(Error::<T>::ChartNotFound)?;
    ensure!(chart.owner == who, Error::<T>::NotOwner);

    // 不能授权给自己
    ensure!(grantee != who, Error::<T>::CannotGrantToSelf);

    // 检查是否已授权
    let already_granted = chart.encrypted_keys.iter()
        .any(|k| k.account == grantee);
    ensure!(!already_granted, Error::<T>::AlreadyGranted);

    // 检查授权数量限制
    ensure!(
        chart.encrypted_keys.len() < 10,
        Error::<T>::TooManyAuthorizations
    );

    // 验证被授权方是注册的服务提供者（可选）
    if role == AccessRole::Master || role == AccessRole::AiService {
        ensure!(
            Providers::<T>::contains_key(&grantee),
            Error::<T>::ProviderNotRegistered
        );
    }

    let current_block = <frame_system::Pallet<T>>::block_number().saturated_into();
    let expires_at = duration_blocks.map(|d| current_block + d).unwrap_or(0);

    // 添加新授权
    let entry = EncryptedKeyEntry {
        account: grantee.clone(),
        encrypted_key,
        role,
        scope,
        granted_at: current_block,
        expires_at,
    };

    chart.encrypted_keys.try_push(entry)
        .map_err(|_| Error::<T>::TooManyAuthorizations)?;

    EncryptedChartById::<T>::insert(chart_id, chart);

    // 更新提供者索引
    ProviderGrants::<T>::try_mutate(&grantee, |grants| {
        grants.try_push(chart_id).ok();
        Ok::<(), ()>(())
    }).ok();

    Self::deposit_event(Event::ChartAccessGranted {
        chart_id,
        owner: who,
        grantee,
        role,
        scope,
        expires_at,
    });

    Ok(())
}

/// 撤销账户访问权限
#[pallet::call_index(22)]
#[pallet::weight(T::WeightInfo::revoke_chart_access())]
pub fn revoke_chart_access(
    origin: OriginFor<T>,
    chart_id: u64,
    revokee: T::AccountId,
) -> DispatchResult {
    let who = ensure_signed(origin)?;

    let mut chart = EncryptedChartById::<T>::get(chart_id)
        .ok_or(Error::<T>::ChartNotFound)?;
    ensure!(chart.owner == who, Error::<T>::NotOwner);

    // 不能撤销所有者
    ensure!(revokee != who, Error::<T>::CannotRevokeOwner);

    // 检查是否存在该授权
    let existed = chart.encrypted_keys.iter()
        .any(|k| k.account == revokee);
    ensure!(existed, Error::<T>::GrantNotFound);

    // 移除授权
    chart.encrypted_keys.retain(|k| k.account != revokee);

    EncryptedChartById::<T>::insert(chart_id, chart);

    // 更新提供者索引
    ProviderGrants::<T>::try_mutate(&revokee, |grants| {
        grants.retain(|&id| id != chart_id);
        Ok::<(), ()>(())
    }).ok();

    Self::deposit_event(Event::ChartAccessRevoked {
        chart_id,
        owner: who,
        revokee,
    });

    Ok(())
}

/// 批量撤销所有授权（紧急情况）
#[pallet::call_index(23)]
#[pallet::weight(T::WeightInfo::revoke_all_access())]
pub fn revoke_all_access(
    origin: OriginFor<T>,
    chart_id: u64,
) -> DispatchResult {
    let who = ensure_signed(origin)?;

    let mut chart = EncryptedChartById::<T>::get(chart_id)
        .ok_or(Error::<T>::ChartNotFound)?;
    ensure!(chart.owner == who, Error::<T>::NotOwner);

    // 收集要撤销的账户（用于更新索引）
    let revoked_accounts: Vec<T::AccountId> = chart.encrypted_keys.iter()
        .filter(|k| k.role != AccessRole::Owner)
        .map(|k| k.account.clone())
        .collect();

    // 只保留 Owner
    chart.encrypted_keys.retain(|k| k.role == AccessRole::Owner);

    EncryptedChartById::<T>::insert(chart_id, chart);

    // 更新所有提供者索引
    for account in revoked_accounts.iter() {
        ProviderGrants::<T>::try_mutate(account, |grants| {
            grants.retain(|&id| id != chart_id);
            Ok::<(), ()>(())
        }).ok();
    }

    Self::deposit_event(Event::AllAccessRevoked {
        chart_id,
        owner: who,
        count: revoked_accounts.len() as u8,
    });

    Ok(())
}
```

---

## 六、前端加密流程（简化版）

### 6.1 加密工具函数

```typescript
// crypto-utils.ts

import {
    blake2AsU8a,
    naclSeal,
    naclOpen,
    ed25519PairFromSeed,
    naclBoxPairFromSecret,
} from '@polkadot/util-crypto';
import { hexToU8a, u8aToHex } from '@polkadot/util';

/**
 * 从 ED25519 密钥对派生 X25519 密钥对
 *
 * 注意：SR25519 不能直接转换，需要使用独立的 X25519 密钥对
 */
export function deriveX25519FromEd25519(ed25519Seed: Uint8Array): {
    publicKey: Uint8Array;
    secretKey: Uint8Array;
} {
    // ED25519 seed → X25519 keypair
    // 使用相同的种子派生，保证确定性
    return naclBoxPairFromSecret(ed25519Seed.slice(0, 32));
}

/**
 * 生成独立的 X25519 密钥对（适用于 SR25519 账户）
 */
export function generateX25519KeyPair(): {
    publicKey: Uint8Array;
    secretKey: Uint8Array;
} {
    const seed = crypto.getRandomValues(new Uint8Array(32));
    return naclBoxPairFromSecret(seed);
}

/**
 * 生成随机数据密钥
 *
 * @returns 32 字节随机密钥
 */
export function generateDataKey(): Uint8Array {
    return crypto.getRandomValues(new Uint8Array(32));
}

/**
 * 使用 AES-256-GCM 加密数据
 */
export async function encryptWithAES(
    plaintext: string,
    key: Uint8Array
): Promise<{ ciphertext: Uint8Array; nonce: Uint8Array; tag: Uint8Array }> {
    const nonce = crypto.getRandomValues(new Uint8Array(12));
    const encoder = new TextEncoder();
    const data = encoder.encode(plaintext);

    const cryptoKey = await crypto.subtle.importKey(
        'raw',
        key,
        { name: 'AES-GCM' },
        false,
        ['encrypt']
    );

    const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv: nonce },
        cryptoKey,
        data
    );

    // 分离 ciphertext 和 auth tag
    const encryptedArray = new Uint8Array(encrypted);
    const ciphertext = encryptedArray.slice(0, -16);
    const tag = encryptedArray.slice(-16);

    return { ciphertext, nonce, tag };
}

/**
 * 使用 AES-256-GCM 解密数据
 */
export async function decryptWithAES(
    ciphertext: Uint8Array,
    nonce: Uint8Array,
    tag: Uint8Array,
    key: Uint8Array
): Promise<string> {
    const cryptoKey = await crypto.subtle.importKey(
        'raw',
        key,
        { name: 'AES-GCM' },
        false,
        ['decrypt']
    );

    // 合并 ciphertext 和 tag
    const combined = new Uint8Array(ciphertext.length + tag.length);
    combined.set(ciphertext);
    combined.set(tag, ciphertext.length);

    const decrypted = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv: nonce },
        cryptoKey,
        combined
    );

    return new TextDecoder().decode(decrypted);
}

/**
 * 使用 X25519 公钥加密数据密钥（NaCl sealed box）
 *
 * 使用 naclSeal：发送方用自己的私钥 + 接收方的公钥加密
 *
 * @param dataKey - 要加密的数据密钥
 * @param recipientPublicKey - 接收方的 X25519 公钥
 * @param senderSecretKey - 发送方的 X25519 私钥
 * @returns 加密后的密钥（nonce + 密文 + tag）
 */
export function encryptKeyForRecipient(
    dataKey: Uint8Array,
    recipientPublicKey: Uint8Array,
    senderSecretKey: Uint8Array
): Uint8Array {
    // naclSeal 返回 { sealed: Uint8Array, nonce: Uint8Array }
    const { sealed, nonce } = naclSeal(
        dataKey,
        recipientPublicKey,
        senderSecretKey
    );

    // 返回 nonce(24) + sealed(48 = 32 + 16 MAC)
    const result = new Uint8Array(nonce.length + sealed.length);
    result.set(nonce);
    result.set(sealed, nonce.length);
    return result;
}

/**
 * 使用 X25519 私钥解密数据密钥
 *
 * @param encryptedKey - 加密的密钥（nonce + 密文 + tag）
 * @param senderPublicKey - 发送方的 X25519 公钥
 * @param recipientSecretKey - 接收方的 X25519 私钥
 * @returns 解密后的数据密钥，失败返回 null
 */
export function decryptKeyFromSender(
    encryptedKey: Uint8Array,
    senderPublicKey: Uint8Array,
    recipientSecretKey: Uint8Array
): Uint8Array | null {
    const nonce = encryptedKey.slice(0, 24);
    const sealed = encryptedKey.slice(24);

    return naclOpen(
        sealed,
        nonce,
        senderPublicKey,
        recipientSecretKey
    );
}

/**
 * 数组比较（时间恒定，防止时序攻击）
 */
export function arraysEqual(a: Uint8Array, b: Uint8Array): boolean {
    if (a.length !== b.length) return false;
    let result = 0;
    for (let i = 0; i < a.length; i++) {
        result |= a[i] ^ b[i];
    }
    return result === 0;
}
```

### 6.2 创建加密命盘

```typescript
// create-encrypted-chart.ts

import { ApiPromise } from '@polkadot/api';
import { KeyringPair } from '@polkadot/keyring/types';
import { blake2AsU8a } from '@polkadot/util-crypto';
import {
    generateDataKey,
    encryptWithAES,
    encryptKeyForRecipient,
    generateX25519KeyPair,
} from './crypto-utils';

interface BirthData {
    year: number;
    month: number;
    day: number;
    hour: number;
    minute: number;
    zishiMode: number;
    longitude?: number;
    inputCalendarType: number;
    name?: string;
    notes?: string;
}

interface X25519KeyPair {
    publicKey: Uint8Array;
    secretKey: Uint8Array;
}

interface AuthorizedParty {
    account: string;
    x25519PublicKey: Uint8Array;  // X25519 公钥，不是账户公钥！
    role: 'Master' | 'Family' | 'AiService';
    scope: 'ReadOnly' | 'CanComment' | 'FullAccess';
    durationBlocks?: number;
}

/**
 * 创建支持多方授权的加密命盘
 *
 * 流程：
 * 1. 生成随机 DataKey
 * 2. 用 DataKey 加密敏感数据
 * 3. 用各方 X25519 公钥分别加密 DataKey
 * 4. 提交交易到链上
 *
 * @param api - Polkadot API 实例
 * @param signer - 用户账户（KeyringPair，用于签名交易）
 * @param ownerX25519 - 所有者的 X25519 密钥对（用于加密）
 * @param sizhuIndex - 四柱索引
 * @param gender - 性别
 * @param birthData - 出生数据（将被加密）
 * @param authorizedParties - 初始授权方列表
 * @returns 命盘 ID
 */
export async function createEncryptedChart(
    api: ApiPromise,
    signer: KeyringPair,
    ownerX25519: X25519KeyPair,
    sizhuIndex: any,
    gender: number,
    birthData: BirthData,
    authorizedParties: AuthorizedParty[] = []
): Promise<number> {
    // 1. 生成随机数据密钥（每个命盘独立）
    const dataKey = generateDataKey();

    // 2. 加密敏感数据
    const plaintext = JSON.stringify(birthData);
    const { ciphertext, nonce, tag } = await encryptWithAES(plaintext, dataKey);

    // 3. 计算数据哈希（用于验证解密正确性）
    const dataHash = blake2AsU8a(new TextEncoder().encode(plaintext), 256);

    // 4. 为每个授权方加密数据密钥
    const encryptedKeys = [];

    // 4.1 所有者的加密密钥（用自己的 X25519 密钥对）
    const ownerEncryptedKey = encryptKeyForRecipient(
        dataKey,
        ownerX25519.publicKey,    // 接收方公钥 = 自己
        ownerX25519.secretKey     // 发送方私钥 = 自己
    );

    encryptedKeys.push({
        account: signer.address,
        encrypted_key: Array.from(ownerEncryptedKey),
        role: { Owner: null },
        scope: { FullAccess: null },
        granted_at: 0,  // 链上会填充
        expires_at: 0,  // 永不过期
    });

    // 4.2 其他授权方的加密密钥
    for (const party of authorizedParties) {
        const encryptedKey = encryptKeyForRecipient(
            dataKey,
            party.x25519PublicKey,    // 接收方的 X25519 公钥
            ownerX25519.secretKey     // 发送方（所有者）的 X25519 私钥
        );

        encryptedKeys.push({
            account: party.account,
            encrypted_key: Array.from(encryptedKey),
            role: { [party.role]: null },
            scope: { [party.scope]: null },
            granted_at: 0,
            expires_at: party.durationBlocks || 0,
        });
    }

    // 5. 提交交易
    return new Promise((resolve, reject) => {
        api.tx.baziChart.createEncryptedChart(
            sizhuIndex,
            gender,
            Array.from(ciphertext),
            Array.from(nonce),
            Array.from(tag),
            encryptedKeys,
            Array.from(dataHash)
        ).signAndSend(signer, ({ status, events }) => {
            if (status.isInBlock) {
                // 从事件中提取 chart_id
                const event = events.find(e =>
                    e.event.section === 'baziChart' &&
                    e.event.method === 'EncryptedChartCreated'
                );
                if (event) {
                    const chartId = event.event.data[1].toNumber();
                    resolve(chartId);
                }
            }
        }).catch(reject);
    });
}

/**
 * 首次使用前，注册用户的 X25519 公钥到链上
 */
export async function registerEncryptionKey(
    api: ApiPromise,
    signer: KeyringPair,
    x25519PublicKey: Uint8Array
): Promise<void> {
    await api.tx.baziChart.registerEncryptionKey(
        Array.from(x25519PublicKey)
    ).signAndSend(signer);
}
```

### 6.3 解密命盘数据

```typescript
// decrypt-chart.ts

import { ApiPromise } from '@polkadot/api';
import { blake2AsU8a } from '@polkadot/util-crypto';
import { decryptWithAES, decryptKeyFromSender, arraysEqual } from './crypto-utils';

interface X25519KeyPair {
    publicKey: Uint8Array;
    secretKey: Uint8Array;
}

interface BirthData {
    year: number;
    month: number;
    day: number;
    hour: number;
    minute: number;
    zishiMode: number;
    longitude?: number;
    inputCalendarType: number;
    name?: string;
    notes?: string;
}

/**
 * 解密命盘数据
 *
 * 流程：
 * 1. 从链上读取加密命盘
 * 2. 检查访问权限和过期时间
 * 3. 从链上获取所有者的 X25519 公钥
 * 4. 用自己的 X25519 私钥解密 DataKey
 * 5. 用 DataKey 解密敏感数据
 * 6. 验证数据完整性
 *
 * @param api - Polkadot API 实例
 * @param chartId - 命盘 ID
 * @param myAddress - 当前账户地址
 * @param myX25519 - 当前账户的 X25519 密钥对
 * @returns 解密后的敏感数据
 */
export async function decryptBaziChart(
    api: ApiPromise,
    chartId: number,
    myAddress: string,
    myX25519: X25519KeyPair
): Promise<BirthData> {
    // 1. 从链上读取加密命盘
    const chartOpt = await api.query.baziChart.encryptedChartById(chartId);
    if (chartOpt.isNone) {
        throw new Error('命盘不存在');
    }

    const chart = chartOpt.unwrap();

    // 2. 查找自己的加密密钥
    const myKeyEntry = chart.encrypted_keys.find(
        entry => entry.account.toString() === myAddress
    );

    if (!myKeyEntry) {
        throw new Error('无权访问此命盘');
    }

    // 3. 检查授权是否过期
    if (myKeyEntry.expires_at.toNumber() > 0) {
        const currentBlock = (await api.query.system.number()).toNumber();
        if (currentBlock > myKeyEntry.expires_at.toNumber()) {
            throw new Error('授权已过期');
        }
    }

    // 4. 获取所有者的 X25519 公钥（从链上存储读取）
    const ownerAddress = chart.owner.toString();
    const ownerX25519PublicKey = await api.query.baziChart.userEncryptionKeys(ownerAddress);
    if (ownerX25519PublicKey.isNone) {
        throw new Error('所有者未注册加密公钥');
    }

    // 5. 解密数据密钥
    const encryptedKey = new Uint8Array(myKeyEntry.encrypted_key.toU8a());

    const dataKey = decryptKeyFromSender(
        encryptedKey,
        new Uint8Array(ownerX25519PublicKey.unwrap()),  // 发送方（所有者）的 X25519 公钥
        myX25519.secretKey                              // 接收方（自己）的 X25519 私钥
    );

    if (!dataKey) {
        throw new Error('密钥解密失败');
    }

    // 6. 解密数据
    const ciphertext = new Uint8Array(chart.encrypted_data.toU8a());
    const nonce = new Uint8Array(chart.nonce);
    const tag = new Uint8Array(chart.auth_tag);

    const decryptedText = await decryptWithAES(ciphertext, nonce, tag, dataKey);

    // 7. 验证数据哈希
    const dataHash = blake2AsU8a(new TextEncoder().encode(decryptedText), 256);
    const storedHash = new Uint8Array(chart.data_hash);

    if (!arraysEqual(dataHash, storedHash)) {
        throw new Error('数据完整性校验失败');
    }

    // 8. 解析并返回
    return JSON.parse(decryptedText);
}

/**
 * 检查是否有访问权限（只读取链上数据，不解密）
 */
export async function checkChartAccess(
    api: ApiPromise,
    chartId: number,
    account: string
): Promise<{ hasAccess: boolean; role?: string; scope?: string; expiresAt?: number }> {
    const chartOpt = await api.query.baziChart.encryptedChartById(chartId);
    if (chartOpt.isNone) {
        return { hasAccess: false };
    }

    const chart = chartOpt.unwrap();
    const keyEntry = chart.encrypted_keys.find(
        entry => entry.account.toString() === account
    );

    if (!keyEntry) {
        return { hasAccess: false };
    }

    // 检查过期
    if (keyEntry.expires_at.toNumber() > 0) {
        const currentBlock = (await api.query.system.number()).toNumber();
        if (currentBlock > keyEntry.expires_at.toNumber()) {
            return { hasAccess: false };
        }
    }

    return {
        hasAccess: true,
        role: Object.keys(keyEntry.role.toHuman())[0],
        scope: Object.keys(keyEntry.scope.toHuman())[0],
        expiresAt: keyEntry.expires_at.toNumber() || undefined,
    };
}
```

### 6.4 授权管理

```typescript
// grant-access.ts

import { ApiPromise } from '@polkadot/api';
import { KeyringPair } from '@polkadot/keyring/types';
import { encryptKeyForRecipient, decryptKeyFromSender } from './crypto-utils';

interface X25519KeyPair {
    publicKey: Uint8Array;
    secretKey: Uint8Array;
}

/**
 * 授权新用户访问命盘
 *
 * 流程：
 * 1. 从链上读取命盘
 * 2. 从链上获取自己的 X25519 公钥（用于解密）
 * 3. 解密自己的 DataKey
 * 4. 从链上获取被授权方的 X25519 公钥
 * 5. 用被授权方 X25519 公钥重新加密 DataKey
 * 6. 提交授权交易
 *
 * @param api - Polkadot API 实例
 * @param signer - 所有者账户（用于签名交易）
 * @param ownerX25519 - 所有者的 X25519 密钥对
 * @param chartId - 命盘 ID
 * @param granteeAccount - 被授权账户地址
 * @param role - 授权角色
 * @param scope - 访问范围
 * @param durationBlocks - 有效期（区块数）
 */
export async function grantAccess(
    api: ApiPromise,
    signer: KeyringPair,
    ownerX25519: X25519KeyPair,
    chartId: number,
    granteeAccount: string,
    role: 'Master' | 'Family' | 'AiService',
    scope: 'ReadOnly' | 'CanComment' | 'FullAccess',
    durationBlocks?: number
): Promise<void> {
    // 1. 读取命盘
    const chartOpt = await api.query.baziChart.encryptedChartById(chartId);
    if (chartOpt.isNone) {
        throw new Error('命盘不存在');
    }

    const chart = chartOpt.unwrap();

    // 2. 验证是所有者
    if (chart.owner.toString() !== signer.address) {
        throw new Error('只有所有者可以授权');
    }

    // 3. 解密自己的数据密钥
    const myKeyEntry = chart.encrypted_keys.find(
        entry => entry.account.toString() === signer.address
    );

    if (!myKeyEntry) {
        throw new Error('找不到所有者密钥条目');
    }

    const encryptedKey = new Uint8Array(myKeyEntry.encrypted_key.toU8a());

    // 所有者自己加密的，用自己的公钥解密
    const dataKey = decryptKeyFromSender(
        encryptedKey,
        ownerX25519.publicKey,    // 发送方 = 自己
        ownerX25519.secretKey     // 接收方 = 自己
    );

    if (!dataKey) {
        throw new Error('密钥解密失败');
    }

    // 4. 获取被授权方的 X25519 公钥
    const granteeX25519PublicKey = await api.query.baziChart.userEncryptionKeys(granteeAccount);
    if (granteeX25519PublicKey.isNone) {
        // 尝试从服务提供者获取
        const provider = await api.query.baziChart.providers(granteeAccount);
        if (provider.isNone) {
            throw new Error('被授权方未注册加密公钥');
        }
        // 使用服务提供者的公钥
    }

    const granteePublicKey = granteeX25519PublicKey.isSome
        ? new Uint8Array(granteeX25519PublicKey.unwrap())
        : new Uint8Array((await api.query.baziChart.providers(granteeAccount)).unwrap().public_key);

    // 5. 用被授权方公钥加密数据密钥
    const newEncryptedKey = encryptKeyForRecipient(
        dataKey,
        granteePublicKey,         // 接收方的 X25519 公钥
        ownerX25519.secretKey     // 发送方（所有者）的 X25519 私钥
    );

    // 6. 提交授权交易
    await api.tx.baziChart.grantChartAccess(
        chartId,
        granteeAccount,
        Array.from(newEncryptedKey),
        { [role]: null },
        { [scope]: null },
        durationBlocks || null
    ).signAndSend(signer);
}

/**
 * 撤销授权
 */
export async function revokeAccess(
    api: ApiPromise,
    signer: KeyringPair,
    chartId: number,
    revokedAccount: string
): Promise<void> {
    await api.tx.baziChart.revokeChartAccess(
        chartId,
        revokedAccount
    ).signAndSend(signer);
}

/**
 * 批量撤销所有授权
 */
export async function revokeAllAccess(
    api: ApiPromise,
    signer: KeyringPair,
    chartId: number
): Promise<void> {
    await api.tx.baziChart.revokeAllAccess(chartId)
        .signAndSend(signer);
}
```

---

## 七、安全分析

### 7.1 威胁模型

| 威胁 | 风险等级 | 缓解措施 |
|------|----------|----------|
| **链上数据泄露** | 低 | 敏感数据 AES-256-GCM 加密，只有密钥持有者可解密 |
| **服务提供者滥用** | 中 | 时间限制授权 + 可撤销 + 链上审计日志 |
| **用户私钥泄露** | 高 | 建议使用硬件钱包；支持密钥轮换重新加密 |
| **重放攻击** | 低 | 每个授权有唯一 granted_at 时间戳 |
| **中间人攻击** | 低 | 公钥与链上账户绑定验证 |
| **撤销后访问** | 中 | 告知用户风险；建立信用体系 |

### 7.2 隐私保护层级

```
┌─────────────────────────────────────────────────────────────────┐
│  Layer 0: 区块链公开数据                                         │
│  - 账户地址、交易记录、授权操作                                    │
├─────────────────────────────────────────────────────────────────┤
│  Layer 1: 四柱索引（公开）                                        │
│  - 可用于免费解盘计算                                             │
│  - 无法反推出生时间                                               │
│  - 8 bytes，信息有限                                             │
├─────────────────────────────────────────────────────────────────┤
│  Layer 2: 加密敏感数据（仅授权方可见）                              │
│  - 出生时间、地点、备注等                                          │
│  - 需要有效授权 + 私钥才能解密                                      │
├─────────────────────────────────────────────────────────────────┤
│  Layer 3: 数据密钥（短暂存在）                                     │
│  - 随机生成，加密后分发                                            │
│  - 明文仅在前端内存中短暂存在                                       │
├─────────────────────────────────────────────────────────────────┤
│  Layer 4: 账户私钥（仅用户持有）                                   │
│  - 钱包管理，用于签名和解密                                        │
│  - 永不上链、永不暴露                                              │
└─────────────────────────────────────────────────────────────────┘
```

### 7.3 授权撤销后的安全性

```
撤销授权后：
┌──────────────────────────────────────────────────────────────────┐
│  1. 链上标记立即移除 encrypted_key                                │
│  2. 被撤销方无法再从链上读取自己的加密密钥                          │
│  3. 即使之前保存了 encrypted_key，也无法继续解密                    │
│     - 因为需要 owner 的公钥来完成密钥交换                          │
│  4. 但如果之前已解密并保存了明文数据，链上无法阻止                   │
│                                                                    │
│  ⚠️ 缓解措施：                                                     │
│  - 授权时明确告知用户此风险                                         │
│  - 只授权给信任的命理师                                             │
│  - 平台建立命理师信用体系                                           │
│  - 设置合理的授权时限（如 7 天）                                    │
└──────────────────────────────────────────────────────────────────┘
```

---

## 八、成本分析

### 8.1 存储成本

| 数据项 | 大小（bytes） | 说明 |
|--------|--------------|------|
| EncryptedBaziChart 基础 | ~400 | 不含授权 |
| 每个 EncryptedKeyEntry | ~100 | 含加密密钥和元数据 |
| 最大存储（10个授权） | ~1400 | 基础 + 10×100 |
| ServiceProvider | ~80 | 提供者注册信息 |

### 8.2 Gas 费用估算

| 操作 | 估算费用 | 说明 |
|------|----------|------|
| 创建命盘（无授权） | ~0.01 DUST | 基础费用 |
| 创建命盘（3个授权） | ~0.015 DUST | 含密钥存储 |
| 创建命盘（10个授权） | ~0.025 DUST | 最大授权 |
| 授权新用户 | ~0.005 DUST | 添加单个密钥 |
| 撤销授权 | ~0.003 DUST | 移除单个密钥 |
| 批量撤销 | ~0.008 DUST | 移除所有非 Owner |
| 注册服务提供者 | ~0.005 DUST | 一次性 |

### 8.3 性能评估

| 操作 | 前端耗时 | 说明 |
|------|----------|------|
| 生成数据密钥 | <1ms | 随机生成 |
| AES 加密 | ~10ms | 256 bytes 数据 |
| 密钥加密（每个） | ~5ms | NaCl box |
| 密钥解密 | ~5ms | NaCl unbox |
| AES 解密 | ~10ms | 256 bytes 数据 |

---

## 九、事件定义

```rust
#[pallet::event]
#[pallet::generate_deposit(pub(super) fn deposit_event)]
pub enum Event<T: Config> {
    /// 服务提供者注册
    ProviderRegistered {
        account: T::AccountId,
        provider_type: ServiceProviderType,
    },

    /// 服务提供者公钥更新
    ProviderKeyUpdated {
        account: T::AccountId,
    },

    /// 服务提供者注销
    ProviderDeregistered {
        account: T::AccountId,
    },

    /// 加密命盘创建
    EncryptedChartCreated {
        owner: T::AccountId,
        chart_id: u64,
        initial_grants: u8,
    },

    /// 命盘访问授权
    ChartAccessGranted {
        chart_id: u64,
        owner: T::AccountId,
        grantee: T::AccountId,
        role: AccessRole,
        scope: AccessScope,
        expires_at: u32,
    },

    /// 命盘访问撤销
    ChartAccessRevoked {
        chart_id: u64,
        owner: T::AccountId,
        revokee: T::AccountId,
    },

    /// 批量撤销所有访问
    AllAccessRevoked {
        chart_id: u64,
        owner: T::AccountId,
        count: u8,
    },
}
```

---

## 十、错误定义

```rust
#[pallet::error]
pub enum Error<T> {
    // === 服务提供者错误 ===
    /// 提供者已注册
    ProviderAlreadyRegistered,
    /// 提供者未注册
    ProviderNotRegistered,
    /// 无效的公钥
    InvalidPublicKey,

    // === 命盘错误 ===
    /// 命盘不存在
    ChartNotFound,
    /// 非命盘所有者
    NotOwner,
    /// 命盘数量超限
    TooManyCharts,
    /// 命盘 ID 溢出
    ChartIdOverflow,
    /// 无效的四柱索引
    InvalidSiZhuIndex,

    // === 授权错误 ===
    /// 缺少所有者密钥
    MissingOwnerKey,
    /// 授权数量超限
    TooManyAuthorizations,
    /// 不能授权给自己
    CannotGrantToSelf,
    /// 已经授权过
    AlreadyGranted,
    /// 授权不存在
    GrantNotFound,
    /// 不能撤销所有者权限
    CannotRevokeOwner,
    /// 授权已过期
    AuthorizationExpired,

    // === 加密错误 ===
    /// 加密数据过长
    EncryptedDataTooLong,
    /// 加密密钥无效
    InvalidEncryptedKey,
    /// 数据哈希不匹配
    DataHashMismatch,
}
```

---

## 十一、实施路线图

### Phase 1：核心功能（预计 1.5 周）

- [ ] 新增数据结构（`EncryptedBaziChart`、`EncryptedKeyEntry`、`AccessRole`、`AccessScope`）
- [ ] 实现 `create_encrypted_chart` 接口
- [ ] 实现 `grant_chart_access` 接口
- [ ] 实现 `revoke_chart_access` 和 `revoke_all_access` 接口
- [ ] 编写单元测试

### Phase 2：服务提供者系统（预计 1 周）

- [ ] 实现服务提供者注册/注销
- [ ] 实现公钥管理
- [ ] 实现提供者授权索引（`ProviderGrants`）
- [ ] 编写集成测试

### Phase 3：前端集成（预计 1.5 周）

- [ ] 实现加密工具库（TypeScript）
- [ ] 实现创建加密命盘 UI
- [ ] 实现授权管理界面
- [ ] 实现解密查看功能
- [ ] 命理师选择器组件

### Phase 4：Runtime API（预计 0.5 周）

- [ ] `get_encrypted_chart` - 获取加密命盘（不含敏感数据）
- [ ] `get_chart_access_list` - 获取命盘授权列表
- [ ] `get_provider_charts` - 获取提供者可访问的命盘
- [ ] `check_access` - 检查访问权限

### Phase 5：安全审计与优化（预计 1 周）

- [ ] 密码学实现审计
- [ ] 边界条件测试
- [ ] 性能优化
- [ ] 文档完善

---

## 十二、附录

### A. 密码学库选择

| 功能 | Rust（链上） | TypeScript（前端） |
|------|-------------|-------------------|
| 哈希 | `sp_core::hashing::blake2_256` | `@polkadot/util-crypto: blake2AsU8a` |
| 对称加密 | N/A（前端执行） | `Web Crypto API: AES-GCM` |
| 非对称加密 | N/A（前端执行） | `@polkadot/util-crypto: naclEncrypt/naclDecrypt` |
| 密钥交换 | N/A（前端执行） | `@polkadot/util-crypto: naclBox` |

### B. 与现有系统的兼容性

如果已有旧版本的加密命盘，可以通过以下方式迁移：

```rust
/// 从旧版本升级（需要前端配合）
///
/// 流程：
/// 1. 前端解密旧版本命盘获取明文数据
/// 2. 使用明文数据调用 create_encrypted_chart
/// 3. 成功后删除旧命盘
#[pallet::call_index(30)]
pub fn migrate_old_chart(
    origin: OriginFor<T>,
    old_chart_id: u64,
    // 新版本创建参数...
) -> DispatchResult;
```

### C. 简化设计对比原设计的优势

| 对比项 | 原设计 | 简化设计 | 改进 |
|--------|--------|----------|------|
| **密钥层级** | 4层（主密钥→会话密钥→数据密钥→分发） | 2层（账户密钥→数据密钥） | 减少50%复杂度 |
| **前端缓存** | SessionStorage 缓存会话密钥 | 不需要缓存 | 代码更简洁 |
| **签名次数** | 首次登录1次，后续无需 | 每次操作可能需要（取决于钱包） | 换取架构简洁性 |
| **代码行数** | ~2000行 | ~1200行 | 减少40% |
| **安全性** | 高 | 高（相同） | 无降低 |
| **可维护性** | 中 | 高 | 显著提升 |

---

## 十三、总结

本简化设计相比原设计的核心改进：

### ✅ 保留的核心功能

1. **多方授权访问** - 命理师、AI、家族成员
2. **细粒度权限控制** - 角色、范围、时间限制
3. **加密存储** - AES-256-GCM + NaCl box
4. **可撤销授权** - 立即生效
5. **链上审计** - 完全透明

### ✨ 简化的设计

1. **移除会话密钥层** - 不参与实际加密，纯粹多余
2. **直接使用账户密钥** - 标准 Polkadot 钱包即可
3. **减少派生算法** - 标准密码学库足够
4. **无需前端缓存** - 代码更简洁

### 🎯 设计原则

- **简洁优于复杂** - KISS（Keep It Simple, Stupid）
- **标准优于自定义** - 使用行业标准算法
- **实用优于理论** - 满足需求即可
- **可维护性第一** - 未来开发者容易理解

**合理性评分：⭐⭐⭐⭐⭐ (5/5)**
**可行性评分：⭐⭐⭐⭐⭐ (5/5)**
**简洁性评分：⭐⭐⭐⭐⭐ (5/5)**

**强烈推荐实施！**
