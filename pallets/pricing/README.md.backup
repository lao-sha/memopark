# pallet-pricing（价格源）

## 概述

提供两大功能：
1. **链上价格预言机**：由治理/白名单账户喂价（传统功能）
2. **OTC & Bridge 均价统计**：维护最近累计 1,000,000 MEMO 的订单均价（新功能）

---

## 一、价格预言机（传统功能）

### 存储
- `Price`：当前报价（分子/分母/时间戳）
- `PricingParams`：参数（过期阈值、跳变限制、暂停开关）
- `Feeders`：喂价白名单

### 接口
- `set_price(price_num, price_den)`：治理/白名单喂价
- `set_params(stale_seconds, max_jump_bps)`：更新参数（Root）
- `set_pause(on)`：暂停/恢复（Root）
- `set_feeders(feeders)`：维护白名单（Root）

### 风控
- 价格过期检测：超过 `stale_seconds` 视为陈旧
- 跳变限制：单次价格变动不超过 `max_jump_bps`（万分比）

---

## 二、均价统计（新功能）

### 功能说明

维护两个独立的滑动窗口，分别统计：
1. **OTC 订单均价**：最近累计 1,000,000 MEMO 的 OTC 订单成交均价
2. **Bridge 兑换均价**：最近累计 1,000,000 MEMO 的桥接兑换均价

### 数据结构

#### 聚合数据
```rust
pub struct PriceAggregateData {
    pub total_memo: u128,       // 累计 MEMO 数量（10^12 精度）
    pub total_usdt: u128,       // 累计 USDT 金额（10^6 精度）
    pub order_count: u32,       // 订单数量
    pub oldest_index: u32,      // 最旧订单索引
    pub newest_index: u32,      // 最新订单索引
}
```

#### 订单快照（循环缓冲区）
```rust
pub struct OrderSnapshot {
    pub timestamp: u64,     // 时间戳（毫秒）
    pub price_usdt: u64,    // USDT 单价（10^6 精度）
    pub memo_qty: u128,     // MEMO 数量（10^12 精度）
}
```

### 存储

| 存储项 | 类型 | 说明 |
|--------|------|------|
| `OtcPriceAggregate` | `PriceAggregateData` | OTC 订单聚合数据 |
| `OtcOrderRingBuffer` | `Map<u32, OrderSnapshot>` | OTC 订单循环缓冲区（0-9999） |
| `BridgePriceAggregate` | `PriceAggregateData` | Bridge 兑换聚合数据 |
| `BridgeOrderRingBuffer` | `Map<u32, OrderSnapshot>` | Bridge 兑换循环缓冲区（0-9999） |

### 核心方法（聚合统计）

#### 1. 添加订单
```rust
pub fn add_otc_order(timestamp: u64, price_usdt: u64, memo_qty: u128) -> DispatchResult
pub fn add_bridge_swap(timestamp: u64, price_usdt: u64, memo_qty: u128) -> DispatchResult
```

**逻辑**：
1. 如果累计 MEMO 超过 1,000,000，删除最旧订单
2. 添加新订单到循环缓冲区
3. 更新聚合统计
4. 发出事件

**时间复杂度**：O(1) amortized（通常删除 0-10 个旧订单）

#### 2. 计算均价
```rust
pub fn get_otc_average_price() -> u64  // 返回 USDT/MEMO（10^6 精度）
pub fn get_bridge_average_price() -> u64
```

**公式**：
```
均价 = (total_usdt * 10^12) / total_memo
```

**时间复杂度**：O(1)

#### 3. 获取统计信息
```rust
pub fn get_otc_stats() -> (u128, u128, u32, u64)     // (累计MEMO, 累计USDT, 订单数, 均价)
pub fn get_bridge_stats() -> (u128, u128, u32, u64)
```

---

### 市场价格计算（新功能）

#### 1. 简单平均价格
```rust
pub fn get_memo_reference_price() -> u64  // 返回 USDT/MEMO（10^6 精度）
```

**算法**：
```
if OTC均价 == 0 && Bridge均价 == 0:
    返回 0  // 无数据
elif OTC均价 == 0:
    返回 Bridge均价  // 只有 Bridge
elif Bridge均价 == 0:
    返回 OTC均价  // 只有 OTC
else:
    返回 (OTC均价 + Bridge均价) / 2  // 简单平均
```

**用途**：
- 前端显示参考价格
- 价格偏离度计算
- 简单的市场概览

---

#### 2. 加权平均价格（推荐）
```rust
pub fn get_memo_market_price_weighted() -> u64  // 返回 USDT/MEMO（10^6 精度）
```

**算法**：
```
加权平均 = (OTC总USDT + Bridge总USDT) / (OTC总MEMO + Bridge总MEMO)
```

**示例**：
```
OTC 市场:    900,000 MEMO @ 0.52 USDT/MEMO  = 468,000 USDT
Bridge 市场: 100,000 MEMO @ 0.48 USDT/MEMO  =  48,000 USDT
                                      ————————————————————
加权平均:    1,000,000 MEMO               = 516,000 USDT
           => 516,000 / 1,000,000 = 0.516 USDT/MEMO

简单平均:    (0.52 + 0.48) / 2 = 0.50 USDT/MEMO  ❌ 不准确

✅ 加权平均更准确反映市场情况（考虑交易量）
```

**优点**：
- ✅ 考虑交易量权重
- ✅ 大交易量市场的价格权重更高
- ✅ 符合市值加权指数的计算方式
- ✅ 更准确反映市场供需

**用途**：
- 资产估值（钱包总值计算）
- 清算价格参考
- 市场指数计算
- 动态费率计算

---

#### 3. 完整市场统计
```rust
pub fn get_market_stats() -> MarketStats
```

**返回结构**：
```rust
pub struct MarketStats {
    pub otc_price: u64,           // OTC 均价（10^6 精度）
    pub bridge_price: u64,        // Bridge 均价（10^6 精度）
    pub weighted_price: u64,      // 加权平均价格（10^6 精度）
    pub simple_avg_price: u64,    // 简单平均价格（10^6 精度）
    pub otc_volume: u128,         // OTC 交易量（10^12 精度）
    pub bridge_volume: u128,      // Bridge 交易量（10^12 精度）
    pub total_volume: u128,       // 总交易量（10^12 精度）
    pub otc_order_count: u32,     // OTC 订单数
    pub bridge_swap_count: u32,   // Bridge 兑换数
}
```

**用途**：
- 市场概况 Dashboard
- 价格比较和分析
- 交易量统计
- API 查询接口

### 事件
- `OtcOrderAdded { timestamp, price_usdt, memo_qty, new_avg_price }`
- `BridgeSwapAdded { timestamp, price_usdt, memo_qty, new_avg_price }`

### 集成方式

#### pallet-otc-order
订单放行时自动添加：
```rust
// 在 release() 和 arbitrate_release() 中
let _ = pallet_pricing::Pallet::<T>::add_otc_order(timestamp, price_usdt, memo_qty);
```

#### pallet-simple-bridge
兑换完成时自动添加：
```rust
// 在 complete_swap() 中
let _ = pallet_pricing::Pallet::<T>::add_bridge_swap(timestamp, price_usdt, memo_qty);
```

---

## 设计优势

### 1. 高效性
- **均价计算 O(1)**：直接用聚合数据计算，无需遍历
- **添加订单 O(1) amortized**：循环缓冲区 + 聚合更新
- **存储可控**：最多 20,000 个槽位（OTC 10,000 + Bridge 10,000）

### 2. 灵活性
- 独立统计 OTC 和 Bridge 均价
- 自动维护滑动窗口（1,000,000 MEMO）
- 不影响原有订单和兑换流程

### 3. 可扩展性
- 可轻松添加更多统计维度（如按时间分组）
- 未来可用于动态定价
- 可作为链上价格预言机补充数据源

---

## 存储成本

| 项目 | 数量 | 单个大小 | 总大小 |
|------|------|----------|--------|
| 聚合数据 | 2 | 48 字节 | 96 字节 |
| 订单快照 | 最多 20,000 | 32 字节 | 640 KB |
| **总计** | - | - | **~640 KB** |

---

## 三、冷启动保护（新功能）

### 问题场景

**初期市场问题**：
- 系统刚上线，OTC 和 Bridge 交易量为 0
- 市场价格计算结果为 0 USDT/MEMO
- 用户无法判断 MEMO 的合理价格
- 少量异常交易可能严重扭曲价格

### 核心机制

**存储项**：
- `ColdStartThreshold`：冷启动阈值（默认 100,000,000 MEMO，即1亿）
- `DefaultPrice`：默认价格（默认 0.000001 USDT/MEMO，精度限制下的最小值）
- `ColdStartExited`：退出标记（单向锁定，不可逆）

**工作原理**：
```
if !ColdStartExited && (OTC_volume < threshold) && (Bridge_volume < threshold):
    return DefaultPrice  // 0.000001 USDT
else:
    ColdStartExited = true  // 永久退出
    return 加权平均价格
```

### 治理接口

```rust
pricing.setColdStartParams(threshold, default_price)  // 仅冷启动期间可调
```

### 事件

- `ColdStartExited`：退出冷启动（标志性事件）
- `ColdStartParamsUpdated`：参数更新

详见：`docs/价格冷启动方案分析.md`

---

## 使用示例

### 1. 前端查询单一市场均价
```javascript
// 获取 OTC 订单均价
const otcAvgPrice = await api.query.pricing.otcAggregate();
console.log(`OTC 均价: ${otcAvgPrice.total_usdt * 1e12 / otcAvgPrice.total_memo / 1e6} USDT/MEMO`);

// 或者直接调用辅助方法（如果导出为 RPC）
const avgPrice = await api.rpc.pricing.getOtcAveragePrice();
console.log(`OTC 均价: ${avgPrice / 1e6} USDT/MEMO`);
```

---

### 2. 前端查询市场加权价格（推荐）
```javascript
// 方法1：读取完整市场统计
const stats = await api.query.pricing.getMarketStats();
console.log(`
MEMO 市场价格（加权平均）: ${stats.weightedPrice / 1e6} USDT/MEMO
  ├─ OTC 均价:    ${stats.otcPrice / 1e6} USDT/MEMO
  ├─ Bridge 均价: ${stats.bridgePrice / 1e6} USDT/MEMO
  ├─ OTC 交易量:  ${(stats.otcVolume / 1e12).toFixed(0)} MEMO
  └─ Bridge 交易量: ${(stats.bridgeVolume / 1e12).toFixed(0)} MEMO
`);

// 方法2：只获取加权价格
const weightedPrice = await api.query.pricing.getMemoMarketPriceWeighted();
console.log(`MEMO 市场价: ${weightedPrice / 1e6} USDT/MEMO`);

// 方法3：获取参考价格（简单平均）
const refPrice = await api.query.pricing.getMemoReferencePrice();
console.log(`MEMO 参考价: ${refPrice / 1e6} USDT/MEMO`);
```

---

### 3. 市场概况 Dashboard（React 示例）
```typescript
// MarketOverview.tsx
import { Card, Statistic, Row, Col, Progress } from 'antd';

const MarketOverview = () => {
    const [stats, setStats] = useState(null);
    
    useEffect(() => {
        const fetchStats = async () => {
            const data = await api.query.pricing.getMarketStats();
            setStats({
                weightedPrice: data.weightedPrice.toNumber() / 1e6,
                otcPrice: data.otcPrice.toNumber() / 1e6,
                bridgePrice: data.bridgePrice.toNumber() / 1e6,
                otcVolume: data.otcVolume.toBigInt() / 1000000000000n,
                bridgeVolume: data.bridgeVolume.toBigInt() / 1000000000000n,
                totalVolume: data.totalVolume.toBigInt() / 1000000000000n,
            });
        };
        fetchStats();
    }, []);
    
    if (!stats) return <Spin />;
    
    const otcWeight = (stats.otcVolume / stats.totalVolume) * 100;
    const bridgeWeight = (stats.bridgeVolume / stats.totalVolume) * 100;
    
    return (
        <Card title="MEMO 市场概况">
            <Row gutter={16}>
                <Col span={8}>
                    <Statistic
                        title="市场价格（加权）"
                        value={stats.weightedPrice}
                        precision={6}
                        suffix="USDT"
                        valueStyle={{ color: '#3f8600' }}
                    />
                </Col>
                <Col span={8}>
                    <Statistic
                        title="总交易量"
                        value={Number(stats.totalVolume)}
                        suffix="MEMO"
                    />
                </Col>
                <Col span={8}>
                    <Statistic
                        title="市场活跃度"
                        value={otcWeight > 50 ? 'OTC主导' : 'Bridge主导'}
                    />
                </Col>
            </Row>
            
            <Divider />
            
            <Title level={5}>市场分布</Title>
            <Row gutter={16}>
                <Col span={12}>
                    <Text>OTC 市场</Text>
                    <Progress 
                        percent={otcWeight} 
                        format={() => `${stats.otcPrice.toFixed(6)} USDT`}
                    />
                    <Text type="secondary">
                        交易量: {Number(stats.otcVolume)} MEMO ({otcWeight.toFixed(1)}%)
                    </Text>
                </Col>
                <Col span={12}>
                    <Text>Bridge 市场</Text>
                    <Progress 
                        percent={bridgeWeight}
                        format={() => `${stats.bridgePrice.toFixed(6)} USDT`}
                    />
                    <Text type="secondary">
                        交易量: {Number(stats.bridgeVolume)} MEMO ({bridgeWeight.toFixed(1)}%)
                    </Text>
                </Col>
            </Row>
        </Card>
    );
};
```

---

### 4. 钱包资产估值
```typescript
// WalletBalance.tsx
const calculateWalletValue = async (memoBalance: bigint) => {
    const marketPrice = await api.query.pricing.getMemoMarketPriceWeighted();
    
    const memoAmount = Number(memoBalance) / 1e12;
    const usdtValue = (memoAmount * marketPrice) / 1e6;
    const cnyValue = usdtValue * 7.12;  // USDT → CNY
    
    return {
        memo: memoAmount,
        usdt: usdtValue,
        cny: cnyValue,
    };
};

// 显示
<Card title="钱包资产">
    <Descriptions>
        <Item label="MEMO 余额">{balance.memo.toFixed(2)}</Item>
        <Item label="估值 (USDT)">
            <Text strong>${balance.usdt.toFixed(2)}</Text>
        </Item>
        <Item label="估值 (CNY)">
            <Text strong>¥{balance.cny.toFixed(2)}</Text>
        </Item>
    </Descriptions>
    <Text type="secondary">
        基于市场加权价格计算
    </Text>
</Card>
```

---

### 5. 价格偏离告警
```typescript
// PriceAlert.tsx
const checkPriceDeviation = async (listingPrice: number) => {
    const stats = await api.query.pricing.getMarketStats();
    const marketPrice = stats.weightedPrice.toNumber() / 1e6;
    const deviation = ((listingPrice - marketPrice) / marketPrice) * 100;
    
    if (Math.abs(deviation) > 10) {
        notification.warning({
            message: '价格偏离警告',
            description: (
                <div>
                    <p>该挂单价格: {listingPrice.toFixed(6)} USDT/MEMO</p>
                    <p>市场价格: {marketPrice.toFixed(6)} USDT/MEMO</p>
                    <p>偏离度: <Text strong>{deviation > 0 ? '+' : ''}{deviation.toFixed(2)}%</Text></p>
                </div>
            ),
            icon: <WarningOutlined style={{ color: '#faad14' }} />,
        });
    }
};
```

### 治理监控
```javascript
// 监控均价变化
api.query.system.events((events) => {
    events.forEach((record) => {
        const { event } = record;
        if (api.events.pricing.OtcOrderAdded.is(event)) {
            const { new_avg_price } = event.data;
            console.log(`新 OTC 均价: ${new_avg_price / 1e6} USDT/MEMO`);
        }
    });
});
```

---

## 未来规划

1. **动态定价**：Phase 2 使用均价作为动态汇率基础
2. **多维度统计**：按时间段、交易对分组统计
3. **RPC 导出**：提供便捷的查询接口
4. **告警机制**：价格异常波动自动告警

---

## 注意事项

1. **数据质量**：均价基于链上交易，可能被大额订单影响
2. **时间滞后**：统计基于已完成订单，不是实时报价
3. **不可篡改**：一旦添加到统计中，无法删除或修改
4. **错误处理**：添加订单失败不影响原有交易流程（忽略错误）
